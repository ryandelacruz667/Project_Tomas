<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <link rel="stylesheet" href="./resources/ol.css">
        <link rel="stylesheet" href="resources/fontawesome-all.min.css">
        <link href="resources/photon-geocoder-autocomplete.min.css" rel="stylesheet">
        <link rel="stylesheet" href="./resources/ol-layerswitcher.css">
        <link rel="stylesheet" href="./resources/qgis2web.css">
        <!-- Bootstrap Icons -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
        <!-- Bootstrap CSS for alert styles -->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
        <!-- Bootstrap JS for offcanvas -->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
        <style>
        html, body {
            background-color: #ffffff;
        }
        .ol-control > * {
            background-color: #f8f8f8!important;
            color: #444444!important;
            border-radius: 0px;
        }
        .ol-attribution a, .gcd-gl-input::placeholder, .search-layer-input-search::placeholder {
            color: #444444!important;
        }
        .search-layer-input-search {
            background-color: #f8f8f8!important;
        }
        .ol-control > *:focus, .ol-control >*:hover {
            background-color: rgba(248, 248, 248, 0.7)!important;
        } 
        .ol-control {
            background-color: rgba(255,255,255,.4) !important;
            padding: 2px !important;
        } 
        </style>

        <style>
        html, body, #map {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
        }

        body, html {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        #main-wrapper {
            display: flex;
            flex-direction: row;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        #left-pane {
            width: 320px;
            background: #23272f;
            color: #fff;
            height: 100vh;
            box-shadow: 2px 0 8px rgba(34,34,34,0.04);
            display: flex;
            flex-direction: column;
            padding: 0;
            z-index: 10;
            overflow: hidden;
            position: fixed;
            left: 0;
            top: 0;
        }
        
        /* Right pane removed - no longer needed */
        
        /* Family table styling */
        #family-table table {
            width: 100%;
            border-collapse: collapse;
            border-radius: 8px;
            overflow: hidden;
            font-size: 0.9rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        #family-table th, #family-table td {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            text-align: left;
        }
        
        #family-table th {
            background: #1e88e5;
            color: white;
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        #family-table tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }
        
        #family-table tr:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        #family-table td {
            color: #fafafa;
        }
        
        #family-table p {
            color: #fafafa;
            text-align: center;
            padding: 1rem;
            margin: 0;
        }
        
        /* Ensure all child elements inherit the dark background */
        #left-pane * {
            background-color: inherit;
        }
        
        /* Override any white backgrounds that might be inherited */
        #left-pane .sidebar-header,
        #left-pane .nav-bar,
        #left-pane .flood-section,
        #left-pane .flood-form-group,
        #left-pane .flood-legend-section {
            background: #23272f !important;
        }
        .sidebar-header {
            font-size: 1.6rem;
            font-weight: 700;
            text-align: left;
            padding: 1.5rem 1.5rem 0.8rem 1.5rem;
            letter-spacing: 0.3px;
            border-bottom: none;
            color: #fafafa;
            background: #23272f;
        }
        .sidebar-header span {
            border-bottom: 3px solid #24b2ff;
            padding-bottom: 0.2rem;
            color: #24b2ff;
            font-size: 1.3rem;
            display: inline-block;
            letter-spacing: 0.5px;
        }
        .sidebar-header.flood-header {
            /* Same as .sidebar-header but separate class for Flood Extent */
            font-size: 1.6rem;
            font-weight: 700;
            text-align: left;
            padding: 1.5rem 1.5rem 0.8rem 1.5rem;
            letter-spacing: 0.3px;
            border-bottom: none;
            color: #fafafa;
            background: #23272f;
        }
        .sidebar-header.flood-header span {
            border-bottom: 3px solid #f39c12;
            padding-bottom: 0.2rem;
            color: #f39c12;
            font-size: 1.3rem;
            display: inline-block;
            letter-spacing: 0.5px;
        }
        .nav-bar {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
            margin-top: 1rem;
            padding: 0 1.2rem;
        }
        .nav-btn {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            padding: 0.7rem 1rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            outline: none;
            background: none;
            color: #fafafa;
            transition: background 0.18s, color 0.18s;
            border-radius: 8px;
            cursor: pointer;
            letter-spacing: 0.5px;
        }
        .nav-btn i {
            font-size: 1.2rem;
        }
        .nav-btn:hover, .nav-btn.active {
            background: #24b2ff;
            color: #fff;
        }
        .nav-btn.is-disabled {
            opacity: 0.45;
            cursor: not-allowed;
            pointer-events: none;
            background: rgba(36, 178, 255, 0.08);
            color: #8d939f;
        }
        button.is-disabled {
            opacity: 0.5;
            cursor: not-allowed !important;
            pointer-events: none;
        }
        /* Flood hazard section style */
        .flood-section {
            margin-top: 1.5rem;
        }
        .flood-form-group {
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
            margin: 0 1.5rem 1rem 1.5rem;
        }
        .flood-form-label {
            font-size: 1.03rem;
            color: #f39c12;
            font-weight: 600;
            margin-bottom: 0.35rem;
            margin-left: 2px;
            letter-spacing: 0.5px;
        }
        .flood-modern-select {
            padding: 0.6rem 1rem;
            border: none;
            border-radius: 8px;
            background: #262a33;
            color: #fafafa;
            font-size: 1.08rem;
            font-weight: 500;
            outline: none;
            transition: background 0.14s;
            min-width: 135px;
            box-shadow: 0 0 0 1px #222326;
            position: relative;
            z-index: 1; /* Below charts panel (999) and table (1001) */
            overflow: visible;
        }
        .flood-modern-select:focus {
            background: #181b1f;
            box-shadow: 0 0 0 1.5px #f39c12;
            z-index: 100; /* Higher when focused to show dropdown options */
        }
        .flood-modern-select.is-disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }
        .flood-divider {
            border: none;
            border-top: 2px solid #444;
            margin: 1.2rem 2rem 0.5rem 2rem;
        }
        
        /* Flood Legend Styles */
        .flood-legend-section {
            margin: 0.8rem 2rem 0.8rem 2rem;
        }
        .flood-legend-section:first-of-type {
            margin: 1.5rem 2rem 1rem 2rem;
        }
        .flood-legend {
            background: #262a33;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 0.5rem;
            border: 1px solid #333;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 0.6rem;
            padding: 0.3rem 0;
        }
        .legend-item:last-child {
            margin-bottom: 0;
        }
        .legend-icon {
            width: 20px;
            height: 20px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        .legend-text {
            color: #fafafa;
            font-size: 0.95rem;
            font-weight: 500;
        }

        /* Top Pane Styles */
        #top-pane {
            position: fixed;
            left: 320px;
            top: 0;
            right: 600px; /* Account for right pane */
            height: 80px;
            background: #23272f;
            color: #fafafa;
            display: flex;
            align-items: center;
            z-index: 9;
            box-shadow: 0 2px 8px rgba(34,34,34,0.04);
            padding-left: 2.5rem;
            padding-right: 3rem;
        }
        
        .search-form {
            display: flex;
            align-items: center;
            gap: 1.8rem;
            width: 100%;
            max-width: 1200px;
            margin-left: 0;
        }
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
            flex: 1 1 auto;
            min-width: 0;
        }
        .form-label {
            font-size: 0.95rem;
            color: #24b2ff;
            font-weight: 600;
            margin-bottom: 0.25rem;
            margin-left: 2px;
            letter-spacing: 0.4px;
            white-space: nowrap;
        }
        .modern-select {
            padding: 0.7rem 1.1rem;
            border: none;
            border-radius: 8px;
            background: #262a33;
            color: #fafafa;
            font-size: 1rem;
            font-weight: 500;
            outline: none;
            transition: all 0.14s ease;
            min-width: 180px;
            width: 100%;
            max-width: 220px;
            height: 42px;
            box-sizing: border-box;
            box-shadow: 0 0 0 1px #222326;
            position: relative;
            z-index: 1; /* Below charts panel (999) and table (1001) */
            overflow: visible;
        }
        .modern-select:hover {
            background: #2a2e37;
            box-shadow: 0 0 0 1px #3a3f4a;
        }
        .modern-select:focus {
            background: #181b1f;
            box-shadow: 0 0 0 2px #24b2ff;
            z-index: 100; /* Higher when focused to show dropdown options */
        }
        .modern-multiselect {
            position: relative;
            min-width: 180px;
            width: 100%;
            max-width: 220px;
        }
        .multiselect-button {
            width: 100%;
            text-align: left;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
        }
        .multiselect-button::after {
            content: '\25BC';
            font-size: 0.8rem;
            color: #9aa0ae;
            transition: transform 0.2s ease;
        }
        .multiselect-button.is-open::after {
            transform: rotate(180deg);
        }
        .multiselect-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            right: 0;
            width: max-content;
            min-width: 180px;
            max-width: 280px;
            background: #262a33;
            border-radius: 10px;
            border: 1px solid #3a3f4a;
            padding: 0.6rem 0.85rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            display: none;
            max-height: 320px;
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 150;
        }
        /* Custom scrollbar for multiselect dropdown */
        .multiselect-dropdown::-webkit-scrollbar {
            width: 8px;
        }
        .multiselect-dropdown::-webkit-scrollbar-track {
            background: #1e2229;
            border-radius: 4px;
        }
        .multiselect-dropdown::-webkit-scrollbar-thumb {
            background: #3a3f4a;
            border-radius: 4px;
        }
        .multiselect-dropdown::-webkit-scrollbar-thumb:hover {
            background: #4a4f5a;
        }
        .multiselect-dropdown.is-open {
            display: block;
            animation: dropdownFade 0.18s ease;
        }
        .multiselect-option {
            display: flex;
            align-items: center;
            gap: 0.65rem;
            padding: 0.55rem 0.5rem;
            border-radius: 6px;
            transition: background 0.14s ease, color 0.14s ease;
            margin-bottom: 2px;
        }
        .multiselect-option:hover {
            background: rgba(36, 178, 255, 0.12);
        }
        .multiselect-option:last-child {
            margin-bottom: 0;
        }
        .multiselect-option input[type="checkbox"] {
            accent-color: #24b2ff;
            width: 17px;
            height: 17px;
            flex-shrink: 0;
            cursor: pointer;
        }
        .multiselect-option label {
            flex: 1;
            color: #e1e4eb;
            font-size: 0.94rem;
            cursor: pointer;
            user-select: none;
            line-height: 1.4;
            word-break: break-word;
        }
        .multiselect-empty {
            text-align: center;
            padding: 0.8rem 0.5rem;
            color: #9aa0ae;
            font-size: 0.91rem;
            font-style: italic;
        }
        @keyframes dropdownFade {
            from {
                opacity: 0;
                transform: translateY(-6px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .search-btn {
            padding: 0.65rem 2.1rem;
            border: none;
            border-radius: 10px;
            background: #24b2ff;
            color: #fff;
            font-size: 1.13rem;
            font-weight: 700;
            letter-spacing: 1px;
            cursor: pointer;
            transition: background 0.12s, box-shadow 0.15s;
            margin-left: 1.4rem;
            box-shadow: 0 2px 8px rgba(36,178,255,0.09);
        }
        .search-btn:hover {
            background: #189fd1;
            box-shadow: 0 2px 14px rgba(36,178,255,0.13);
        }

        /* Map container adjustments */
        #map-container {
            position: fixed;
            left: 320px;
            top: 80px; /* Below top-pane */
            right: 0; /* No right pane */
            bottom: 0;
            width: calc(100vw - 320px); /* 320px left only */
            height: calc(100vh - 80px);
            transition: left 0.3s ease, right 0.3s ease, width 0.3s ease;
        }
        
        /* Adjust map container when navigation bar is visible */
        #map-container.nav-bar-visible {
            top: calc(80px + var(--nav-bar-height, 0px)); /* Account for navigation bar height */
            height: calc(100vh - 80px - var(--nav-bar-height, 0px));
        }
        
        /* Adjust map container when offcanvas is shown */
        #map-container.offcanvas-open {
            right: 400px; /* Account for offcanvas width (default Bootstrap offcanvas-end width) */
            width: calc(100vw - 720px); /* 320px left + 400px offcanvas */
            transition: right 0.3s ease, width 0.3s ease;
        }
        
        /* Charts panel adjustments */
        #map-container.charts-open {
            right: 400px; /* 400px charts panel only */
            width: calc(100vw - 720px); /* 320px left + 400px charts */
        }
        
        /* Charts panel when offcanvas is also open */
        #map-container.charts-open.offcanvas-open {
            right: 800px; /* 400px offcanvas + 400px charts panel */
            width: calc(100vw - 1120px); /* 320px left + 400px offcanvas + 400px charts */
        }
        
        #charts-panel {
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            overflow-x: hidden;
            overflow-y: hidden;
            box-sizing: border-box;
            max-width: 100%;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 80px); /* Full viewport height minus top bar */
        }
        
        /* Contain all chart content within panel - use flex to fill height */
        #charts-panel > div {
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
            width: 100%;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        /* Chart container divs - fill available height */
        #charts-panel > div > div {
            width: 100% !important;
            max-width: 100% !important;
            box-sizing: border-box !important;
            overflow: hidden !important;
            flex: 1;
            min-height: 0;
            position: relative;
        }
        
        #charts-panel canvas {
            max-width: 100% !important;
            max-height: 100% !important;
            width: 100% !important;
            height: 100% !important;
            box-sizing: border-box !important;
            display: block;
        }
        
        /* Modern charts panel styling */
        #charts-panel h4 {
            color: #f39c12;
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid rgba(243, 156, 18, 0.3);
            padding-bottom: 0.5rem;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        /* Ensure no white background shows when panel is hidden */
        body {
            background-color: #1e2329 !important;
            overflow-x: hidden;
        }
        
        html {
            background-color: #1e2329 !important;
        }

        /* Top Navigation Bar - Contains all population exposure table elements */
        #top-navigation-bar {
            display: none; /* shown when 24m is selected */
            position: fixed;
            top: 80px; /* Below top-pane */
            left: 320px; /* Account for left pane */
            right: 0; /* No right pane */
            background: linear-gradient(135deg, rgba(35, 39, 47, 0.98) 0%, rgba(42, 47, 57, 0.98) 100%);
            color: #fafafa;
            border-bottom: 2px solid rgba(243, 156, 18, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 950; /* Below modals (1000) but above charts panel (999) */
            transition: right 0.3s ease, left 0.3s ease, width 0.3s ease;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            overflow-x: hidden;
            box-sizing: border-box;
        }
        
        /* Adjust navigation bar when offcanvas is open */
        #map-container.offcanvas-open #top-navigation-bar {
            right: 400px !important; /* 400px offcanvas */
        }
        
        /* Adjust navigation bar when charts panel is open */
        #map-container.charts-open #top-navigation-bar {
            right: 400px !important; /* 400px charts panel */
        }
        
        /* Adjust navigation bar when both offcanvas and charts are open */
        #map-container.charts-open.offcanvas-open #top-navigation-bar {
            right: 800px !important; /* 400px offcanvas + 400px charts panel */
        }
        
        /* Bootstrap Offcanvas Custom Styling */
        #offcanvasRight {
            width: 400px;
            background: #23272f;
            color: #fff;
        }
        
        #offcanvasRight .offcanvas-header {
            background: #24b2ff;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        #offcanvasRight .offcanvas-title {
            color: #fff;
            font-weight: 700;
        }
        
        #offcanvasRight .btn-close {
            filter: invert(1);
        }
        
        #offcanvasRight .offcanvas-body {
            background: #23272f;
            overflow-y: auto;
        }
        
        /* Right pane charts container in offcanvas */
        #offcanvasRight #right-pane-charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 16px;
            padding: 0;
        }
        
        /* Chart wrapper in offcanvas */
        #offcanvasRight .right-pane-chart-wrapper {
            width: 100%;
            height: 250px;
            position: relative;
            background: rgba(42, 47, 57, 0.4);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        #offcanvasRight .right-pane-chart-wrapper > div {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 0;
        }
        
        #offcanvasRight .right-pane-chart-wrapper canvas {
            max-width: 100% !important;
            max-height: 100% !important;
            width: 100% !important;
            height: 100% !important;
        }
        
        #offcanvasRight .age-chart-wrapper {
            height: 250px;
        }
        
        #offcanvasRight .right-pane-chart-wrapper h4 {
            margin: 0 0 8px 0;
            text-align: center;
            flex-shrink: 0;
        }
        
        #top-navigation-bar .nav-content {
            padding: 1rem 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            width: 100%;
            box-sizing: border-box;
        }
        
        /* Navigation bar header */
        #top-navigation-bar .nav-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        #top-navigation-bar #people-table-title {
            margin: 0;
            color: #f39c12;
            font-size: 1.2rem;
            font-weight: 700;
        }
        
        #top-navigation-bar #people-table-count {
            font-size: 0.9rem;
            color: #cccccc;
            font-weight: 500;
            margin-left: 8px;
        }
        
        /* Navigation bar filters */
        #top-navigation-bar #people-filters {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        /* Navigation bar table wrapper */
        #top-navigation-bar #people-table-wrapper {
            overflow-y: auto;
            overflow-x: auto;
            background: rgba(42, 47, 57, 0.5);
            border: 1px solid rgba(243, 156, 18, 0.2);
            border-radius: 8px;
            max-height: calc(100vh - 300px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            width: 100%;
            box-sizing: border-box;
        }
        
        /* Ensure all navigation bar child elements are responsive */
        #top-navigation-bar .nav-content,
        #top-navigation-bar #people-table-wrapper,
        #top-navigation-bar #people-24-table-inner {
            width: 100% !important;
            max-width: 100% !important;
            box-sizing: border-box;
        }
        
        /* Ensure table and its container are responsive */
        #people-24-table-inner {
            width: 100% !important;
            max-width: 100% !important;
            overflow-x: auto;
            box-sizing: border-box;
            table-layout: auto; /* Allow table to adjust column widths */
        }
        
        #people-table-wrapper {
            width: 100% !important;
            max-width: 100% !important;
            overflow-x: auto !important;
            overflow-y: auto !important;
            box-sizing: border-box;
        }
        
        /* Responsive adjustments when charts panel is open */
        #map-container.charts-open #top-navigation-bar .nav-content {
            padding-right: 0.5rem; /* Small gap from charts */
        }
        
        /* Set specific column widths for better fit */
        #people-24-table-inner th:nth-child(1),
        #people-24-table-inner td:nth-child(1) {
            width: 5%;
        }
        #people-24-table-inner th:nth-child(2),
        #people-24-table-inner td:nth-child(2) {
            width: 20%;
        }
        #people-24-table-inner th:nth-child(3),
        #people-24-table-inner td:nth-child(3),
        #people-24-table-inner th:nth-child(4),
        #people-24-table-inner td:nth-child(4),
        #people-24-table-inner th:nth-child(5),
        #people-24-table-inner td:nth-child(5),
        #people-24-table-inner th:nth-child(6),
        #people-24-table-inner td:nth-child(6),
        #people-24-table-inner th:nth-child(7),
        #people-24-table-inner td:nth-child(7),
        #people-24-table-inner th:nth-child(8),
        #people-24-table-inner td:nth-child(8),
        #people-24-table-inner th:nth-child(9),
        #people-24-table-inner td:nth-child(9) {
            width: 7%;
        }
        #people-24-table-inner th:nth-child(10),
        #people-24-table-inner td:nth-child(10) {
            width: 7%;
        }
        #people-24-table-inner th:nth-child(11),
        #people-24-table-inner td:nth-child(11) {
            width: 15%;
        }

        /* Lower pane removed - map is now directly in map-container */
        #map {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* Flood Data Table Styles */
        #flood-data-table {
            position: fixed;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(35, 39, 47, 0.95);
            color: #fafafa;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            max-width: 80%;
            max-height: 60vh;
            overflow-y: auto;
            display: none;
        }
        
        #flood-data-table h3 {
            margin: 0 0 1rem 0;
            color: #f39c12;
            font-size: 1.4rem;
            font-weight: 700;
            text-align: center;
            border-bottom: 2px solid #f39c12;
            padding-bottom: 0.5rem;
        }
        
        .flood-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            table-layout: fixed;
        }
        
        .flood-table th {
            background: #2a2f39;
            color: #f39c12;
            padding: 0.6rem 0.4rem;
            text-align: center;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border: 1px solid #444;
        }
        
        /* Modal Styles */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none; /* Allow clicks to pass through to map */
        }
        
        .modal-content {
            background: #2a2f39;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            position: relative;
            pointer-events: auto; /* Enable interaction with modal content */
        }

/* Maximize behavior for infographics modal */
.modal-content.maximized {
    width: 100% !important;
    max-width: none !important;
    height: 95vh !important;
}

        /* Simple loading spinner */
        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid #3a3f4a;
            border-top-color: #f39c12;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .loading-wrap {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1e2329;
        }
        .inline-error {
            color: #ff7675;
            background: #2a2f39;
            border: 1px solid #3a3f4a;
            padding: 12px 14px;
            border-radius: 8px;
            text-align: center;
        }

        /* Bright blue glow on hover for buttons */
        button, .nav-btn, .close-btn {
            transition: box-shadow 0.2s ease, border-color 0.2s ease;
        }
        button:hover, .nav-btn:hover, .close-btn:hover {
            border-color: #3ea8ff !important;
            box-shadow: 0 0 0 2px rgba(62, 168, 255, 0.35), 0 0 10px rgba(62, 168, 255, 0.6) inset;
        }

        /* Chat widget */
        .ai-chat-toggle {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 1200;
            background: #2a2f39;
            color: #fff;
            border: 1px solid #3a3f4a;
            padding: 10px 12px;
            border-radius: 999px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.4);
        }
        .ai-chat-callout {
            position: fixed;
            right: 92px; /* 20px (edge) + ~72px (toggle total width) */
            bottom: 28px;
            z-index: 1200;
            background: #243447;
            color: #ffffff;
            border: 1px solid #355070;
            border-radius: 22px;
            padding: 10px 14px;
            font-size: 14px;
            font-weight: 600;
            line-height: 1;
            white-space: nowrap;
            box-shadow: 0 6px 18px rgba(0,0,0,0.35);
            animation: aiCalloutPulse 2s ease-in-out infinite;
            transition: box-shadow 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
        }
        .ai-chat-callout::after {
            content: '';
            position: absolute;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 0; height: 0;
            border-left: 6px solid #243447;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
        }
        .ai-chat-callout:hover {
            border-color: #3ea8ff !important;
            box-shadow: 0 0 0 2px rgba(62, 168, 255, 0.35), 0 0 10px rgba(62, 168, 255, 0.6) inset, 0 8px 22px rgba(0,0,0,0.45);
            transform: translateY(-2px);
        }
        @keyframes aiCalloutPulse {
            0%, 100% { transform: translateY(0); box-shadow: 0 6px 18px rgba(0,0,0,0.35); }
            50% { transform: translateY(-2px); box-shadow: 0 8px 22px rgba(0,0,0,0.45); }
        }
        .ai-chat-panel {
            position: fixed;
            right: 20px;
            bottom: 76px;
            width: 340px;
            max-height: 70vh;
            display: none;
            flex-direction: column;
            background: #1e2329;
            border: 1px solid #3a3f4a;
            border-radius: 12px;
            overflow: hidden;
            z-index: 1200;
            box-shadow: 0 12px 30px rgba(0,0,0,0.5);
        }
        .ai-chat-header {
            padding: 10px 12px;
            background: #161b22;
            border-bottom: 1px solid #2a2f39;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .ai-chat-title { color: #f39c12; font-weight: 700; }
        .ai-chat-actions { display: flex; gap: 6px; }
        .ai-chat-body {
            padding: 10px 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 52vh;
        }
        .ai-msg { padding: 8px 10px; border-radius: 10px; max-width: 85%; }
        .ai-msg.user { background: #243447; align-self: flex-end; border: 1px solid #355070; }
        .ai-msg.assistant { background: #2a2f39; align-self: flex-start; border: 1px solid #3a3f4a; }
        .ai-chat-input {
            display: flex;
            gap: 8px;
            padding: 10px 12px;
            border-top: 1px solid #2a2f39;
            background: #1e2329;
        }
        .ai-chat-input input {
            flex: 1 1 auto;
            background: #14181d;
            color: #fff;
            border: 1px solid #3a3f4a;
            border-radius: 8px;
            padding: 8px 10px;
        }
        .ai-chat-input button { border-radius: 8px; background:#2a2f39; color:#fff; border:1px solid #3a3f4a; padding: 8px 10px; cursor: pointer; }
        .ai-key-hint { color:#8aa0b4; font-size: 12px; padding: 6px 12px; border-top: 1px dashed #2a2f39; }
        
        .modal-header {
            cursor: move;
            user-select: none;
        }
        
        .modal-header:hover {
            background: #252a33;
        }
        
        .modal-header {
            background: #1e2329;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h3 {
            margin: 0;
            color: #f39c12;
            font-size: 1.3rem;
            font-weight: 600;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #ccc;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .close-btn:hover {
            background-color: #444;
            color: #fff;
        }
        
        .modal-body {
            padding: 1.5rem;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .household-table {
            width: 100%;
            border-collapse: collapse;
            background: #1e2329;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .household-table th {
            background: #2a2f39;
            color: #fafafa;
            font-weight: 600;
            padding: 0.75rem 0.5rem;
            text-align: left;
            border-bottom: 2px solid #444;
            font-size: 0.9rem;
        }
        
        .household-table td {
            padding: 0.6rem 0.5rem;
            border-bottom: 1px solid #333;
            color: #e0e0e0;
            font-size: 0.85rem;
        }
        
        .household-table tbody tr:hover {
            background-color: #2a2f39;
        }
        
        .household-table tbody tr:last-child td {
            border-bottom: none;
        }
        
        .flood-table td {
            padding: 0.5rem 0.4rem;
            border: 1px solid #444;
            background: rgba(42, 47, 57, 0.5);
            color: #ffffff;
            font-weight: 500;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .flood-table tr:nth-child(even) td {
            background: rgba(42, 47, 57, 0.7);
        }
        
        .flood-table tr:hover td {
            background: rgba(243, 156, 18, 0.1);
        }
        .flood-table tbody tr.household-row-selected td {
            background: rgba(243, 156, 18, 0.25);
            color: #fff5d6;
            font-weight: 600;
        }
        
        .close-table-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #fafafa;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }
        
        .close-table-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        /* Layer Switcher Styles */
        .layer-switcher {
            background: rgba(35, 39, 47, 0.95);
            color: #fafafa;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .layer-switcher .panel {
            background: rgba(35, 39, 47, 0.95);
        }
        
        .layer-switcher label {
            color: #fafafa;
        }
        
        .layer-switcher input[type="checkbox"]:checked + label {
            color: #24b2ff;
        }

        /* Responsive Design - Multiple Screen Sizes */
        @media (max-width: 1400px) {
            #charts-panel {
                width: 350px;
            }
            #map-container.charts-open {
                right: 950px; /* 600px right pane + 350px charts panel */
                width: calc(100vw - 1270px); /* 320px left + 600px right + 350px charts */
            }
        }

        @media (max-width: 1200px) {
            #charts-panel {
                width: 300px;
            }
            #map-container.charts-open {
                right: 900px; /* 600px right pane + 300px charts panel */
                width: calc(100vw - 1220px); /* 320px left + 600px right + 300px charts */
            }
            #top-navigation-bar {
                max-height: 35vh;
            }
            #charts-panel {
                height: calc(100vh - 80px); /* Full height */
            }
        }

        @media (max-width: 1024px) {
            #charts-panel {
                width: 280px;
                padding: 1rem;
            }
            #map-container.charts-open {
                right: 880px; /* 600px right pane + 280px charts panel */
                width: calc(100vw - 1200px); /* 320px left + 600px right + 280px charts */
            }
            #top-navigation-bar {
                max-height: 30vh;
            }
            #charts-panel {
                height: calc(100vh - 80px); /* Full height */
            }
            #charts-panel h4 {
                font-size: 0.85rem;
            }
            /* Charts will flex to fill available height - no fixed heights */
            .flood-table {
                font-size: 0.75rem;
            }
            .flood-table th,
            .flood-table td {
                padding: 0.4rem 0.3rem;
            }
        }

        @media (max-width: 768px) {
            #left-pane {
                width: 280px;
            }
            #right-pane {
                width: 280px;
            }
            #map-container {
                left: 280px;
                right: 280px;
                width: calc(100vw - 560px);
            }
            #charts-panel {
                width: 250px;
                padding: 0.8rem;
            }
            #map-container.charts-open {
                left: 280px;
                right: 530px; /* 280px right pane + 250px charts panel */
                width: calc(100vw - 810px); /* 280px left + 280px right + 250px charts */
            }
            #top-navigation-bar {
                max-height: 25vh;
            }
            #charts-panel {
                height: calc(100vh - 80px); /* Full height */
            }
            /* Charts will flex to fill available height - no fixed heights */
            #people-filters {
                flex-direction: column;
                align-items: stretch !important;
            }
            #people-filters > div {
                width: 100%;
            }
            .modern-select {
                width: 100%;
                min-width: unset;
            }
        }

        @media (max-width: 640px) {
            #left-pane {
                width: 260px;
            }
            #map-container {
                left: 260px;
                width: calc(100vw - 260px);
            }
            #charts-panel {
                width: 100%;
                right: 0;
                top: 80px;
                bottom: 0;
                height: calc(100vh - 80px); /* Full height */
                border-left: none;
                border-top: 2px solid rgba(243, 156, 18, 0.3);
            }
            #map-container.charts-open {
                left: 260px;
                right: 0;
                width: calc(100vw - 260px);
                bottom: 0;
            }
            #top-navigation-bar {
                max-height: 30vh;
            }
            /* Charts will flex to fill available height - no fixed heights */
            .flood-modern-select,
            .modern-select {
                font-size: 0.95rem;
                padding: 0.5rem 0.8rem;
            }
        }

        /* Ensure selects in sidebar don't overflow charts */
        #left-pane select {
            max-width: 100%;
            box-sizing: border-box;
        }

        /* Prevent dropdowns from appearing over charts panel */
        #left-pane {
            position: relative;
            z-index: 100; /* Below table (950) and modals (1000) but above charts (999) when sidebar is open */
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Ensure charts panel stays on top */
        #charts-panel {
            position: fixed;
            z-index: 999;
        }

        /* Ensure table stays above charts but below modals */
        </style>
        <title>PROJECT TOMaS (Tactical Overlay for Mapping and Safety)</title>
    </head>
    <body>
        <div id="main-wrapper">
            <div id="left-pane">
                <div class="sidebar-header" style="background: #24b2ff; border-bottom: none; padding-bottom: 0.7rem; margin-bottom: 1.5rem; display: flex; align-items: center; gap: 1.2rem; justify-content: center; text-align: center;">
                    <i class="fas fa-map-marked-alt" style="font-size: 2.1rem; color: #fff;"></i>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <span style="font-size: 1.45rem; font-weight: 800; color: #fff; letter-spacing: 1.1px; line-height: 1; text-align: center;">PROJECT TOMaS</span>
                        <div style="font-size: 0.98rem; color: #e6e6e6; margin-top: 0.18rem; font-weight: 400; letter-spacing: 0.2px; font-style: italic; opacity: 0.95; text-align: center;">
                            (Tactical Overlay for Mapping and Safety)
                        </div>
                    </div>
                </div>
                <div class="sidebar-header">
                    <span>Database</span>
                </div>
                <nav class="nav-bar">
                    <button class="nav-btn" id="household-btn" title="Household">
                        <i class="fas fa-home"></i>
                        <span>Household</span>
                    </button>
                    <button class="nav-btn" title="ACVs">
                        <i class="fas fa-industry"></i>
                        <span>ACVs</span>
                    </button>
                    <button class="nav-btn" title="Equipment">
                        <i class="fas fa-cogs"></i>
                        <span>Equipment</span>
                    </button>
                    <button class="nav-btn" id="roads-btn" title="Roads &amp; Bridges">
                        <i class="fas fa-road"></i>
                        <span>Roads &amp; Bridges</span>
                    </button>
                    <button class="nav-btn" title="Evac Center">
                        <i class="fas fa-hospital"></i>
                        <span>Evac Center</span>
                    </button>
                    <button class="nav-btn" title="Buildings">
                        <i class="fas fa-building"></i>
                        <span>Buildings</span>
                    </button>
                    <button class="nav-btn" title="Schools">
                        <i class="fas fa-school"></i>
                        <span>Schools</span>
                    </button>
                    <button class="nav-btn" id="documentation-btn" title="Documentation">
                        <i class="fas fa-book"></i>
                        <span>Documentation</span>
                    </button>
                </nav>
                <!-- Flood Extent Dropdown Section Styled like Database Header -->
                <div class="flood-section">
                    <div class="sidebar-header flood-header">
                        <span>Flood Extent</span>
                    </div>
                    <div class="flood-form-group">
                        <label class="flood-form-label" for="floodExtentDropdown">Flood Extent</label>
                        <!-- 
                        FLOOD EXTENT DROPDOWN - ENABLED
                        HOW IT WORKS:
                        - Allows users to select flood extent levels (24-30 meters)
                        - When selected, displays corresponding flood layer PNGs on the map
                        - Triggers chart panel to appear showing hazard distribution
                        - Filters population exposure table and charts based on selected extent
                        - Enabled when at least one barangay is selected
                        -->
                        <select id="floodExtentDropdown" class="flood-modern-select">
                            <option value="">Select Flood Extent</option>
                            <option value="24">24 meters</option>
                            <option value="25">25 meters</option>
                            <option value="26">26 meters</option>
                            <option value="27">27 meters</option>
                            <option value="28">28 meters</option>
                            <option value="29">29 meters</option>
                            <option value="30">30 meters</option>
                        </select>
                        <button id="toggleInfographicsBtn" style="margin-top: 12px; padding: 0.5rem 0.8rem; border-radius: 8px; border: 1px solid #3a3f4a; background:#2a2f39; color:#fff; cursor:pointer; font-weight:600; width: 100%;">Infographics</button>
                        <button id="impactReportBtn" style="margin-top: 8px; padding: 0.5rem 0.8rem; border-radius: 8px; border: 1px solid #3a3f4a; background:#2a2f39; color:#fff; cursor:pointer; font-weight:600; width: 100%;">Impact Report</button>
                    </div>
                            </div>
                            </div>
            <!-- Top Bar -->
            <div id="top-pane">
                <form class="search-form" autocomplete="off">
                    <div class="form-group">
                        <label class="form-label" for="region-multiselect-button">Region</label>
                        <div id="region-multiselect" class="modern-multiselect">
                            <button type="button" id="region-multiselect-button" class="modern-select multiselect-button">Select Region</button>
                            <div id="region-multiselect-dropdown" class="multiselect-dropdown">
                                <div class="multiselect-empty">Loading regions...</div>
                            </div>
                            </div>
                            </div>
                    <div class="form-group">
                        <label class="form-label" for="province-multiselect-button">Province</label>
                        <div id="province-multiselect" class="modern-multiselect">
                            <button type="button" id="province-multiselect-button" class="modern-select multiselect-button">Select Province</button>
                            <div id="province-multiselect-dropdown" class="multiselect-dropdown">
                                <div class="multiselect-empty">Select a region first</div>
                        </div>
                    </div>
                </div>
                    <div class="form-group">
                        <label class="form-label" for="municipality-multiselect-button">Municipality</label>
                        <div id="municipality-multiselect" class="modern-multiselect">
                            <button type="button" id="municipality-multiselect-button" class="modern-select multiselect-button">Select Municipality</button>
                            <div id="municipality-multiselect-dropdown" class="multiselect-dropdown">
                                <div class="multiselect-empty">Select a province first</div>
                    </div>
                    </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="barangay-multiselect-button">Barangay</label>
                        <div id="barangay-multiselect" class="modern-multiselect">
                            <button type="button" id="barangay-multiselect-button" class="modern-select multiselect-button">Select Barangay</button>
                            <div id="barangay-multiselect-dropdown" class="multiselect-dropdown">
                                <div class="multiselect-empty">Select a municipality first</div>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
            <!-- Map Container -->
            <div id="map-container">
                <!-- Charts Panel (Right Side) -->
                <!-- 
                CHARTS PANEL - Partially Disabled
                HOW IT WORKS:
                - Pie chart (Hazard Level Distribution) is ENABLED and visible
                - Bar chart (Exposed Population by Age) is DISABLED (hidden but code preserved)
                - Flood exposure legend is DISABLED (hidden but code preserved)
                - Panel width adjusted to 400px since bar chart and legend are disabled
                - Appears when flood extent is selected (if enabled)
                
                DISABLED COMPONENTS:
                - Demographics bar chart: display: none applied
                - Flood exposure legend: display: none applied
                
                TO RE-ENABLE DISABLED COMPONENTS: Remove display: none from their style attributes
                -->
                <div id="charts-panel" style="display: none; position: fixed; right: 0; top: 80px; bottom: 0; height: auto; width: 400px; background: linear-gradient(135deg, rgba(35, 39, 47, 0.98) 0%, rgba(42, 47, 57, 0.98) 100%); border-left: 2px solid rgba(243, 156, 18, 0.3); z-index: 999; overflow-y: hidden; overflow-x: hidden; padding: 1.5rem; box-shadow: -4px 0 20px rgba(0, 0, 0, 0.4); box-sizing: border-box;">
                    <!-- Pie Chart Section - ENABLED -->
                    <div style="flex: 1; max-width: 100%; box-sizing: border-box; overflow: hidden; display: flex; flex-direction: column; min-height: 0; margin-bottom: 0.75rem;">
                        <h4>Hazard Level Distribution</h4>
                        <div style="position: relative; flex: 1; max-width: 100%; background: rgba(42, 47, 57, 0.4); border-radius: 8px; padding: 1rem; box-sizing: border-box; overflow: hidden; min-height: 0;">
                            <canvas id="hazardPieChart" style="max-width: 100%; max-height: 100%; box-sizing: border-box;"></canvas>
                        </div>
                    </div>
                        <!-- Flood Exposure Legend - DISABLED: Hidden but kept in code for future use -->
                        <!-- 
                        HOW IT WORKS (currently disabled):
                        - Displays flood exposure hazard levels (High, Moderate, Low, Very Low) with corresponding legend icons
                        - Shows beside the pie chart to help users interpret the hazard level distribution
                        - Uses flexbox layout to position legend to the right of the pie chart
                        - Styled to match the charts panel theme with dark background and accent colors
                        - Currently hidden via display: none to disable functionality without removing code
                        
                        TO RE-ENABLE: Remove display: none from the style attribute below
                        -->
                        <div style="flex: 0 0 auto; min-width: 140px; display: none; flex-direction: column;">
                            <h4 style="margin-bottom: 0.5rem; font-size: 0.9rem; color: #f39c12; font-weight: 600;">Flood Exposure</h4>
                            <div style="background: rgba(42, 47, 57, 0.4); border-radius: 8px; padding: 0.75rem; display: flex; flex-direction: column; gap: 6px;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <img src="styles/legend/Numberofpeopleat24meters_12_0.png" alt="High" style="width: 18px; height: 18px; flex-shrink: 0;" />
                                    <span style="color: #cccccc; font-size: 0.8em; line-height: 1.2;">High (> 1.5 m)</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <img src="styles/legend/Numberofpeopleat24meters_12_1.png" alt="Moderate" style="width: 18px; height: 18px; flex-shrink: 0;" />
                                    <span style="color: #cccccc; font-size: 0.8em; line-height: 1.2;">Moderate (> 0.7 - 1.5 m)</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <img src="styles/legend/Numberofpeopleat24meters_12_2.png" alt="Low" style="width: 18px; height: 18px; flex-shrink: 0;" />
                                    <span style="color: #cccccc; font-size: 0.8em; line-height: 1.2;">Low (> 0.1 - 0.7 m)</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <img src="styles/legend/Numberofpeopleat24meters_12_3.png" alt="Very Low" style="width: 18px; height: 18px; flex-shrink: 0;" />
                                    <span style="color: #cccccc; font-size: 0.8em; line-height: 1.2;">Very Low (<= 0.1 m)</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- Demographics Bar Chart - DISABLED: Hidden but kept in code for future use -->
                    <!-- 
                    HOW IT WORKS (currently disabled):
                    - Displays exposed population by age groups (Infant, Child, Youth, Adult, Elderly, Disabled)
                    - Shows as an interactive bar chart using Chart.js library
                    - Updates automatically when barangay or exposure level selections change
                    - Clicking bars filters the population exposure table to show matching demographics
                    - Currently hidden via display: none to disable functionality without removing code
                    
                    TO RE-ENABLE: Remove display: none from the style attribute below and ensure 
                    updateCharts() function includes bar chart creation logic
                    -->
                    <div style="flex: 1; max-width: 100%; box-sizing: border-box; overflow: hidden; display: none; flex-direction: column; min-height: 0;">
                        <h4>Exposed Population by Age</h4>
                        <div style="position: relative; flex: 1; max-width: 100%; background: rgba(42, 47, 57, 0.4); border-radius: 8px; padding: 1rem; box-sizing: border-box; overflow: hidden; min-height: 0;">
                            <canvas id="demographicsBarChart" style="max-width: 100%; max-height: 100%; box-sizing: border-box;"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Top Navigation Bar - Contains all population exposure table elements -->
            <div id="top-navigation-bar" style="display: none;">
                <div class="nav-content">
                    <div class="nav-header">
                        <h3 id="people-table-title">
                            <span id="people-table-title-text">Population Exposure</span>
                            <span id="people-table-count">0 of 0 rows</span>
                        </h3>
                        <button id="people-24-close" class="close-table-btn" title="Close">&times;</button>
                    </div>
                    <!-- Filters -->
                    <div id="people-filters"></div>
                    
                    <!-- Table Wrapper -->
                    <div id="people-table-wrapper">
                        <table class="flood-table" id="people-24-table-inner" style="margin:0;">
                            <thead style="position: sticky; top: 0; z-index: 2;">
                                <tr>
                                    <th>No.</th>
                                    <th>Barangay</th>
                                    <th>Infant</th>
                                    <th>Child</th>
                                    <th>Youth</th>
                                    <th>Adult</th>
                                    <th>Elderly</th>
                                    <th>Male</th>
                                    <th>Female</th>
                                    <th>Disabled</th>
                                    <th>Flood Exposure</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <div id="map-container">
                <!-- Household Details Modal -->
                    <div id="household-modal" class="modal" style="display: none;">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3 id="household-modal-title">Household Details</h3>
                                <button id="household-modal-close" class="close-btn">&times;</button>
                            </div>
                            <div class="modal-body">
                                <div id="household-size-display" style="margin-bottom: 1rem; padding: 0.75rem; background: #1e2329; border-radius: 6px; border-left: 4px solid #f39c12;">
                                    <strong style="color: #f39c12;">Household Size: </strong>
                                    <span id="household-size-value" style="color: #e0e0e0;">-</span>
                                </div>
                                <div id="household-table-container">
                                    <table id="household-details-table" class="household-table">
                                        <thead>
                                            <tr>
                                                <th>Relation</th>
                                                <th>Given Name</th>
                                                <th>Last Name</th>
                                                <th>Age</th>
                                                <th>Sex</th>
                                                <th>Occupation</th>
                                                <th>Religion</th>
                                            </tr>
                                        </thead>
                                        <tbody id="household-details-tbody">
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Infographics Modal -->
                    <div id="infographics-modal" class="modal" style="display: none;">
                        <div class="modal-content" style="width: 95%; max-width: 1000px; height: 85vh; display: flex; flex-direction: column;">
                            <div class="modal-header">
                                <h3 id="infographics-modal-title">Infographics</h3>
                                <div style="display:flex; gap:8px; align-items:center;">
                                    <button id="infographics-modal-maximize" class="close-btn" title="Maximize" style="line-height:1;"></button>
                                    <button id="infographics-modal-close" class="close-btn">&times;</button>
                                </div>
                            </div>
                            <div class="modal-body" style="flex: 1 1 auto; padding: 0;">
                                <div id="infographics-container" style="width:100%; height:100%; background:#1e2329; display:flex; align-items:center; justify-content:center;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Impact Report Modal -->
                    <div id="impact-report-modal" class="modal" style="display: none;">
                        <div class="modal-content" style="width: 95%; max-width: 1000px; height: 85vh; display: flex; flex-direction: column;">
                            <div class="modal-header">
                                <h3 id="impact-report-modal-title">Impact Report</h3>
                                <div style="display:flex; gap:8px; align-items:center;">
                                    <button id="impact-report-modal-maximize" class="close-btn" title="Maximize" style="line-height:1;"></button>
                                    <button id="impact-report-modal-close" class="close-btn">&times;</button>
                                </div>
                            </div>
                            <div class="modal-body" style="flex: 1 1 auto; padding: 0;">
                                <div id="impact-report-container" style="width:100%; height:100%; background:#1e2329; display:flex; align-items:center; justify-content:center;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Barangay Population Modal -->
                    <div id="barangay-population-modal" class="modal" style="display: none;">
                        <div class="modal-content" style="width: 90%; max-width: 700px; max-height: 85vh; display: flex; flex-direction: column;">
                            <div class="modal-header">
                                <h3 id="barangay-population-title">Population by Barangay</h3>
                                <button id="barangay-population-close" class="close-btn">&times;</button>
                            </div>
                            <div class="modal-body" style="flex: 1 1 auto; overflow: hidden;">
                                <div id="barangay-population-content" style="height: 100%; overflow-y: auto;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Family Members Modal -->
                    <div id="family-table-modal" class="modal" style="display: none;">
                        <div class="modal-content" id="family-table-modal-content" style="width: 90%; max-width: 900px; max-height: 85vh; display: flex; flex-direction: column;">
                            <div class="modal-header" id="family-table-modal-header">
                                <h3 id="family-table-modal-title">Household Members</h3>
                                <button id="family-table-modal-close" class="close-btn">&times;</button>
                            </div>
                            <div class="modal-body" style="overflow-y: auto; padding: 1.5rem;">
                                <div id="family-table"></div>
                            </div>
                        </div>
                    </div>
                    <div id="map">
                            <div>
                                <a href="#" id="popup-closer" class="ol-popup-closer"></a>
                                <div id="popup-content"></div>
                            </div>
                            <!-- Barangay Tooltip -->
                        </div>
                        <!-- Map Legend - DISABLED: Hidden but kept in code for future use -->
                        <!-- 
                        HOW IT WORKS (currently disabled):
                        - Displays map legends showing water depth levels and their corresponding colors/icons
                        - Appears on the map when flood extent is selected
                        - Shows legend icons with depth values (0.0010m, 2.3258m, 4.6505m, 6.9753m, 9.3000m)
                        - Positioned at bottom-left of the map overlay
                        - Currently hidden via display: none to disable functionality without removing code
                        
                        TO RE-ENABLE: Change display: none to display: block in the style attribute below
                        and ensure setupFloodExtentListeners() function shows the legend when flood extent is selected
                        -->
                        <div id="map-legend" style="display: none; position: absolute; bottom: 20px; left: 20px; background: rgba(38, 42, 51, 0.2); border: 1px solid #666; border-radius: 8px; padding: 12px; width: auto; height: auto; min-width: fit-content; z-index: 1000;">
                            <div style="color: #1a1a1a; font-size: 0.9rem; font-weight: 600; margin-bottom: 8px; text-align: center;">Legends</div>
                            <!-- Water Depth Legend - DISABLED: Hidden but kept in code for future use -->
                            <div style="margin-bottom: 8px; display: none;">
                                <div style="color: #1a1a1a; font-size: 0.85rem; font-weight: 500; margin-bottom: 4px; padding-bottom: 4px; border-bottom: 1px solid #999;">Water Depth</div>
                                <div style="display: flex; flex-direction: column; gap: 3px;">
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <img src="styles/legend/24_10_0.png" alt="0.0010" style="width: 18px; height: 18px; padding: 4px;" />
                                        <span style="color: #1a1a1a; font-size: 0.85em;">0.0010m</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <img src="styles/legend/24_10_1.png" alt="2.3258" style="width: 18px; height: 18px; padding: 4px;" />
                                        <span style="color: #1a1a1a; font-size: 0.85em;">2.3258m</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <img src="styles/legend/24_10_2.png" alt="4.6505" style="width: 18px; height: 18px; padding: 4px;" />
                                        <span style="color: #1a1a1a; font-size: 0.85em;">4.6505m</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <img src="styles/legend/24_10_3.png" alt="6.9753" style="width: 18px; height: 18px; padding: 4px;" />
                                        <span style="color: #1a1a1a; font-size: 0.85em;">6.9753m</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <img src="styles/legend/24_10_4.png" alt="9.3000" style="width: 18px; height: 18px; padding: 4px;" />
                                        <span style="color: #1a1a1a; font-size: 0.85em;">9.3000m</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- AI Chat Widget - Removed -->
                    <div id="ai-chat-panel" class="ai-chat-panel">
                        <div class="ai-chat-header">
                            <div class="ai-chat-title">Chat with TOMAS</div>
                            <div class="ai-chat-actions">
                                <button id="ai-chat-docs" class="close-btn" title="Proxy setup (docs)">?</button>
                                <button id="ai-chat-settings" class="close-btn" title="Settings"></button>
                                <button id="ai-chat-close" class="close-btn" title="Close"></button>
                            </div>
                        </div>
                        <div id="ai-chat-body" class="ai-chat-body"></div>
                        <div class="ai-key-hint" id="ai-key-hint" style="display:none;">No API key set. Click  to add your OpenAI API key locally.</div>
                        <div class="ai-chat-input">
                            <input id="ai-chat-input" type="text" placeholder="Ask about the data..." />
                            <button id="ai-chat-send">Send</button>
                        </div>
                    </div>
                </div>
            
        </div>
        <script src="resources/qgis2web_expressions.js"></script>
        <script src="./resources/functions.js"></script>
        <script src="./resources/ol.js"></script>
        <script src="./resources/ol-layerswitcher.js"></script>
        <script src="resources/photon-geocoder-autocomplete.min.js"></script>
        <!-- Households_1.js - Required for layers.js -->
        <script src="layers/Households_1.js"></script>
        <!-- People_0.js - DISABLED: Hidden but kept in code for future use -->
        <!-- <script src="layers/People_0.js"></script> -->
        <script src="layers/AnalysisSummaryat24meters_9.js"></script><script src="layers/AggregationSummaryat24meters_10.js"></script><script src="layers/HazardAggregationSummaryat24meters_11.js"></script><script src="layers/Numberofpeopleat24meters_12.js"></script><script src="layers/AnalysisSummaryat25meters_13.js"></script><script src="layers/AggregationSummaryat25meters_14.js"></script><script src="layers/HazardAggregationSummaryat25meters_15.js"></script><script src="layers/Numberofpeopleat25meters_16.js"></script><script src="layers/AnalysisSummaryat27meters_17.js"></script><script src="layers/AggregationSummaryat27meters_18.js"></script><script src="layers/HazardAggregationSummaryat27meters_19.js"></script><script src="layers/Numberofpeopleat26meters_20.js"></script><script src="layers/AnalysisSummaryat27meters_21.js"></script><script src="layers/AggregationSummaryatat27meters_22.js"></script><script src="layers/HazardAggregationSummaryat27meters_23.js"></script><script src="layers/Numberofpeopleat27meters_24.js"></script><script src="layers/AnalysisSummaryat28meters_25.js"></script><script src="layers/AggregationSummaryat28meters_26.js"></script><script src="layers/HazardAggregationSummaryat28meters_27.js"></script><script src="layers/Numberofpeopleat28meters_28.js"></script><script src="layers/AnalysisSummaryat29meters_29.js"></script><script src="layers/AggregationSummaryat29meters_30.js"></script><script src="layers/HazardAggregationSummaryat29meters_31.js"></script><script src="layers/Numberofpeopleat29meters_32.js"></script><script src="layers/AnalysisSummaryat30meters_33.js"></script><script src="layers/AggregationSummaryfor30meters_34.js"></script><script src="layers/HazardAggregationSummaryat30meters_35.js"></script><script src="layers/Numberofpeopleaffectedat30meters_36.js"></script><script src="layers/Schools_37.js"></script><script src="layers/Roads_38.js"></script><script src="layers/Region2_39.js"></script><script src="layers/DB_0.js"></script><script src="layers/StoTomasHouseholdsjoined_layer_1.js"></script>
        <!-- Households_1_style.js - Required for layers.js -->
        <script src="styles/Households_1_style.js"></script>
        <!-- People_0_style.js - DISABLED: Hidden but kept in code for future use -->
        <!-- <script src="styles/People_0_style.js"></script> -->
        <script src="styles/AnalysisSummaryat24meters_9_style.js"></script><script src="styles/AggregationSummaryat24meters_10_style.js"></script><script src="styles/HazardAggregationSummaryat24meters_11_style.js"></script><script src="styles/Numberofpeopleat24meters_12_style.js"></script><script src="styles/AnalysisSummaryat25meters_13_style.js"></script><script src="styles/AggregationSummaryat25meters_14_style.js"></script><script src="styles/HazardAggregationSummaryat25meters_15_style.js"></script><script src="styles/Numberofpeopleat25meters_16_style.js"></script><script src="styles/AnalysisSummaryat27meters_17_style.js"></script><script src="styles/AggregationSummaryat27meters_18_style.js"></script><script src="styles/HazardAggregationSummaryat27meters_19_style.js"></script><script src="styles/Numberofpeopleat26meters_20_style.js"></script><script src="styles/AnalysisSummaryat27meters_21_style.js"></script><script src="styles/AggregationSummaryatat27meters_22_style.js"></script><script src="styles/HazardAggregationSummaryat27meters_23_style.js"></script><script src="styles/Numberofpeopleat27meters_24_style.js"></script><script src="styles/AnalysisSummaryat28meters_25_style.js"></script><script src="styles/AggregationSummaryat28meters_26_style.js"></script><script src="styles/HazardAggregationSummaryat28meters_27_style.js"></script><script src="styles/Numberofpeopleat28meters_28_style.js"></script><script src="styles/AnalysisSummaryat29meters_29_style.js"></script><script src="styles/AggregationSummaryat29meters_30_style.js"></script><script src="styles/HazardAggregationSummaryat29meters_31_style.js"></script><script src="styles/Numberofpeopleat29meters_32_style.js"></script><script src="styles/AnalysisSummaryat30meters_33_style.js"></script><script src="styles/AggregationSummaryfor30meters_34_style.js"></script><script src="styles/HazardAggregationSummaryat30meters_35_style.js"></script><script src="styles/Numberofpeopleaffectedat30meters_36_style.js"></script><script src="styles/Schools_37_style.js"></script><script src="styles/Roads_38_style.js"></script><script src="styles/Region2_39_style.js"></script><script src="styles/DB_0_style.js"></script><script src="styles/StoTomasHouseholdsjoined_layer_1_style.js"></script>
        
        <!-- Place a small safe-guard before layers/layers.js runs to avoid undefined style references -->
        <script>
        // Ensure any missing style helper used by layers.js won't throw at parse time.
        // Add placeholders only if they don't already exist.
        window.style_Numberofpeopleat24meters_12 = window.style_Numberofpeopleat24meters_12 || function(feature, resolution){
            // return null or a very simple style if OL expects a style object
            try {
                if (typeof ol !== 'undefined' && ol.style && ol.style.Style) {
                    return new ol.style.Style({
                        stroke: new ol.style.Stroke({ color: 'rgba(0,0,0,0.6)', width: 1 }),
                        fill: new ol.style.Fill({ color: 'rgba(255,255,255,0.01)' })
                    });
                }
            } catch (e) {}
            return null;
        };
        </script>

        <!-- existing layer/style/layers.js includes follow here (no change) -->
        <script src="./layers/layers.js" type="text/javascript"></script> 
        <script src="./resources/Autolinker.min.js"></script>
        <script src="./resources/qgis2web.js"></script>
        
        
        
        <script>
        // Global variables
        var regionLayer = null;
        var highlightLayer = null;
        var popupOverlay = null;
        var selectedFeatures = [];
        var peopleLayer = null;
        var householdLayers = [];
        var householdLayersVisible = false;
        // Global variable to store selected barangays for StoTomasHouseholdsjoined_layer_1 filtering
        var stoTomasFilteredBarangays = new Set();
        var barangaySelectionState = {
            options: [],
            selected: new Set()
        };
        var barangayDropdownInitialized = false;
        
        // Multiselect state for Region, Province, and Municipality
        var regionSelectionState = {
            options: [],
            selected: new Set()
        };
        var regionDropdownInitialized = false;
        
        var provinceSelectionState = {
            options: [],
            selected: new Set()
        };
        var provinceDropdownInitialized = false;
        
        var municipalitySelectionState = {
            options: [],
            selected: new Set()
        };
        var municipalityDropdownInitialized = false;
        
        /**
         * Updates the top pane position based on right pane and charts panel state.
         * Called when right pane is toggled or when top pane is shown.
         * Connected to: setupRightPaneToggle(), showPeopleTableFor()
         */
        /**
         * Updates the top pane position and width based on right pane and charts panel state.
         * Ensures smooth responsive behavior when right pane is toggled.
         * Called when right pane is toggled or when top pane is shown.
         * Connected to: setupRightPaneToggle(), showPeopleTableFor(), showChartsPanel(), hideChartsPanel()
         */
        function updateTopPanePosition() {
            var topNavBar = document.getElementById('top-navigation-bar');
            var mapContainer = document.getElementById('map-container');
            
            if (!topNavBar || !mapContainer) return;
            
            // Only update if navigation bar is visible
            if (topNavBar.style.display === 'none') return;
            
            var isChartsOpen = mapContainer.classList.contains('charts-open');
            
            // Calculate right position based on state (no right pane anymore)
            var rightValue;
            if (isChartsOpen) {
                rightValue = '400px'; // 400px charts panel only
            } else {
                rightValue = '0'; // No right pane
            }
            
            // Set the position with smooth transition
            topNavBar.style.right = rightValue;
            topNavBar.style.width = ''; // Clear any fixed width to allow auto calculation
            topNavBar.style.maxWidth = ''; // Clear any max-width restrictions
            topNavBar.style.transition = 'right 0.3s ease, left 0.3s ease, width 0.3s ease'; // Ensure smooth transition
            
            // Force all child elements to be responsive and fill available width
            var navContent = topNavBar.querySelector('.nav-content');
            var tableWrapper = topNavBar.querySelector('#people-table-wrapper');
            var table = topNavBar.querySelector('#people-24-table-inner');
            
            if (navContent) {
                navContent.style.width = '100%';
                navContent.style.maxWidth = '100%';
                navContent.style.minWidth = '0';
            }
            if (tableWrapper) {
                tableWrapper.style.width = '100%';
                tableWrapper.style.maxWidth = '100%';
                tableWrapper.style.minWidth = '0';
            }
            if (table) {
                table.style.width = '100%';
                table.style.maxWidth = '100%';
                table.style.minWidth = '0';
            }
            
            // Force a reflow to ensure changes take effect immediately
            void topNavBar.offsetHeight;
        }
        
        // Right pane toggle functionality removed - right pane has been deleted
        
        // Initialize map with base map and Region_2 layer visible
        // Setup offcanvas event listeners for map container adjustment
        function setupOffcanvasListeners() {
            var offcanvasElement = document.getElementById('offcanvasRight');
            var mapContainer = document.getElementById('map-container');
            
            if (!offcanvasElement || !mapContainer) {
                console.warn('Offcanvas or map container not found');
                return;
            }
            
            // Adjust map when offcanvas is shown
            offcanvasElement.addEventListener('show.bs.offcanvas', function() {
                mapContainer.classList.add('offcanvas-open');
                // Update map size after transition
                setTimeout(function() {
                    if (typeof map !== 'undefined' && map.updateSize) {
                        map.updateSize();
                    }
                }, 300);
            });
            
            // Adjust map when offcanvas is hidden
            offcanvasElement.addEventListener('hide.bs.offcanvas', function() {
                mapContainer.classList.remove('offcanvas-open');
                // Update map size after transition
                setTimeout(function() {
                    if (typeof map !== 'undefined' && map.updateSize) {
                        map.updateSize();
                    }
                }, 300);
            });
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            // Setup offcanvas listeners
            setupOffcanvasListeners();
            
            // Wait for the map to be fully loaded
            setTimeout(function() {
                console.log('Checking map layers...');
                if (typeof map !== 'undefined' && map.getLayers) {
                    var layers = map.getLayers().getArray();
                    console.log('Total layers found:', layers.length);
                    
                    // Layer visibility is now controlled by layers.js - only Region2 and Positron are visible by default
                    layers.forEach(function(layer, index) {
                        var layerTitle = layer.get('title') || layer.get('name') || 'Unknown';
                        var layerType = layer.getType ? layer.getType() : 'unknown';
                        console.log('Layer ' + index + ':', layerTitle, 'Type:', layerType, 'Visible:', layer.getVisible());
                        
                        // Store region layer reference for other functionality
                        var layerTitleLower = layerTitle.toLowerCase();
                        var isRegionLayer = layerTitle === 'Region2' || 
                            layerTitle === 'Region_2' || 
                            layerTitle === 'Region2_39' ||
                            layerTitleLower.includes('region2') ||
                            layerTitleLower.includes('region_2');
                        
                        if (isRegionLayer) {
                            regionLayer = layer;
                            console.log('Region layer reference stored:', layerTitle);
                        }
                    });
                    
                    // Debug: List all layer names for troubleshooting
                    console.log('=== ALL LAYER NAMES ===');
                    layers.forEach(function(layer, index) {
                        var layerTitle = layer.get('title') || layer.get('name') || 'Unknown';
                        console.log('Layer ' + index + ' name:', layerTitle, 'Visible:', layer.getVisible());
                    });
                    console.log('=== END LAYER NAMES ===');
                    
                    // Create highlight layer
                    createHighlightLayer();
                    
                    // Create popup overlay
                    createPopupOverlay();
                    
                    // Add map click listener to clear highlights
                    setupMapClickHandler();
                    
                    // Add layer switcher control
                    setupLayerSwitcher();

                    // Ensure basemap and region layers are visible and ordered correctly now that layers exist
                    ensureBasemapVisible();

                    // People layer initialization - DISABLED
                    // ensurePeopleLayer(); // People_0.js is disabled, so this function is not called
                    ensureHouseholdLayers();
                    
                    // Ensure StoTomasHouseholdsjoined_layer_1 layer is hidden by default
                    var stoTomasLayer = findStoTomasHouseholdsLayer();
                    if (stoTomasLayer) {
                        stoTomasLayer.setVisible(false);
                        console.log('StoTomasHouseholdsjoined_layer_1 layer hidden on initialization');
                    }
                    
                    // Setup household polygon click handler
                    setupHouseholdPolygonClickHandler();
                    
                    // Setup cursor change on hover for household polygons
                    setupHouseholdPolygonHoverCursor();
                    
                    // Setup family table modal
                    setupFamilyTableModal();
                } else {
                    console.log('Map not found or not ready');
                }
                
                // Initialize custom barangay multiselect before populating options
                // Initialize all multiselect dropdowns
                initializeRegionMultiselect();
                initializeProvinceMultiselect();
                initializeMunicipalityMultiselect();
                initializeBarangayMultiselect();
                
                // Populate dropdowns from Region2_39 data
                populateDropdowns();
                
                // Add event listeners for dropdowns
                setupDropdownEventListeners();

                // Initialize barangay display value
                updatePeopleBarangayDisplay();
                updateFloodExtentAvailability();
                filterHouseholdsBySelectedBarangay();
                
                // Add event listeners for navigation buttons
                setupNavigationButtons();
                
                // Add event listeners for flood extent functionality
                setupFloodExtentListeners();
                
                // Initialize right pane charts - wait for canvas elements to be ready
                function initializeRightPaneCharts() {
                    if (areChartCanvasesReady()) {
                        updateRightPaneCharts();
                    } else {
                        console.log('Waiting for chart canvases...');
                        setTimeout(initializeRightPaneCharts, 500);
                    }
                }
                initializeRightPaneCharts();
                
            }, 2000); // Increased wait time to 2 seconds
        });
        
        /**
         * Creates a highlight layer for selected polygons on the map.
         * This layer is used to visually highlight selected features with a red dashed border.
         * Called during map initialization. Uses global variable 'highlightLayer'.
         * Connected to: clearHighlight(), highlightSelectedPolygon(), highlightTableFeatures()
         */
        function createHighlightLayer() {
            highlightLayer = new ol.layer.Vector({
                source: new ol.source.Vector(),
                style: new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#ff0000',
                        width: 4,
                        lineDash: [5, 5]
                    }),
                    fill: new ol.style.Fill({
                        color: 'rgba(255, 0, 0, 0.1)'
                    })
                }),
                zIndex: 1000
            });
            map.addLayer(highlightLayer);
        }
        
        /**
         * Creates a popup overlay for displaying feature information on the map.
         * The popup appears when hovering over or clicking features.
         * Called during map initialization. Uses global variable 'popupOverlay'.
         * Connected to: handlePointerMove(), setupMapClickHandler()
         */
        function createPopupOverlay() {
            var popupElement = document.getElementById('popup');
            popupOverlay = new ol.Overlay({
                element: popupElement,
                positioning: 'bottom-center',
                stopEvent: false,
                offset: [0, -50]
            });
            map.addOverlay(popupOverlay);
            
            // Close popup when clicking the closer
            document.getElementById('popup-closer').onclick = function() {
                popupOverlay.setPosition(undefined);
                return false;
            };
        }
        
        /**
         * Populates the Region multiselect dropdown from Region2_39 GeoJSON data.
         * Extracts unique region names and renders them as checkboxes in the region multiselect.
         * Called during page initialization. Clears province, municipality, and barangay dropdowns.
         * Connected to: updateProvinceDropdown(), updateMunicipalityDropdown(), updateBarangayDropdown(),
         *              renderRegionOptions()
         */
        function populateDropdowns() {
            if (typeof json_Region2_39 !== 'undefined' && json_Region2_39.features) {
                console.log('Populating dropdowns from Region2_39 data...');
                
                // Get unique values for Region multiselect
                var regions = new Set();
                
                json_Region2_39.features.forEach(function(feature) {
                    if (feature.properties && feature.properties.Reg_Name) {
                        regions.add(feature.properties.Reg_Name);
                    }
                });
                
                // Populate Region multiselect with sorted regions
                var sortedRegions = Array.from(regions).sort();
                renderRegionOptions(sortedRegions);
                
                // Clear other dropdowns - they will be populated based on selections
                renderProvinceOptions([]);
                renderMunicipalityOptions([]);
                renderBarangayOptions([]);
                
                console.log('Region multiselect populated successfully with', sortedRegions.length, 'regions. Other dropdowns will populate based on selections.');
            } else {
                console.log('Region2_39 data not found');
                renderRegionOptions([]);
            }
        }
        
        /**
         * Sets up event listeners for Region, Province, and Municipality multiselect dropdowns.
         * Multiselect functionality is handled by their respective initialization and handler functions.
         * This function now serves as a placeholder for any additional setup needed.
         * The multiselect dropdowns handle their own events via:
         * - initializeRegionMultiselect(), initializeProvinceMultiselect(), initializeMunicipalityMultiselect()
         * - handleRegionSelectionChange(), handleProvinceSelectionChange(), handleMunicipalitySelectionChange()
         * Called during page initialization.
         * Connected to: All multiselect initialization and handler functions
         */
        function setupDropdownEventListeners() {
            // Event listeners are now handled by the multiselect initialization functions
            // (initializeRegionMultiselect, initializeProvinceMultiselect, initializeMunicipalityMultiselect)
            // and their respective handler functions (handleRegionSelectionChange, etc.)
            console.log('Dropdown event listeners setup complete. Multiselect dropdowns handle their own events.');
        }

        /**
         * Initializes the barangay multiselect dropdown component.
         * Sets up click handlers for opening/closing the dropdown and prevents event bubbling.
         * Called once during page initialization. Uses global variable 'barangayDropdownInitialized'.
         * Connected to: toggleBarangayDropdown(), closeBarangayDropdown(), renderBarangayOptions()
         */
        function initializeBarangayMultiselect() {
            if (barangayDropdownInitialized) return;
            var button = document.getElementById('barangay-multiselect-button');
            var dropdown = document.getElementById('barangay-multiselect-dropdown');
            if (!button || !dropdown) return;

            button.addEventListener('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                var willOpen = !dropdown.classList.contains('is-open');
                toggleBarangayDropdown(willOpen);
            });

            dropdown.addEventListener('click', function(event) {
                event.stopPropagation();
            });

            document.addEventListener('click', function() {
                closeBarangayDropdown();
            });

            barangayDropdownInitialized = true;
        }

        /**
         * Toggles the barangay multiselect dropdown open/closed state.
         * Adds or removes 'is-open' class from button and dropdown elements.
         * Called by: initializeBarangayMultiselect(), closeBarangayDropdown()
         * Connected to: closeBarangayDropdown()
         */
        function toggleBarangayDropdown(shouldOpen) {
            var button = document.getElementById('barangay-multiselect-button');
            var dropdown = document.getElementById('barangay-multiselect-dropdown');
            if (!button || !dropdown) return;
            if (shouldOpen) {
                dropdown.classList.add('is-open');
                button.classList.add('is-open');
            } else {
                dropdown.classList.remove('is-open');
                button.classList.remove('is-open');
            }
        }

        /**
         * Closes the barangay multiselect dropdown.
         * Wrapper function that calls toggleBarangayDropdown(false).
         * Called when clicking outside the dropdown or when closing programmatically.
         * Connected to: toggleBarangayDropdown()
         */
        function closeBarangayDropdown() {
            toggleBarangayDropdown(false);
        }

        /**
         * Returns an array of currently selected barangay names.
         * Converts the Set stored in barangaySelectionState.selected to an array.
         * Used throughout the application to check which barangays are selected.
         * Connected to: filterHouseholdsBySelectedBarangay(), handleBarangaySelectionChange(),
         *              updateFloodExtentAvailability(), applyPeopleFiltersAndRender()
         */
        function getSelectedBarangays() {
            return Array.from(barangaySelectionState.selected);
        }

        /**
         * Normalizes a barangay name for comparison by converting to lowercase and trimming whitespace.
         * Used to ensure consistent matching when comparing barangay names from different sources.
         * Called by: filterHouseholdsBySelectedBarangay(), getSelectedBarangayFeatures(),
         *           applyPeopleFiltersAndRender(), updateCharts()
         */
        function normalizeBarangayName(value) {
            return (value || '').toString().trim().toLowerCase();
        }

        /**
         * Updates the display text on the barangay multiselect button.
         * Shows "Select Barangay", single barangay name, or count of selected barangays.
         * Called whenever barangay selection changes.
         * Connected to: handleBarangayOptionToggle(), renderBarangayOptions(), clearBarangaySelections()
         */
        function updateBarangaySelectionDisplay() {
            var button = document.getElementById('barangay-multiselect-button');
            if (!button) return;
            var selections = getSelectedBarangays();
            if (barangaySelectionState.options.length === 0) {
                button.textContent = 'Select Barangay';
                return;
            }
            if (selections.length === 0) {
                button.textContent = 'Select Barangay';
            } else if (selections.length === 1) {
                button.textContent = selections[0];
            } else {
                button.textContent = selections.length + ' barangays selected';
            }
        }

        /**
         * Renders the barangay multiselect dropdown options as checkboxes.
         * Creates checkbox elements for each barangay and maintains selection state.
         * Prunes selections that are no longer available in the current options.
         * Called by: updateBarangayDropdown(), clearLowerDropdowns()
         * Connected to: handleBarangayOptionToggle(), updateBarangaySelectionDisplay(),
         *              handleBarangaySelectionChange(), barangaySelectionState
         */
        function renderBarangayOptions(barangays) {
            var dropdown = document.getElementById('barangay-multiselect-dropdown');
            if (!dropdown) return;

            dropdown.innerHTML = '';
            barangaySelectionState.options = Array.isArray(barangays) ? barangays.slice() : [];

            if (!barangaySelectionState.options.length) {
                barangaySelectionState.selected.clear();
                dropdown.innerHTML = '<div class="multiselect-empty">Select a municipality first</div>';
                updateBarangaySelectionDisplay();
                handleBarangaySelectionChange({ skipZoom: true, reason: 'options-cleared' });
                return;
            }

            var previousSelection = new Set(barangaySelectionState.selected);
            barangaySelectionState.selected.clear();
            var availableSet = new Set(barangaySelectionState.options);
            var selectionChanged = false;

            previousSelection.forEach(function(name) {
                if (availableSet.has(name)) {
                    barangaySelectionState.selected.add(name);
                } else {
                    selectionChanged = true;
                }
            });

            var fragment = document.createDocumentFragment();
            barangaySelectionState.options.forEach(function(name, index) {
                var option = document.createElement('div');
                option.className = 'multiselect-option';

                var checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = 'barangay-checkbox-' + index;
                checkbox.value = name;
                checkbox.checked = barangaySelectionState.selected.has(name);
                checkbox.addEventListener('change', function(event) {
                    handleBarangayOptionToggle(name, event.target.checked);
                });

                var label = document.createElement('label');
                label.setAttribute('for', checkbox.id);
                label.textContent = name;

                option.appendChild(checkbox);
                option.appendChild(label);
                fragment.appendChild(option);
            });

            dropdown.appendChild(fragment);
            updateBarangaySelectionDisplay();

            if (selectionChanged) {
                console.log('Pruned barangay selections that are no longer available.');
                handleBarangaySelectionChange({ skipZoom: true, reason: 'pruned-selection' });
            }
        }

        /**
         * Handles checkbox toggle for a barangay option in the multiselect dropdown.
         * Adds or removes the barangay from the selection state and triggers updates.
         * Called when a checkbox is clicked in the barangay dropdown.
         * Connected to: updateBarangaySelectionDisplay(), handleBarangaySelectionChange(),
         *              barangaySelectionState.selected
         */
        function handleBarangayOptionToggle(name, isChecked) {
            if (!name) return;
            if (isChecked) {
                barangaySelectionState.selected.add(name);
            } else {
                barangaySelectionState.selected.delete(name);
            }
            updateBarangaySelectionDisplay();
            console.log('Barangay selection updated:', getSelectedBarangays());
            handleBarangaySelectionChange({ reason: 'checkbox' });
            // Auto-collapse dropdown after selection
            closeBarangayDropdown();
        }

        /**
         * Clears all barangay selections from the multiselect dropdown.
         * Unchecks all checkboxes and clears the selection state.
         * Can be forced to clear even if already empty.
         * Called by: setupMapClickHandler(), clearLowerDropdowns()
         * Connected to: updateBarangaySelectionDisplay(), handleBarangaySelectionChange(),
         *              barangaySelectionState.selected
         */
        function clearBarangaySelections(options) {
            options = options || {};
            if (barangaySelectionState.selected.size === 0 && !options.force) {
                return;
            }
            barangaySelectionState.selected.clear();
            var dropdown = document.getElementById('barangay-multiselect-dropdown');
            if (dropdown) {
                dropdown.querySelectorAll('input[type="checkbox"]').forEach(function(cb) {
                    cb.checked = false;
                });
            }
            updateBarangaySelectionDisplay();
            console.log('Barangay selections cleared.', options.reason ? '(' + options.reason + ')' : '');
            handleBarangaySelectionChange({ skipZoom: true, reason: options.reason || 'clear' });
        }

        /**
         * Handles changes to barangay selection and triggers related updates.
         * Updates map highlights, filters households, updates people table, and updates charts.
         * This is the main coordination function for barangay selection changes.
         * Called by: handleBarangayOptionToggle(), clearBarangaySelections(), renderBarangayOptions()
         * Connected to: clearHighlight(), highlightSelectedPolygon(), zoomToArea(),
         *              updatePeopleBarangayDisplay(), updateFloodExtentAvailability(),
         *              filterHouseholdsBySelectedBarangay(), applyPeopleFiltersAndRender(), updateCharts()
         */
        function handleBarangaySelectionChange(options) {
            options = options || {};
            var selections = getSelectedBarangays();
            if (!options.reason) {
                console.log('Barangay selection change detected.');
            }
            console.log('Current barangay selections:', selections, 'Reason:', options.reason || 'unknown');
            if (selections.length === 0) {
                clearHighlight();
                // Hide offcanvas when no barangay is selected
                var offcanvasElement = document.getElementById('offcanvasRight');
                if (offcanvasElement) {
                    var offcanvas = bootstrap.Offcanvas.getInstance(offcanvasElement);
                    if (offcanvas) {
                        offcanvas.hide();
                    }
                }
            } else {
                highlightSelectedPolygon();
                if (!options.skipZoom) {
                    zoomToArea();
                }
                // Show offcanvas when barangay is selected
                var offcanvasElement = document.getElementById('offcanvasRight');
                if (offcanvasElement) {
                    // Update offcanvas title with selected barangay names
                    var titleElement = document.getElementById('offcanvasRightLabel');
                    if (titleElement) {
                        if (selections.length === 1) {
                            titleElement.textContent = 'Barangay: ' + selections[0];
                        } else {
                            titleElement.textContent = 'Selected Barangay/s (' + selections.length + ')';
                        }
                    }
                    
                    var offcanvas = bootstrap.Offcanvas.getInstance(offcanvasElement);
                    if (!offcanvas) {
                        offcanvas = new bootstrap.Offcanvas(offcanvasElement);
                    }
                    offcanvas.show();
                }
            }
            updatePeopleBarangayDisplay();
            updateFloodExtentAvailability();
            filterHouseholdsBySelectedBarangay();
            filterStoTomasHouseholdsByBarangay();
            if (selections.length > 0) {
                // People layer is disabled - no need to hide it
                // setPeopleLayerVisible(false);
            } else if (householdLayersVisible) {
                // Household layers are disabled - don't show them
                // setBaseHouseholdLayersVisible(true);
                setBaseHouseholdLayersVisible(false);
            }
            applyPeopleFiltersAndRender();
            updateCharts();
            updateRightPaneCharts();
            
            // Don't show charts panel when flood extent is selected
            // Charts panel is hidden when flood extent is selected
            hideChartsPanel();
        }
        
        /**
         * ============================================================================
         * REGION MULTISELECT FUNCTIONS
         * ============================================================================
         * 
         * These functions implement a multiselect dropdown for Region selection.
         * 
         * How it works:
         * - Users can select multiple regions simultaneously via checkboxes
         * - Selection state is stored in regionSelectionState.selected (a Set)
         * - The button displays "Select Region", single region name, or count of selections
         * - Selecting/deselecting regions triggers updates to Province, Municipality, and Barangay dropdowns
         * - The dropdown opens/closes on button click and closes when clicking outside
         * - Selection changes are logged to console for debugging
         * 
         * Workflow:
         * 1. initializeRegionMultiselect() - Sets up click handlers (called once on page load)
         * 2. populateDropdowns() - Populates initial region options from GeoJSON data
         * 3. renderRegionOptions() - Renders checkboxes for available regions
         * 4. handleRegionOptionToggle() - Handles checkbox click (add/remove from selection)
         * 5. handleRegionSelectionChange() - Coordinates updates (cascades to lower dropdowns)
         * 6. updateProvinceDropdown() - Filters provinces based on selected regions
         * 
         * Connected to: Province, Municipality, Barangay multiselects (hierarchical filtering)
         * ============================================================================
         */

        /**
         * Initializes the region multiselect dropdown component.
         * Sets up click handlers for opening/closing the dropdown and prevents event bubbling.
         * This must be called once during page initialization before using the region multiselect.
         * Uses global variable 'regionDropdownInitialized' to prevent multiple initializations.
         * Connected to: toggleRegionDropdown(), closeRegionDropdown(), renderRegionOptions()
         */
        function initializeRegionMultiselect() {
            if (regionDropdownInitialized) return;
            console.log('Initializing region multiselect...');
            var button = document.getElementById('region-multiselect-button');
            var dropdown = document.getElementById('region-multiselect-dropdown');
            if (!button || !dropdown) {
                console.warn('Region multiselect elements not found');
                return;
            }

            button.addEventListener('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                var willOpen = !dropdown.classList.contains('is-open');
                toggleRegionDropdown(willOpen);
                console.log('Region dropdown toggled:', willOpen ? 'open' : 'closed');
            });

            dropdown.addEventListener('click', function(event) {
                event.stopPropagation();
            });

            document.addEventListener('click', function() {
                closeRegionDropdown();
            });

            regionDropdownInitialized = true;
            console.log('Region multiselect initialized successfully');
        }

        /**
         * Toggles the region multiselect dropdown open/closed state.
         * Adds or removes 'is-open' class from button and dropdown elements to control visibility.
         * Called by: initializeRegionMultiselect(), closeRegionDropdown()
         * Connected to: closeRegionDropdown()
         */
        function toggleRegionDropdown(shouldOpen) {
            var button = document.getElementById('region-multiselect-button');
            var dropdown = document.getElementById('region-multiselect-dropdown');
            if (!button || !dropdown) return;
            if (shouldOpen) {
                dropdown.classList.add('is-open');
                button.classList.add('is-open');
            } else {
                dropdown.classList.remove('is-open');
                button.classList.remove('is-open');
            }
        }

        /**
         * Closes the region multiselect dropdown.
         * Wrapper function that calls toggleRegionDropdown(false).
         * Called when clicking outside the dropdown or when closing programmatically.
         * Connected to: toggleRegionDropdown()
         */
        function closeRegionDropdown() {
            toggleRegionDropdown(false);
        }

        /**
         * Returns an array of currently selected region names.
         * Converts the Set stored in regionSelectionState.selected to an array.
         * Used throughout the application to check which regions are selected.
         * Connected to: updateProvinceDropdown(), handleRegionSelectionChange(),
         *              renderRegionOptions(), getSelectedRegions()
         */
        function getSelectedRegions() {
            return Array.from(regionSelectionState.selected);
        }

        /**
         * Normalizes a region name for comparison by converting to lowercase and trimming whitespace.
         * Used to ensure consistent matching when comparing region names from different sources.
         * Called by: updateProvinceDropdown(), handleRegionOptionToggle()
         */
        function normalizeRegionName(value) {
            return (value || '').toString().trim().toLowerCase();
        }

        /**
         * Updates the display text on the region multiselect button.
         * Shows "Select Region", single region name, or count of selected regions.
         * Called whenever region selection changes.
         * Connected to: handleRegionOptionToggle(), renderRegionOptions(), clearRegionSelections()
         */
        function updateRegionSelectionDisplay() {
            var button = document.getElementById('region-multiselect-button');
            if (!button) return;
            var selections = getSelectedRegions();
            if (regionSelectionState.options.length === 0) {
                button.textContent = 'Select Region';
                return;
            }
            if (selections.length === 0) {
                button.textContent = 'Select Region';
            } else if (selections.length === 1) {
                button.textContent = selections[0];
            } else {
                button.textContent = selections.length + ' regions selected';
            }
        }

        /**
         * Renders the region multiselect dropdown options as checkboxes.
         * Creates checkbox elements for each region and maintains selection state.
         * Prunes selections that are no longer available in the current options.
         * This is the main rendering function that populates the dropdown with interactive checkboxes.
         * Called by: populateDropdowns()
         * Connected to: handleRegionOptionToggle(), updateRegionSelectionDisplay(),
         *              handleRegionSelectionChange(), regionSelectionState
         */
        function renderRegionOptions(regions) {
            var dropdown = document.getElementById('region-multiselect-dropdown');
            if (!dropdown) return;

            dropdown.innerHTML = '';
            regionSelectionState.options = Array.isArray(regions) ? regions.slice() : [];

            if (!regionSelectionState.options.length) {
                regionSelectionState.selected.clear();
                dropdown.innerHTML = '<div class="multiselect-empty">No regions available</div>';
                updateRegionSelectionDisplay();
                handleRegionSelectionChange({ skipZoom: true, reason: 'options-cleared' });
                return;
            }

            var previousSelection = new Set(regionSelectionState.selected);
            regionSelectionState.selected.clear();
            var availableSet = new Set(regionSelectionState.options);
            var selectionChanged = false;

            // Preserve previous selections that are still available
            previousSelection.forEach(function(name) {
                if (availableSet.has(name)) {
                    regionSelectionState.selected.add(name);
                } else {
                    selectionChanged = true;
                }
            });

            // Create checkbox elements for each region
            var fragment = document.createDocumentFragment();
            regionSelectionState.options.forEach(function(name, index) {
                var option = document.createElement('div');
                option.className = 'multiselect-option';

                var checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = 'region-checkbox-' + index;
                checkbox.value = name;
                checkbox.checked = regionSelectionState.selected.has(name);
                checkbox.addEventListener('change', function(event) {
                    handleRegionOptionToggle(name, event.target.checked);
                });

                var label = document.createElement('label');
                label.setAttribute('for', checkbox.id);
                label.textContent = name;

                option.appendChild(checkbox);
                option.appendChild(label);
                fragment.appendChild(option);
            });

            dropdown.appendChild(fragment);
            updateRegionSelectionDisplay();

            if (selectionChanged) {
                console.log('Pruned region selections that are no longer available.');
                handleRegionSelectionChange({ skipZoom: true, reason: 'pruned-selection' });
            }
            
            console.log('Region options rendered:', regionSelectionState.options.length, 'options');
        }

        /**
         * Handles checkbox toggle for a region option in the multiselect dropdown.
         * Adds or removes the region from the selection state and triggers cascading updates.
         * When a region is selected/deselected, it automatically updates the Province dropdown
         * which in turn updates Municipality and Barangay dropdowns.
         * Called when a checkbox is clicked in the region dropdown.
         * Connected to: updateRegionSelectionDisplay(), handleRegionSelectionChange(),
         *              regionSelectionState.selected
         */
        function handleRegionOptionToggle(name, isChecked) {
            if (!name) return;
            if (isChecked) {
                regionSelectionState.selected.add(name);
                console.log('Region selected:', name);
            } else {
                regionSelectionState.selected.delete(name);
                console.log('Region deselected:', name);
            }
            updateRegionSelectionDisplay();
            console.log('Region selection updated:', getSelectedRegions());
            handleRegionSelectionChange({ reason: 'checkbox' });
            // Auto-collapse dropdown after selection
            closeRegionDropdown();
        }

        /**
         * Handles changes to region selection and triggers cascading updates.
         * When regions are selected/deselected, this function:
         * 1. Updates the Province dropdown to show only provinces in selected regions
         * 2. Cascades updates to Municipality and Barangay dropdowns
         * 3. Updates map highlights and zooms to selected regions (if applicable)
         * This is the main coordination function for region selection changes.
         * Called by: handleRegionOptionToggle(), clearRegionSelections(), renderRegionOptions()
         * Connected to: updateProvinceDropdown(), updateMunicipalityDropdown(), updateBarangayDropdown(),
         *              clearHighlight(), highlightSelectedPolygon(), zoomToArea()
         */
        function handleRegionSelectionChange(options) {
            options = options || {};
            var selections = getSelectedRegions();
            if (!options.reason) {
                console.log('Region selection change detected.');
            }
            console.log('Current region selections:', selections, 'Reason:', options.reason || 'unknown');
            
            // Update lower-level dropdowns based on region selection
            if (selections.length === 0) {
                    clearHighlight();
                // Clear all lower dropdowns
                clearProvinceSelections({ reason: 'region-cleared' });
                clearMunicipalitySelections({ reason: 'region-cleared' });
                clearBarangaySelections({ reason: 'region-cleared' });
            } else {
                // Update province dropdown to show only provinces in selected regions
                    updateProvinceDropdown();
                if (!options.skipZoom) {
                        highlightSelectedPolygon();
                    zoomToArea();
                }
            }
        }

        /**
         * Clears all region selections from the multiselect dropdown.
         * Unchecks all checkboxes and clears the selection state.
         * Can be forced to clear even if already empty.
         * Called by: clearLowerDropdowns(), handleRegionSelectionChange()
         * Connected to: updateRegionSelectionDisplay(), handleRegionSelectionChange(),
         *              regionSelectionState.selected
         */
        function clearRegionSelections(options) {
            options = options || {};
            if (regionSelectionState.selected.size === 0 && !options.force) {
                return;
            }
            regionSelectionState.selected.clear();
            var dropdown = document.getElementById('region-multiselect-dropdown');
            if (dropdown) {
                dropdown.querySelectorAll('input[type="checkbox"]').forEach(function(cb) {
                    cb.checked = false;
                });
            }
            updateRegionSelectionDisplay();
            console.log('Region selections cleared.', options.reason ? '(' + options.reason + ')' : '');
            handleRegionSelectionChange({ skipZoom: true, reason: options.reason || 'clear' });
        }

        /**
         * ============================================================================
         * PROVINCE MULTISELECT FUNCTIONS
         * ============================================================================
         * 
         * These functions implement a multiselect dropdown for Province selection.
         * 
         * How it works:
         * - Users can select multiple provinces simultaneously via checkboxes
         * - Selection state is stored in provinceSelectionState.selected (a Set)
         * - Provinces are filtered based on selected regions (hierarchical filtering)
         * - The button displays "Select Province", single province name, or count of selections
         * - Selecting/deselecting provinces triggers updates to Municipality and Barangay dropdowns
         * - The dropdown opens/closes on button click and closes when clicking outside
         * - Selection changes are logged to console for debugging
         * 
         * Workflow:
         * 1. initializeProvinceMultiselect() - Sets up click handlers (called once on page load)
         * 2. updateProvinceDropdown() - Populates province options based on selected regions
         * 3. renderProvinceOptions() - Renders checkboxes for available provinces
         * 4. handleProvinceOptionToggle() - Handles checkbox click (add/remove from selection)
         * 5. handleProvinceSelectionChange() - Coordinates updates (cascades to lower dropdowns)
         * 6. updateMunicipalityDropdown() - Filters municipalities based on selected provinces
         * 
         * Connected to: Region multiselect (filters provinces), Municipality and Barangay multiselects (hierarchical filtering)
         * ============================================================================
         */

        /**
         * Initializes the province multiselect dropdown component.
         * Sets up click handlers for opening/closing the dropdown and prevents event bubbling.
         * This must be called once during page initialization before using the province multiselect.
         * Uses global variable 'provinceDropdownInitialized' to prevent multiple initializations.
         * Connected to: toggleProvinceDropdown(), closeProvinceDropdown(), renderProvinceOptions()
         */
        function initializeProvinceMultiselect() {
            if (provinceDropdownInitialized) return;
            console.log('Initializing province multiselect...');
            var button = document.getElementById('province-multiselect-button');
            var dropdown = document.getElementById('province-multiselect-dropdown');
            if (!button || !dropdown) {
                console.warn('Province multiselect elements not found');
                return;
            }

            button.addEventListener('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                var willOpen = !dropdown.classList.contains('is-open');
                toggleProvinceDropdown(willOpen);
                console.log('Province dropdown toggled:', willOpen ? 'open' : 'closed');
            });

            dropdown.addEventListener('click', function(event) {
                event.stopPropagation();
            });

            document.addEventListener('click', function() {
                closeProvinceDropdown();
            });

            provinceDropdownInitialized = true;
            console.log('Province multiselect initialized successfully');
        }

        /**
         * Toggles the province multiselect dropdown open/closed state.
         * Adds or removes 'is-open' class from button and dropdown elements to control visibility.
         * Called by: initializeProvinceMultiselect(), closeProvinceDropdown()
         * Connected to: closeProvinceDropdown()
         */
        function toggleProvinceDropdown(shouldOpen) {
            var button = document.getElementById('province-multiselect-button');
            var dropdown = document.getElementById('province-multiselect-dropdown');
            if (!button || !dropdown) return;
            if (shouldOpen) {
                dropdown.classList.add('is-open');
                button.classList.add('is-open');
            } else {
                dropdown.classList.remove('is-open');
                button.classList.remove('is-open');
            }
        }

        /**
         * Closes the province multiselect dropdown.
         * Wrapper function that calls toggleProvinceDropdown(false).
         * Called when clicking outside the dropdown or when closing programmatically.
         * Connected to: toggleProvinceDropdown()
         */
        function closeProvinceDropdown() {
            toggleProvinceDropdown(false);
        }

        /**
         * Returns an array of currently selected province names.
         * Converts the Set stored in provinceSelectionState.selected to an array.
         * Used throughout the application to check which provinces are selected.
         * Connected to: updateMunicipalityDropdown(), handleProvinceSelectionChange(),
         *              renderProvinceOptions(), getSelectedProvinces()
         */
        function getSelectedProvinces() {
            return Array.from(provinceSelectionState.selected);
        }

        /**
         * Normalizes a province name for comparison by converting to lowercase and trimming whitespace.
         * Used to ensure consistent matching when comparing province names from different sources.
         * Called by: updateMunicipalityDropdown(), handleProvinceOptionToggle()
         */
        function normalizeProvinceName(value) {
            return (value || '').toString().trim().toLowerCase();
        }

        /**
         * Updates the display text on the province multiselect button.
         * Shows "Select Province", single province name, or count of selected provinces.
         * Called whenever province selection changes.
         * Connected to: handleProvinceOptionToggle(), renderProvinceOptions(), clearProvinceSelections()
         */
        function updateProvinceSelectionDisplay() {
            var button = document.getElementById('province-multiselect-button');
            if (!button) return;
            var selections = getSelectedProvinces();
            if (provinceSelectionState.options.length === 0) {
                button.textContent = 'Select Province';
                return;
            }
            if (selections.length === 0) {
                button.textContent = 'Select Province';
            } else if (selections.length === 1) {
                button.textContent = selections[0];
            } else {
                button.textContent = selections.length + ' provinces selected';
            }
        }

        /**
         * Renders the province multiselect dropdown options as checkboxes.
         * Creates checkbox elements for each province and maintains selection state.
         * Prunes selections that are no longer available in the current options.
         * This is the main rendering function that populates the dropdown with interactive checkboxes.
         * Called by: updateProvinceDropdown()
         * Connected to: handleProvinceOptionToggle(), updateProvinceSelectionDisplay(),
         *              handleProvinceSelectionChange(), provinceSelectionState
         */
        function renderProvinceOptions(provinces) {
            var dropdown = document.getElementById('province-multiselect-dropdown');
            if (!dropdown) return;

            dropdown.innerHTML = '';
            provinceSelectionState.options = Array.isArray(provinces) ? provinces.slice() : [];

            if (!provinceSelectionState.options.length) {
                provinceSelectionState.selected.clear();
                dropdown.innerHTML = '<div class="multiselect-empty">Select a region first</div>';
                updateProvinceSelectionDisplay();
                handleProvinceSelectionChange({ skipZoom: true, reason: 'options-cleared' });
                return;
            }

            var previousSelection = new Set(provinceSelectionState.selected);
            provinceSelectionState.selected.clear();
            var availableSet = new Set(provinceSelectionState.options);
            var selectionChanged = false;

            // Preserve previous selections that are still available
            previousSelection.forEach(function(name) {
                if (availableSet.has(name)) {
                    provinceSelectionState.selected.add(name);
                } else {
                    selectionChanged = true;
                }
            });

            // Create checkbox elements for each province
            var fragment = document.createDocumentFragment();
            provinceSelectionState.options.forEach(function(name, index) {
                var option = document.createElement('div');
                option.className = 'multiselect-option';

                var checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = 'province-checkbox-' + index;
                checkbox.value = name;
                checkbox.checked = provinceSelectionState.selected.has(name);
                checkbox.addEventListener('change', function(event) {
                    handleProvinceOptionToggle(name, event.target.checked);
                });

                var label = document.createElement('label');
                label.setAttribute('for', checkbox.id);
                label.textContent = name;

                option.appendChild(checkbox);
                option.appendChild(label);
                fragment.appendChild(option);
            });

            dropdown.appendChild(fragment);
            updateProvinceSelectionDisplay();

            if (selectionChanged) {
                console.log('Pruned province selections that are no longer available.');
                handleProvinceSelectionChange({ skipZoom: true, reason: 'pruned-selection' });
            }
            
            console.log('Province options rendered:', provinceSelectionState.options.length, 'options');
        }

        /**
         * Handles checkbox toggle for a province option in the multiselect dropdown.
         * Adds or removes the province from the selection state and triggers cascading updates.
         * When a province is selected/deselected, it automatically updates the Municipality dropdown
         * which in turn updates the Barangay dropdown.
         * Called when a checkbox is clicked in the province dropdown.
         * Connected to: updateProvinceSelectionDisplay(), handleProvinceSelectionChange(),
         *              provinceSelectionState.selected
         */
        function handleProvinceOptionToggle(name, isChecked) {
            if (!name) return;
            if (isChecked) {
                provinceSelectionState.selected.add(name);
                console.log('Province selected:', name);
            } else {
                provinceSelectionState.selected.delete(name);
                console.log('Province deselected:', name);
            }
            updateProvinceSelectionDisplay();
            console.log('Province selection updated:', getSelectedProvinces());
            handleProvinceSelectionChange({ reason: 'checkbox' });
            // Auto-collapse dropdown after selection
            closeProvinceDropdown();
        }

        /**
         * Handles changes to province selection and triggers cascading updates.
         * When provinces are selected/deselected, this function:
         * 1. Updates the Municipality dropdown to show only municipalities in selected provinces
         * 2. Cascades updates to Barangay dropdown
         * 3. Updates map highlights and zooms to selected provinces (if applicable)
         * This is the main coordination function for province selection changes.
         * Called by: handleProvinceOptionToggle(), clearProvinceSelections(), renderProvinceOptions()
         * Connected to: updateMunicipalityDropdown(), updateBarangayDropdown(),
         *              clearHighlight(), highlightSelectedPolygon(), zoomToArea()
         */
        function handleProvinceSelectionChange(options) {
            options = options || {};
            var selections = getSelectedProvinces();
            if (!options.reason) {
                console.log('Province selection change detected.');
            }
            console.log('Current province selections:', selections, 'Reason:', options.reason || 'unknown');
            
            // Update lower-level dropdowns based on province selection
            if (selections.length === 0) {
                    clearHighlight();
                // Clear all lower dropdowns
                clearMunicipalitySelections({ reason: 'province-cleared' });
                clearBarangaySelections({ reason: 'province-cleared' });
            } else {
                // Update municipality dropdown to show only municipalities in selected provinces
                    updateMunicipalityDropdown();
                if (!options.skipZoom) {
                        highlightSelectedPolygon();
                    zoomToArea();
                }
            }
        }

        /**
         * Clears all province selections from the multiselect dropdown.
         * Unchecks all checkboxes and clears the selection state.
         * Can be forced to clear even if already empty.
         * Called by: clearLowerDropdowns(), handleRegionSelectionChange(), handleProvinceSelectionChange()
         * Connected to: updateProvinceSelectionDisplay(), handleProvinceSelectionChange(),
         *              provinceSelectionState.selected
         */
        function clearProvinceSelections(options) {
            options = options || {};
            if (provinceSelectionState.selected.size === 0 && !options.force) {
                return;
            }
            provinceSelectionState.selected.clear();
            var dropdown = document.getElementById('province-multiselect-dropdown');
            if (dropdown) {
                dropdown.querySelectorAll('input[type="checkbox"]').forEach(function(cb) {
                    cb.checked = false;
                });
            }
            updateProvinceSelectionDisplay();
            console.log('Province selections cleared.', options.reason ? '(' + options.reason + ')' : '');
            handleProvinceSelectionChange({ skipZoom: true, reason: options.reason || 'clear' });
        }

        /**
         * ============================================================================
         * MUNICIPALITY MULTISELECT FUNCTIONS
         * ============================================================================
         * 
         * These functions implement a multiselect dropdown for Municipality selection.
         * 
         * How it works:
         * - Users can select multiple municipalities simultaneously via checkboxes
         * - Selection state is stored in municipalitySelectionState.selected (a Set)
         * - Municipalities are filtered based on selected regions and provinces (hierarchical filtering)
         * - The button displays "Select Municipality", single municipality name, or count of selections
         * - Selecting/deselecting municipalities triggers updates to Barangay dropdown
         * - The dropdown opens/closes on button click and closes when clicking outside
         * - Selection changes are logged to console for debugging
         * 
         * Workflow:
         * 1. initializeMunicipalityMultiselect() - Sets up click handlers (called once on page load)
         * 2. updateMunicipalityDropdown() - Populates municipality options based on selected regions/provinces
         * 3. renderMunicipalityOptions() - Renders checkboxes for available municipalities
         * 4. handleMunicipalityOptionToggle() - Handles checkbox click (add/remove from selection)
         * 5. handleMunicipalitySelectionChange() - Coordinates updates (cascades to Barangay dropdown)
         * 6. updateBarangayDropdown() - Filters barangays based on selected municipalities
         * 
         * Connected to: Region and Province multiselects (filters municipalities), Barangay multiselect (hierarchical filtering)
         * ============================================================================
         */

        /**
         * Initializes the municipality multiselect dropdown component.
         * Sets up click handlers for opening/closing the dropdown and prevents event bubbling.
         * This must be called once during page initialization before using the municipality multiselect.
         * Uses global variable 'municipalityDropdownInitialized' to prevent multiple initializations.
         * Connected to: toggleMunicipalityDropdown(), closeMunicipalityDropdown(), renderMunicipalityOptions()
         */
        function initializeMunicipalityMultiselect() {
            if (municipalityDropdownInitialized) return;
            console.log('Initializing municipality multiselect...');
            var button = document.getElementById('municipality-multiselect-button');
            var dropdown = document.getElementById('municipality-multiselect-dropdown');
            if (!button || !dropdown) {
                console.warn('Municipality multiselect elements not found');
                return;
            }

            button.addEventListener('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                var willOpen = !dropdown.classList.contains('is-open');
                toggleMunicipalityDropdown(willOpen);
                console.log('Municipality dropdown toggled:', willOpen ? 'open' : 'closed');
            });

            dropdown.addEventListener('click', function(event) {
                event.stopPropagation();
            });

            document.addEventListener('click', function() {
                closeMunicipalityDropdown();
            });

            municipalityDropdownInitialized = true;
            console.log('Municipality multiselect initialized successfully');
        }

        /**
         * Toggles the municipality multiselect dropdown open/closed state.
         * Adds or removes 'is-open' class from button and dropdown elements to control visibility.
         * Called by: initializeMunicipalityMultiselect(), closeMunicipalityDropdown()
         * Connected to: closeMunicipalityDropdown()
         */
        function toggleMunicipalityDropdown(shouldOpen) {
            var button = document.getElementById('municipality-multiselect-button');
            var dropdown = document.getElementById('municipality-multiselect-dropdown');
            if (!button || !dropdown) return;
            if (shouldOpen) {
                dropdown.classList.add('is-open');
                button.classList.add('is-open');
            } else {
                dropdown.classList.remove('is-open');
                button.classList.remove('is-open');
            }
        }

        /**
         * Closes the municipality multiselect dropdown.
         * Wrapper function that calls toggleMunicipalityDropdown(false).
         * Called when clicking outside the dropdown or when closing programmatically.
         * Connected to: toggleMunicipalityDropdown()
         */
        function closeMunicipalityDropdown() {
            toggleMunicipalityDropdown(false);
        }

        /**
         * Returns an array of currently selected municipality names.
         * Converts the Set stored in municipalitySelectionState.selected to an array.
         * Used throughout the application to check which municipalities are selected.
         * Connected to: updateBarangayDropdown(), handleMunicipalitySelectionChange(),
         *              renderMunicipalityOptions(), getSelectedMunicipalities()
         */
        function getSelectedMunicipalities() {
            return Array.from(municipalitySelectionState.selected);
        }

        /**
         * Normalizes a municipality name for comparison by converting to lowercase and trimming whitespace.
         * Used to ensure consistent matching when comparing municipality names from different sources.
         * Called by: updateBarangayDropdown(), handleMunicipalityOptionToggle()
         */
        function normalizeMunicipalityName(value) {
            return (value || '').toString().trim().toLowerCase();
        }

        /**
         * Updates the display text on the municipality multiselect button.
         * Shows "Select Municipality", single municipality name, or count of selected municipalities.
         * Called whenever municipality selection changes.
         * Connected to: handleMunicipalityOptionToggle(), renderMunicipalityOptions(), clearMunicipalitySelections()
         */
        function updateMunicipalitySelectionDisplay() {
            var button = document.getElementById('municipality-multiselect-button');
            if (!button) return;
            var selections = getSelectedMunicipalities();
            if (municipalitySelectionState.options.length === 0) {
                button.textContent = 'Select Municipality';
                return;
            }
            if (selections.length === 0) {
                button.textContent = 'Select Municipality';
            } else if (selections.length === 1) {
                button.textContent = selections[0];
            } else {
                button.textContent = selections.length + ' municipalities selected';
            }
        }

        /**
         * Renders the municipality multiselect dropdown options as checkboxes.
         * Creates checkbox elements for each municipality and maintains selection state.
         * Prunes selections that are no longer available in the current options.
         * This is the main rendering function that populates the dropdown with interactive checkboxes.
         * Called by: updateMunicipalityDropdown()
         * Connected to: handleMunicipalityOptionToggle(), updateMunicipalitySelectionDisplay(),
         *              handleMunicipalitySelectionChange(), municipalitySelectionState
         */
        function renderMunicipalityOptions(municipalities) {
            var dropdown = document.getElementById('municipality-multiselect-dropdown');
            if (!dropdown) return;

            dropdown.innerHTML = '';
            municipalitySelectionState.options = Array.isArray(municipalities) ? municipalities.slice() : [];

            if (!municipalitySelectionState.options.length) {
                municipalitySelectionState.selected.clear();
                dropdown.innerHTML = '<div class="multiselect-empty">Select a province first</div>';
                updateMunicipalitySelectionDisplay();
                handleMunicipalitySelectionChange({ skipZoom: true, reason: 'options-cleared' });
                return;
            }

            var previousSelection = new Set(municipalitySelectionState.selected);
            municipalitySelectionState.selected.clear();
            var availableSet = new Set(municipalitySelectionState.options);
            var selectionChanged = false;

            // Preserve previous selections that are still available
            previousSelection.forEach(function(name) {
                if (availableSet.has(name)) {
                    municipalitySelectionState.selected.add(name);
                } else {
                    selectionChanged = true;
                }
            });

            // Create checkbox elements for each municipality
            var fragment = document.createDocumentFragment();
            municipalitySelectionState.options.forEach(function(name, index) {
                var option = document.createElement('div');
                option.className = 'multiselect-option';

                var checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = 'municipality-checkbox-' + index;
                checkbox.value = name;
                checkbox.checked = municipalitySelectionState.selected.has(name);
                checkbox.addEventListener('change', function(event) {
                    handleMunicipalityOptionToggle(name, event.target.checked);
                });

                var label = document.createElement('label');
                label.setAttribute('for', checkbox.id);
                label.textContent = name;

                option.appendChild(checkbox);
                option.appendChild(label);
                fragment.appendChild(option);
            });

            dropdown.appendChild(fragment);
            updateMunicipalitySelectionDisplay();

            if (selectionChanged) {
                console.log('Pruned municipality selections that are no longer available.');
                handleMunicipalitySelectionChange({ skipZoom: true, reason: 'pruned-selection' });
            }
            
            console.log('Municipality options rendered:', municipalitySelectionState.options.length, 'options');
        }

        /**
         * Handles checkbox toggle for a municipality option in the multiselect dropdown.
         * Adds or removes the municipality from the selection state and triggers cascading updates.
         * When a municipality is selected/deselected, it automatically updates the Barangay dropdown.
         * Called when a checkbox is clicked in the municipality dropdown.
         * Connected to: updateMunicipalitySelectionDisplay(), handleMunicipalitySelectionChange(),
         *              municipalitySelectionState.selected
         */
        function handleMunicipalityOptionToggle(name, isChecked) {
            if (!name) return;
            if (isChecked) {
                municipalitySelectionState.selected.add(name);
                console.log('Municipality selected:', name);
            } else {
                municipalitySelectionState.selected.delete(name);
                console.log('Municipality deselected:', name);
            }
            updateMunicipalitySelectionDisplay();
            console.log('Municipality selection updated:', getSelectedMunicipalities());
            handleMunicipalitySelectionChange({ reason: 'checkbox' });
            // Auto-collapse dropdown after selection
            closeMunicipalityDropdown();
        }

        /**
         * Handles changes to municipality selection and triggers cascading updates.
         * When municipalities are selected/deselected, this function:
         * 1. Updates the Barangay dropdown to show only barangays in selected municipalities
         * 2. Updates map highlights and zooms to selected municipalities (if applicable)
         * This is the main coordination function for municipality selection changes.
         * Called by: handleMunicipalityOptionToggle(), clearMunicipalitySelections(), renderMunicipalityOptions()
         * Connected to: updateBarangayDropdown(),
         *              clearHighlight(), highlightSelectedPolygon(), zoomToArea()
         */
        function handleMunicipalitySelectionChange(options) {
            options = options || {};
            var selections = getSelectedMunicipalities();
            if (!options.reason) {
                console.log('Municipality selection change detected.');
            }
            console.log('Current municipality selections:', selections, 'Reason:', options.reason || 'unknown');
            
            // Update lower-level dropdowns based on municipality selection
            if (selections.length === 0) {
                    clearHighlight();
                // Clear barangay dropdown
                clearBarangaySelections({ reason: 'municipality-cleared' });
            } else {
                // Update barangay dropdown to show only barangays in selected municipalities
                updateBarangayDropdown();
                if (!options.skipZoom) {
                        highlightSelectedPolygon();
                    zoomToArea();
                }
            }
        }

        /**
         * Clears all municipality selections from the multiselect dropdown.
         * Unchecks all checkboxes and clears the selection state.
         * Can be forced to clear even if already empty.
         * Called by: clearLowerDropdowns(), handleProvinceSelectionChange(), handleMunicipalitySelectionChange()
         * Connected to: updateMunicipalitySelectionDisplay(), handleMunicipalitySelectionChange(),
         *              municipalitySelectionState.selected
         */
        function clearMunicipalitySelections(options) {
            options = options || {};
            if (municipalitySelectionState.selected.size === 0 && !options.force) {
                return;
            }
            municipalitySelectionState.selected.clear();
            var dropdown = document.getElementById('municipality-multiselect-dropdown');
            if (dropdown) {
                dropdown.querySelectorAll('input[type="checkbox"]').forEach(function(cb) {
                    cb.checked = false;
                });
            }
            updateMunicipalitySelectionDisplay();
            console.log('Municipality selections cleared.', options.reason ? '(' + options.reason + ')' : '');
            handleMunicipalitySelectionChange({ skipZoom: true, reason: options.reason || 'clear' });
        }

        /**
         * Sets up event listeners for navigation buttons (Household, Roads, Schools, Documentation).
         * Handles button clicks and toggles layer visibility or navigation.
         * Called during page initialization.
         * Connected to: toggleLayer(), toggleButtonActive()
         */
        function setupNavigationButtons() {
            console.log('Setting up navigation buttons...');
            
            // Household button
            var householdBtn = document.getElementById('household-btn');
            if (householdBtn) {
                console.log('Household button found, adding event listener');
                householdBtn.addEventListener('click', function() {
                    if (this.disabled || this.classList.contains('is-disabled')) {
                        console.log('Household button click ignored - disabled state');
                        return;
                    }
                    console.log('Household button clicked');
                    // toggleLayer will handle button state via toggleButtonActive
                    toggleLayer('household');
                });
            } else {
                console.log('Household button not found');
            }
            
            // Roads button
            var roadsBtn = document.getElementById('roads-btn');
            if (roadsBtn) {
                console.log('Roads button found, adding event listener');
                roadsBtn.addEventListener('click', function() {
                    console.log('Roads button clicked');
                    toggleLayer('roads');
                    toggleButtonActive(this);
                });
            } else {
                console.log('Roads button not found');
            }
            
            // Schools button
            var schoolsBtn = document.querySelector('.nav-btn[title="Schools"]');
            if (schoolsBtn) {
                console.log('Schools button found, adding event listener');
                schoolsBtn.addEventListener('click', function() {
                    console.log('Schools button clicked');
                    toggleLayer('schools');
                    toggleButtonActive(this);
                });
            } else {
                console.log('Schools button not found');
            }
            
            // Documentation button
            var documentationBtn = document.getElementById('documentation-btn');
            if (documentationBtn) {
                console.log('Documentation button found, adding event listener');
                documentationBtn.addEventListener('click', function() {
                    console.log('Documentation button clicked');
                    window.location.href = 'Documentation.html';
                });
            } else {
                console.log('Documentation button not found');
            }
        }
        /**
         * ============================================================================
         * ENSURE PEOPLE LAYER FUNCTION - DISABLED
         * ============================================================================
         * 
         * This function ensures the People layer is initialized and added to the map.
         * 
         * HOW IT WORKS (currently disabled):
         * - Creates a vector layer from json_People_0 GeoJSON data if it doesn't already exist
         * - Adds the layer to the map with appropriate styling
         * - Sets initial visibility to false
         * - Currently disabled: Function returns immediately without creating the layer
         * 
         * CURRENT STATE:
         * - People_0.js script is DISABLED (commented out in HTML)
         * - ensurePeopleLayer() is DISABLED (returns immediately)
         * - setPeopleLayerVisible() is DISABLED (does nothing)
         * - Layer will never be created or shown on the map
         * 
         * NOTE: People_0.js layer is permanently disabled. It will not load even when
         * the household button is clicked.
         * 
         * TO RE-ENABLE:
         * 1. Uncomment the People_0.js script tag in HTML
         * 2. Uncomment the People_0_style.js script tag in HTML
         * 3. Remove the early return statement below
         * 4. Uncomment the ensurePeopleLayer() call during map initialization
         * 
         * Called during map initialization and when toggling layers (but currently disabled).
         * Uses global variable 'peopleLayer'.
         * Connected to: setPeopleLayerVisible(), toggleLayer()
         * ============================================================================
         */
        function ensurePeopleLayer() {
            // PEOPLE_0.JS IS DISABLED - Return immediately without creating layer
            console.log('People layer initialization skipped - People_0.js is disabled');
            return;
            
            // Original code below is disabled but preserved for future use
            /*
            if (peopleLayer || typeof map === 'undefined' || !map.getView || !map.getView().getProjection) {
                return;
            }
            if (typeof json_People_0 === 'undefined') {
                console.warn('People layer data unavailable');
                return;
            }

            try {
                var format = new ol.format.GeoJSON({
                    dataProjection: 'EPSG:4326',
                    featureProjection: map.getView().getProjection()
                });
                var features = format.readFeatures(json_People_0);
                peopleLayer = new ol.layer.Vector({
                    source: new ol.source.Vector({
                        features: features
                    }),
                    style: (typeof style_People_0 === 'function') ? style_People_0 : undefined,
                    title: 'People_0',
                    visible: false,
                    zIndex: 1100
                });
                map.addLayer(peopleLayer);
            } catch (e) {
                console.error('Failed to initialize People layer:', e);
            }
            */
        }
        
        /**
         * Toggles visibility of map layers based on layer type.
         * Handles household, roads, and schools layer toggling.
         * For household layers, also manages filtered household display based on barangay selection.
         * Called by navigation button click handlers.
         * Connected to: ensureHouseholdLayers(), filterHouseholdsBySelectedBarangay(),
         *              setBaseHouseholdLayersVisible(), setPeopleLayerVisible(), toggleButtonActive()
         */
        function toggleLayer(layerType) {
            if (typeof map === 'undefined' || !map.getLayers) {
                return;
            }

                var layers = map.getLayers().getArray();
                console.log('toggleLayer called for:', layerType);

            if (layerType === 'household') {
                ensureHouseholdLayers();
                var householdBtn = document.getElementById('household-btn');
                
                // Find StoTomasHouseholdsjoined_layer_1 layer using helper function
                var stoTomasLayer = findStoTomasHouseholdsLayer();
                
                if (!stoTomasLayer) {
                    console.error('Cannot toggle household layer: StoTomasHouseholdsjoined_layer_1 layer not found. Check if the data file is loaded correctly.');
                    alert('Household layer not found. Please check the browser console for details.');
                    return;
                }
                
                if (!householdLayersVisible) {
                    // Activating: Show only StoTomasHouseholdsjoined_layer_1, hide all other layers
                    householdLayersVisible = true;
                    console.log('Activating household layer view. Showing only StoTomasHouseholdsjoined_layer_1');
                    
                    // Apply barangay filter BEFORE showing the layer, so filtered results are shown immediately
                    filterStoTomasHouseholdsByBarangay();
                    
                    // 1. Show StoTomasHouseholdsjoined_layer_1 layer
                    try {
                        stoTomasLayer.setVisible(true);
                        ensureStoTomasLayerOnTop();
                        console.log('Sto.Tomas Households layer shown successfully');
                        
                        // Update button state after successful layer activation
                        if (householdBtn) {
                            toggleButtonActive(householdBtn);
                        }
                    } catch (e) {
                        console.error('Error showing Sto.Tomas Households layer:', e);
                        householdLayersVisible = false; // Revert state on error
                    }
                    
                    // 2. Hide peopleLayer if it exists
                    if (peopleLayer && typeof peopleLayer.setVisible === 'function') {
                        peopleLayer.setVisible(false);
                        console.log('People layer hidden');
                    }
                    
                    // 3. Hide all household layers (Households_1)
                    setBaseHouseholdLayersVisible(false);
                    
                    // 4. Hide any filtered household layers
                    if (filteredHouseholdLayer) {
                        filteredHouseholdLayer.setVisible(false);
                        console.log('Filtered household layer hidden');
                    }
                } else {
                    // Deactivating: Hide StoTomasHouseholdsjoined_layer_1 layer
                    householdLayersVisible = false;
                    if (householdBtn) {
                        householdBtn.classList.remove('active');
                        toggleButtonActive(householdBtn); // Ensure button state is updated
                    }
                    console.log('Deactivating household layer view.');
                    
                    // 5. Hide StoTomasHouseholdsjoined_layer_1 layer
                    if (stoTomasLayer) {
                        try {
                            stoTomasLayer.setVisible(false);
                            console.log('Sto.Tomas Households layer hidden successfully');
                        } catch (e) {
                            console.error('Error hiding Sto.Tomas Households layer:', e);
                        }
                    }
                    
                    // Ensure all household layers remain hidden
                    setBaseHouseholdLayersVisible(false);
                    if (filteredHouseholdLayer) {
                        filteredHouseholdLayer.setVisible(false);
                        removeFilteredHouseholdLayer();
                    }
                }
                return;
            }
                
                layers.forEach(function(layer) {
                    var layerTitle = layer.get('title') || layer.get('name') || 'Unknown';
                    var layerTitleLower = layerTitle.toLowerCase();
                    console.log('Checking layer:', layerTitle, 'for type:', layerType);
                    
                if (layerType === 'roads' &&
                               (layerTitleLower.includes('roads') || layerTitleLower.includes('road') || 
                                layerTitle === 'Roads_38' || layerTitleLower.includes('roads_38'))) {
                        layer.setVisible(!layer.getVisible());
                        console.log('Toggled roads layer:', layerTitle, 'Visible:', layer.getVisible());
                    } else if (layerType === 'schools' && 
                               (layerTitleLower.includes('schools') || layerTitleLower.includes('school') || 
                                layerTitle === 'Schools_37' || layerTitleLower.includes('schools_37'))) {
                        layer.setVisible(!layer.getVisible());
                        console.log('Toggled schools layer:', layerTitle, 'Visible:', layer.getVisible());
                    }
                });
        }
        
        /**
         * Toggles the active state of navigation buttons.
         * Removes active class from all nav buttons and adds it to the clicked button.
         * Called when a navigation button is clicked.
         * Connected to: toggleLayer(), setupNavigationButtons()
         */
        function toggleButtonActive(button) {
            // Remove active class from all nav buttons
            var allNavBtns = document.querySelectorAll('.nav-btn');
            allNavBtns.forEach(function(btn) {
                btn.classList.remove('active');
            });
            
            // Add active class to clicked button
            button.classList.add('active');
        }
        
        /**
         * Updates the Province multiselect dropdown based on selected regions.
         * Extracts unique province names from Region2_39 data that match the selected regions.
         * Cascades updates to municipality and barangay dropdowns when provinces change.
         * Called when region selection changes.
         * Connected to: updateMunicipalityDropdown(), updateBarangayDropdown(), handleRegionSelectionChange(),
         *              renderProvinceOptions(), getSelectedRegions()
         */
        function updateProvinceDropdown() {
            var selectedRegions = getSelectedRegions();
            var provinces = new Set();
            
            if (selectedRegions.length > 0) {
                // Only show provinces if at least one region is selected
                var selectedRegionsSet = new Set(selectedRegions);
                json_Region2_39.features.forEach(function(feature) {
                    if (feature.properties && 
                        selectedRegionsSet.has(feature.properties.Reg_Name) && 
                        feature.properties.Pro_Name) {
                        provinces.add(feature.properties.Pro_Name);
                    }
                });
            }
            
            // Render province multiselect with sorted provinces
            var sortedProvinces = Array.from(provinces).sort();
            renderProvinceOptions(sortedProvinces);
            
            console.log('Updated province multiselect with', sortedProvinces.length, 'options for regions:', selectedRegions);
        }
        
        /**
         * Updates the Municipality multiselect dropdown based on selected regions and provinces.
         * Extracts unique municipality names from Region2_39 data that match the selected regions and provinces.
         * Cascades updates to barangay dropdown when municipalities change.
         * Called when region or province selection changes.
         * Connected to: updateBarangayDropdown(), handleProvinceSelectionChange(), updateProvinceDropdown(),
         *              renderMunicipalityOptions(), getSelectedRegions(), getSelectedProvinces()
         */
        function updateMunicipalityDropdown() {
            var selectedRegions = getSelectedRegions();
            var selectedProvinces = getSelectedProvinces();
            var municipalities = new Set();
            
            console.log('updateMunicipalityDropdown called with regions:', selectedRegions, 'provinces:', selectedProvinces);
            
            if (selectedProvinces.length > 0) {
                // Only show municipalities if at least one province is selected
                var selectedRegionsSet = new Set(selectedRegions);
                var selectedProvincesSet = new Set(selectedProvinces);
                json_Region2_39.features.forEach(function(feature) {
                    if (feature.properties && 
                        (selectedRegions.length === 0 || selectedRegionsSet.has(feature.properties.Reg_Name)) &&
                        selectedProvincesSet.has(feature.properties.Pro_Name) && 
                        feature.properties.Mun_Name) {
                        municipalities.add(feature.properties.Mun_Name);
                    }
                });
            }
            
            // Render municipality multiselect with sorted municipalities
            var sortedMunicipalities = Array.from(municipalities).sort();
            renderMunicipalityOptions(sortedMunicipalities);
            
            console.log('Updated municipality multiselect with', sortedMunicipalities.length, 'options for regions:', selectedRegions, 'provinces:', selectedProvinces);
        }
        
        /**
         * ============================================================================
         * BARANGAY DROPDOWN UPDATE FUNCTION
         * ============================================================================
         * 
         * This function updates the Barangay multiselect dropdown based on selected 
         * regions, provinces, and municipalities. It implements hierarchical filtering 
         * so that only barangays within the selected geographic hierarchy are shown.
         * 
         * How it works:
         * 1. Gets current selections from Region, Province, and Municipality multiselects
         * 2. Filters Region2_39 GeoJSON features to match selected hierarchy
         * 3. Extracts unique barangay names (using Bgy_Name property, falls back to Brg_Name)
         * 4. Renders the filtered barangays as checkboxes in the multiselect dropdown
         * 5. Logs all changes for debugging
         * 
         * Property name handling:
         * - Primary: Uses feature.properties.Bgy_Name (standard property name)
         * - Fallback: Also checks feature.properties.Brg_Name for compatibility
         * - This handles any inconsistencies in the GeoJSON data
         * 
         * Filtering logic:
         * - If regions selected: Only shows barangays in those regions
         * - If provinces selected: Only shows barangays in those provinces (within selected regions)
         * - If municipalities selected: Only shows barangays in those municipalities
         * - If nothing selected: Shows empty dropdown with "Select a municipality first" message
         * 
         * Called by: handleMunicipalitySelectionChange(), handleProvinceSelectionChange(),
         *           handleRegionSelectionChange(), updateMunicipalityDropdown()
         * Connected to: renderBarangayOptions(), getSelectedRegions(), getSelectedProvinces(),
         *              getSelectedMunicipalities()
         * ============================================================================
         */
        function updateBarangayDropdown() {
            console.log('=== BARANGAY DROPDOWN UPDATE START ===');
            
            // Get current selections from parent multiselects
            var selectedRegions = getSelectedRegions();
            var selectedProvinces = getSelectedProvinces();
            var selectedMunicipalities = getSelectedMunicipalities();
            var barangays = new Set();
            
            console.log('Current selections - Regions:', selectedRegions.length, selectedRegions);
            console.log('Current selections - Provinces:', selectedProvinces.length, selectedProvinces);
            console.log('Current selections - Municipalities:', selectedMunicipalities.length, selectedMunicipalities);
            
            // Check if we have the necessary data
            if (typeof json_Region2_39 === 'undefined' || !json_Region2_39.features) {
                console.error('BARANGAY DROPDOWN ERROR: json_Region2_39 data not available');
                renderBarangayOptions([]);
                return;
            }
            
            // Only show barangays if at least one municipality is selected
            if (selectedMunicipalities.length > 0) {
                console.log('Municipalities selected, filtering barangays...');
                
                // Convert arrays to Sets for efficient lookup
                var selectedRegionsSet = new Set(selectedRegions);
                var selectedProvincesSet = new Set(selectedProvinces);
                var selectedMunicipalitiesSet = new Set(selectedMunicipalities);
                
                var totalFeatures = json_Region2_39.features.length;
                var matchedCount = 0;
                
                // Iterate through all features to find matching barangays
                json_Region2_39.features.forEach(function(feature) {
                    if (!feature.properties) {
                        return; // Skip features without properties
                    }
                    
                    var props = feature.properties;
                    
                    // Check if this feature matches the selected hierarchy
                    var matchesRegion = selectedRegions.length === 0 || selectedRegionsSet.has(props.Reg_Name);
                    var matchesProvince = selectedProvinces.length === 0 || selectedProvincesSet.has(props.Pro_Name);
                    var matchesMunicipality = selectedMunicipalitiesSet.has(props.Mun_Name);
                    
                    // Only include if all conditions match
                    if (matchesRegion && matchesProvince && matchesMunicipality) {
                        // Get barangay name - try Bgy_Name first, then Brg_Name as fallback
                        var barangayName = props.Bgy_Name || props.Brg_Name;
                        if (barangayName) {
                            barangays.add(barangayName);
                            matchedCount++;
                        }
                    }
                });
                
                console.log('Filtering complete:', {
                    totalFeatures: totalFeatures,
                    matchedFeatures: matchedCount,
                    uniqueBarangays: barangays.size
                });
                
                // Log a sample of found barangay names for debugging
                if (barangays.size > 0) {
                    var sampleBarangays = Array.from(barangays).slice(0, 5);
                    console.log('Sample barangays found (first 5):', sampleBarangays);
            } else {
                    console.warn('WARNING: No barangays found matching the selected municipalities');
                }
            } else {
                console.log('No municipalities selected, clearing barangay dropdown');
            }
            
            // Render barangay multiselect with sorted barangays
            var sortedBarangays = Array.from(barangays).sort();
            console.log('Rendering', sortedBarangays.length, 'barangay options');
            renderBarangayOptions(sortedBarangays);
            
            console.log('=== BARANGAY DROPDOWN UPDATE COMPLETE ===');
            console.log('Final result:', {
                regions: selectedRegions.length,
                provinces: selectedProvinces.length,
                municipalities: selectedMunicipalities.length,
                barangays: sortedBarangays.length
            });
        }
        
        /**
         * Clears lower-level multiselect dropdowns (province, municipality, barangay) when a higher-level selection is cleared.
         * Used to maintain hierarchical consistency in the multiselect selections.
         * Also resets household selection and updates flood extent availability.
         * Called by: handleRegionSelectionChange()
         * Connected to: clearProvinceSelections(), clearMunicipalitySelections(), clearBarangaySelections(),
         *              resetHouseholdSelection(), updateFloodExtentAvailability(), filterHouseholdsBySelectedBarangay()
         */
        function clearLowerDropdowns() {
            clearProvinceSelections({ reason: 'parent-cleared' });
            clearMunicipalitySelections({ reason: 'parent-cleared' });
            clearBarangaySelections({ reason: 'parent-cleared' });
            resetHouseholdSelection();
            updateFloodExtentAvailability();
            filterHouseholdsBySelectedBarangay();
        }
        
        /**
         * Clears only the barangay multiselect dropdown.
         * Also resets household selection and updates flood extent availability.
         * Called when municipality selection changes or is cleared.
         * Connected to: clearBarangaySelections(), resetHouseholdSelection(),
         *              updateFloodExtentAvailability(), filterHouseholdsBySelectedBarangay()
         */
        function clearBarangayDropdown() {
            clearBarangaySelections({ reason: 'parent-cleared' });
            resetHouseholdSelection();
            updateFloodExtentAvailability();
            filterHouseholdsBySelectedBarangay();
        }
        
        /**
         * Zooms the map to the area defined by selected regions, provinces, municipalities, and barangays.
         * Calculates the bounding box of all selected geographic features and fits the map view to it.
         * If no selections are made, returns without zooming.
         * Called when selections change and zoom is not skipped.
         * Connected to: getSelectedRegions(), getSelectedProvinces(), getSelectedMunicipalities(),
         *              getSelectedBarangays(), highlightSelectedPolygon()
         */
        function zoomToArea() {
            var regions = getSelectedRegions();
            var provinces = getSelectedProvinces();
            var municipalities = getSelectedMunicipalities();
            var barangays = getSelectedBarangays();
            var barangaySet = new Set(barangays.map(function(name) {
                return (name || '').toString().trim().toLowerCase();
            }));
            var regionSet = new Set(regions);
            var provinceSet = new Set(provinces);
            var municipalitySet = new Set(municipalities);
            
            if (regionSet.size === 0 && provinceSet.size === 0 && municipalitySet.size === 0 && barangaySet.size === 0) {
                return;
            }
            
            if (typeof map !== 'undefined' && typeof json_Region2_39 !== 'undefined' && json_Region2_39.features) {
                var format = new ol.format.GeoJSON();
                var features = format.readFeatures(json_Region2_39, {
                    featureProjection: map.getView().getProjection()
                });
                
                var matchingFeatures = features.filter(function(feature) {
                    var props = feature.getProperties();
                    var matches = true;
                    
                    // Match regions (if any selected)
                    if (regionSet.size > 0) {
                        if (!regionSet.has(props.Reg_Name)) {
                            matches = false;
                        }
                    }
                    
                    // Match provinces (if any selected)
                    if (provinceSet.size > 0) {
                        if (!provinceSet.has(props.Pro_Name)) {
                            matches = false;
                        }
                    }
                    
                    // Match municipalities (if any selected)
                    if (municipalitySet.size > 0) {
                        if (!municipalitySet.has(props.Mun_Name)) {
                            matches = false;
                        }
                    }
                    
                    // Match barangays (if any selected)
                    if (barangaySet.size > 0) {
                        var bgyName = (props.Brg_Name || props.Bgy_Name || '').toString().trim().toLowerCase();
                        if (!barangaySet.has(bgyName)) {
                            matches = false;
                        }
                    }
                    
                    return matches;
                });
                
                if (matchingFeatures.length > 0) {
                    var extent = matchingFeatures[0].getGeometry().getExtent();
                    for (var i = 1; i < matchingFeatures.length; i++) {
                        extent = ol.extent.extend(extent, matchingFeatures[i].getGeometry().getExtent());
                    }
                    
                    map.getView().fit(extent, {
                        duration: 1000,
                        maxZoom: 17
                    });
                    
                    console.log('Zoomed to', matchingFeatures.length, 'matching features');
                }
            }
        }
        
        /**
         * Highlights the selected polygon(s) on the map based on multiselect dropdown selections.
         * Matches features from Region2_39 data based on selected regions, provinces, municipalities, and barangays.
         * Adds matching features to the highlight layer for visual feedback.
         * Called when dropdown selections change.
         * Connected to: highlightLayer, handleRegionSelectionChange(), handleProvinceSelectionChange(),
         *              handleMunicipalitySelectionChange(), handleBarangaySelectionChange(),
         *              getSelectedRegions(), getSelectedProvinces(), getSelectedMunicipalities(),
         *              getSelectedBarangays(), addHoverListeners()
         */
        function highlightSelectedPolygon() {
            var regions = getSelectedRegions();
            var provinces = getSelectedProvinces();
            var municipalities = getSelectedMunicipalities();
            var barangays = getSelectedBarangays();
            var regionSet = new Set(regions);
            var provinceSet = new Set(provinces);
            var municipalitySet = new Set(municipalities);
            var barangaySet = new Set(barangays.map(function(name) {
                return (name || '').toString().trim().toLowerCase();
            }));
            
            if (regionSet.size === 0 && provinceSet.size === 0 && municipalitySet.size === 0 && barangaySet.size === 0) {
                return;
            }
            
            if (typeof json_Region2_39 !== 'undefined' && json_Region2_39.features) {
                var format = new ol.format.GeoJSON();
                var features = format.readFeatures(json_Region2_39, {
                    featureProjection: map.getView().getProjection()
                });
                
                var matchingFeatures = features.filter(function(feature) {
                    var props = feature.getProperties();
                    var matches = true;
                    
                    // Match regions (if any selected)
                    if (regionSet.size > 0) {
                        if (!regionSet.has(props.Reg_Name)) {
                            matches = false;
                        }
                    }
                    
                    // Match provinces (if any selected)
                    if (provinceSet.size > 0) {
                        if (!provinceSet.has(props.Pro_Name)) {
                            matches = false;
                        }
                    }
                    
                    // Match municipalities (if any selected)
                    if (municipalitySet.size > 0) {
                        if (!municipalitySet.has(props.Mun_Name)) {
                            matches = false;
                        }
                    }
                    
                    // Match barangays (if any selected)
                    if (barangaySet.size > 0) {
                        var bgyName = (props.Brg_Name || props.Bgy_Name || '').toString().trim().toLowerCase();
                        if (!barangaySet.has(bgyName)) {
                            matches = false;
                        }
                    }
                    
                    return matches;
                });
                
                if (matchingFeatures.length > 0) {
                    highlightLayer.getSource().clear();
                    selectedFeatures = matchingFeatures;
                    matchingFeatures.forEach(function(feature) {
                        highlightLayer.getSource().addFeature(feature);
                    });
                    console.log('Highlighted', matchingFeatures.length, 'polygons');
                    addHoverListeners();
                }
            }
        }
        
        /**
         * Adds hover event listeners to highlighted features on the map.
         * Sets up pointer move event to handle popup display on hover (currently disabled).
         * Called after highlighting polygons.
         * Connected to: handlePointerMove(), highlightSelectedPolygon(), popupOverlay
         */
        function addHoverListeners() {
            // Remove existing listeners
            map.un('pointermove', handlePointerMove);
            
            // Add new pointer move listener
            map.on('pointermove', handlePointerMove);
        }
        
        /**
         * Handles pointer move events for popup display (currently popup is disabled).
         * Checks if pointer is over highlighted features and would show popup if enabled.
         * Called on mouse move over the map.
         * Connected to: addHoverListeners(), popupOverlay, highlightLayer
         */
        function handlePointerMove(evt) {
            if (selectedFeatures.length === 0) {
                popupOverlay.setPosition(undefined);
                return;
            }
            
            var pixel = evt.pixel;
            var coordinate = evt.coordinate;
            
            // Check if pointer is over any selected feature
            var feature = map.forEachFeatureAtPixel(pixel, function(feature, layer) {
                if (layer === highlightLayer) {
                    return feature;
                }
                return null;
            });
            
            // Popup disabled - always hide it
                popupOverlay.setPosition(undefined);
        }
        
        /**
         * Clears all highlights from the map.
         * Removes features from highlight layer and clears selected features array.
         * Also removes hover listeners and hides popup.
         * Called when clearing selections or clicking on the map.
         * Connected to: highlightLayer, selectedFeatures, setupMapClickHandler(),
         *              setupDropdownEventListeners(), handleBarangaySelectionChange()
         */
        function clearHighlight() {
            if (highlightLayer) {
                highlightLayer.getSource().clear();
            }
            selectedFeatures = [];
            // Remove hover listeners
            map.un('pointermove', handlePointerMove);
            popupOverlay.setPosition(undefined);
        }
        
        /**
         * Sets up the map click handler for feature interaction.
         * Handles clicks on People layer features (shows household modal),
         * household layer features (shows household modal), and map background (clears selections).
         * Called during map initialization.
         * Connected to: showHouseholdModal(), applyHouseholdSelection(), clearBarangaySelections(),
         *              clearHighlight(), resetHouseholdSelection(), peopleLayer, highlightLayer
         */
        function setupMapClickHandler() {
            if (typeof map !== 'undefined') {
                map.on('click', function(evt) {
                    if (!map) return;
                    var hit = map.forEachFeatureAtPixel(evt.pixel, function(feature, layer) {
                        return { feature: feature, layer: layer };
                    });

                    if (hit && hit.feature) {
                        if (peopleLayer && hit.layer === peopleLayer) {
                            var props = hit.feature.get ? hit.feature.getProperties() : hit.feature.properties;
                            var familyCode = '';
                            if (props) {
                                familyCode = props['FAMILY-ID'] || props['fid'] || '';
                            }
                            if (familyCode) {
                                var geoFeature = featureToGeoJson(hit.feature);
                                var members = findHouseholdDataByFamilyId(familyCode) || [];
                                console.log('Household details for FAMILY-ID', String(familyCode) + ':', members);
                                showHouseholdModal(familyCode, geoFeature);
                                if (geoFeature) {
                                    zoomToFeature(geoFeature);
                                    highlightPopulationPolygon(geoFeature);
                                }
                            } else {
                                console.warn('People feature clicked without FAMILY-ID information.');
                            }
                            return;
                        }

                        if (selectedBarangayHighlightLayer && hit.layer === selectedBarangayHighlightLayer) {
                            console.log('Clicked highlighted barangay - keeping multi-selection pinned.');
                            return;
                        }

                        var familyId = getFamilyIdFromFeature(hit.feature);
                        if (familyId) {
                            var geoFeature = featureToGeoJson(hit.feature);
                            applyHouseholdSelection(familyId, geoFeature);
                            showHouseholdModal(familyId, geoFeature);
                            return;
                        }
                    }

                    console.log('Map background clicked - preserving barangay selections');
                    resetHouseholdSelection();
                    
                    // Also clear any active button states
                    var allNavBtns = document.querySelectorAll('.nav-btn');
                    allNavBtns.forEach(function(btn) {
                        btn.classList.remove('active');
                    });
                });
                console.log('Map click handler setup complete');
            }
        }
        
              

        
        /**
         * Finds the flood extent layer for a specific meter value (e.g., 24, 25, 27).
         * Searches through window globals and map layers to locate the layer by URL or title.
         * Uses cached global references when available (e.g., window.lyr_24).
         * Called by: showFloodData(), addMeterPNGLayer(), setFloodExtent24InitialVisibility()
         * Connected to: addMeterPNGLayer(), showFloodData()
         */
        function findFloodExtentLayer(meter) {
            try {
                var globalKey = 'lyr_' + meter;
                if (typeof window[globalKey] !== 'undefined' && window[globalKey]) return window[globalKey];
                
                var needles = [
                    meter + '_2.png',
                    meter + '_3.png',
                    meter + '_4.png',
                    meter + '_5.png',
                    meter + '_6.png',
                    meter + '_7.png',
                    meter + '_8.png',
                    meter + '_10.png',
                    meter + '_2',
                    meter + '_3',
                    meter + '_4',
                    meter + '_5',
                    meter + '_6',
                    meter + '_7',
                    meter + '_8',
                    meter + '_10'
                ];
                
                // search window globals
                for (var key in window) {
                    if (!window.hasOwnProperty(key)) continue;
                    var obj = window[key];
                    if (!obj || typeof obj !== 'object') continue;
                    if (typeof obj.setVisible !== 'function') continue;
                    try {
                        var src = null;
                        if (obj.getSource && typeof obj.getSource === 'function') {
                            var s = obj.getSource();
                            if (s) {
                                if (typeof s.getUrl === 'function') src = s.getUrl();
                                else if (s.getUrls) src = (s.getUrls()[0] || '');
                            }
                        }
                        var name = (key + '').toLowerCase();
                        var url = (src && (src + '') || '').toLowerCase();
                        for (var i = 0; i < needles.length; i++) {
                            if (url.indexOf(needles[i]) !== -1 || name.indexOf(needles[i]) !== -1) {
                                return obj;
                            }
                        }
                    } catch (e) { /* ignore */ }
                }
                
                // search map layers
                if (typeof map !== 'undefined' && map.getLayers) {
                    var layers = map.getLayers().getArray();
                    for (var i = 0; i < layers.length; i++) {
                        var layer = layers[i];
                        try {
                            var title = (layer.get('title') || layer.get('name') || '').toString().toLowerCase();
                            for (var j = 0; j < needles.length; j++) {
                                if (title.indexOf(needles[j]) !== -1) return layer;
                            }
                            var src = layer.getSource && layer.getSource();
                            var url = (src && ((typeof src.getUrl === 'function' && src.getUrl()) || (src.getUrls && src.getUrls()[0])) || '').toString().toLowerCase();
                            for (var k = 0; k < needles.length; k++) {
                                if (url.indexOf(needles[k]) !== -1) return layer;
                            }
                        } catch (e) { /* ignore */ }
                    }
                }
            } catch (e) { console.warn('findFloodExtentLayer(' + meter + ') error', e); }
            return null;
        }

        /**
         * Adds a PNG image layer for a specific flood extent meter value.
         * Tries multiple candidate PNG files (e.g., 24_8.png, 24_7.png) and uses the first that loads successfully.
         * Creates an OpenLayers ImageStatic layer and adds it to the map.
         * Called when flood extent layer doesn't exist and needs to be created.
         * Connected to: showFloodData(), findFloodExtentLayer()
         */
        function addMeterPNGLayer(meter) {
            if (typeof map === 'undefined') return;
            var key = 'lyr_' + meter;
            
            // reuse if already created
            if (window[key]) {
                try {
                    var existing = window[key];
                    if (map.getLayers().getArray().indexOf(existing) === -1) map.addLayer(existing);
                    existing.setVisible(true);
                    if (typeof existing.setOpacity === 'function') existing.setOpacity(0.8);
                    try { existing.setZIndex(2000); } catch (e) {}
                    map.render();
                    console.log('Reused existing ' + meter + ' PNG layer and made visible');
                    return;
                } catch (e) { console.warn('Error re-showing existing layer', e); }
            }
            
            // helper to add image given a working url
            function createAndAddImage(url) {
                try {
                    var imageExtent = [13540235.716279, 1947216.452722, 13566724.528428, 1971690.071692];
                    var src = new ol.source.ImageStatic({
                        url: url,
                        imageExtent: imageExtent,
                        projection: 'EPSG:3857',
                        alwaysInRange: true
                    });
                    var imageLayer = new ol.layer.Image({
                        source: src,
                        opacity: 0.8,
                        visible: true
                    });
                    imageLayer.set('title', meter + '_flood_image');
                    window[key] = imageLayer;
                    map.addLayer(imageLayer);
                    try { imageLayer.setZIndex(2000); } catch (e) {}
                    map.render();
                    console.log('Successfully added ' + meter + ' PNG layer from', url);
                } catch (err) {
                    console.error('Error creating image layer for', url, err);
                }
            }
            
            // Attempt candidates with preload to detect missing/corrupt files early
            function tryCandidates(candidates, onComplete) {
                var idx = 0;
                function attempt() {
                    if (idx >= candidates.length) {
                        console.error('All attempts to load ' + meter + ' PNG failed.');
                        if (typeof onComplete === 'function') onComplete(false);
                        return;
                    }
                    var url = candidates[idx];
                    var testImg = new Image();
                    testImg.onload = function() {
                        createAndAddImage(url);
                        if (typeof onComplete === 'function') onComplete(true);
                    };
                    testImg.onerror = function() {
                        console.warn('Preload failed for', url);
                        idx++;
                        attempt();
                    };
                    testImg.src = url + '?_ts=' + Date.now();
                }
                attempt();
            }
            
            // special-case 24 -> 24_8.png
            if (String(meter) === '24') {
                tryCandidates([
                    './layers/24_8.png',
                    './24_8.png',
                    './layers/24_10.png',
                    './24_10.png',
                    './layers/24_7.png',
                    './24_7.png'
                ]);
                return;
            }
            
            // special-case 25 -> 25_7.png
            if (String(meter) === '25') {
                tryCandidates([
                    './layers/25_7.png',
                    './25_7.png',
                    './layers/25_8.png',
                    './25_8.png',
                    './layers/25_6.png',
                    './25_6.png'
                ]);
                return;
            }
            
            // special-case 26 -> 26_6.png
            if (String(meter) === '26') {
                tryCandidates([
                    './layers/26_6.png',
                    './26_6.png',
                    './layers/26_7.png',
                    './26_7.png',
                    './layers/26_5.png',
                    './26_5.png'
                ]);
                return;
            }
            
            // special-case 27 -> 27_5.png
            if (String(meter) === '27') {
                tryCandidates([
                    './layers/27_5.png',
                    './27_5.png',
                    './layers/27_6.png',
                    './27_6.png',
                    './layers/27_4.png',
                    './27_4.png'
                ]);
                return;
            }
            
            // special-case 28 -> 28_4.png
            if (String(meter) === '28') {
                tryCandidates([
                    './layers/28_4.png',
                    './28_4.png',
                    './layers/28_5.png',
                    './28_5.png',
                    './layers/28_3.png',
                    './28_3.png'
                ]);
                return;
            }
            
            // special-case 29 -> 29_3.png
            if (String(meter) === '29') {
                tryCandidates([
                    './layers/29_3.png',
                    './29_3.png',
                    './layers/29_4.png',
                    './29_4.png',
                    './layers/29_2.png',
                    './29_2.png'
                ]);
                return;
            }
            
            // special-case 30 -> 30_2.png
            if (String(meter) === '30') {
                tryCandidates([
                    './layers/30_2.png',
                    './30_2.png',
                    './layers/30_3.png',
                    './30_3.png',
                    './layers/30_1.png',
                    './30_1.png'
                ]);
                return;
            }
            
            // fallback generic attempt for other meters
            try {
                var urlCandidates = [
                    './layers/' + meter + '_2.png',
                    './layers/' + meter + '_3.png',
                    './layers/' + meter + '_4.png',
                    './layers/' + meter + '_5.png',
                    './layers/' + meter + '_6.png',
                    './layers/' + meter + '_7.png',
                    './layers/' + meter + '_8.png',
                    './layers/' + meter + '_10.png',
                    './' + meter + '_2.png',
                    './' + meter + '_3.png',
                    './' + meter + '_4.png',
                    './' + meter + '_5.png',
                    './' + meter + '_6.png',
                    './' + meter + '_7.png',
                    './' + meter + '_8.png',
                    './' + meter + '_10.png'
                ];
                tryCandidates(urlCandidates);
            } catch (err) {
                console.error('Error creating/showing ' + meter + ' PNG layer:', err);
            }
        }

        /**
         * Shows flood data layer for a specific flood extent (in meters).
         * Hides all flood groups, then either shows existing layer or creates new PNG layer.
         * Sets layer opacity to 0.8 and ensures basemap remains visible.
         * Called when flood extent dropdown selection changes.
         * Connected to: hideAllFloodGroups(), findFloodExtentLayer(), addMeterPNGLayer(),
         *              ensureBasemapVisible(), setupFloodExtentListeners()
         */
        function showFloodData(extent) {
            extent = String(extent);
            
            if (typeof hideAllFloodGroups !== 'function' ||
                typeof ensureBasemapVisible !== 'function') {
                console.warn('Required helper functions are missing');
                return false;
            }

            // Hide all flood groups first
            hideAllFloodGroups();
            
            // Try to find existing layer for this extent
            var layer = findFloodExtentLayer(extent);
            
            if (layer) {
                // Layer exists, just make it visible
                try {
                    layer.setVisible(true);
                    layer.setZIndex(2000);
                    if (typeof layer.setOpacity === 'function') layer.setOpacity(0.8);
                    ensureBasemapVisible();
                    map.render();
                    console.log('Showed existing flood layer for', extent, 'meters');
                    return true;
                } catch (err) {
                    console.error('Error showing flood layer:', err);
                }
            } else {
                // Layer doesn't exist, create it
                try {
                    addMeterPNGLayer(extent);
                    setTimeout(function() {
                        var l = findFloodExtentLayer(extent);
                        if (l) {
                            try { 
                                l.setVisible(true); 
                                l.setZIndex(2000);
                                if (typeof l.setOpacity === 'function') l.setOpacity(0.8);
                                ensureBasemapVisible();
                                map.render();
                            } catch (e) {}
                        }
                    }, 200);
                    return true;
                } catch (err) {
                    console.error('Error creating flood layer for', extent, 'meters:', err);
                    return false;
                }
            }

            return false;
        }



    
        
        /**
         * Ensures basemap and region layers remain visible and properly ordered.
         * Places basemap at z-index 0 (bottom), region layer at z-index 5, and flood layers at z-index 2000.
         * Called after showing flood layers or during map initialization.
         * Connected to: showFloodData(), map initialization, layer visibility changes
         */
        /**
         * ============================================================================
         * ENSURE BASEMAP AND REGION LAYERS VISIBLE FUNCTION
         * ============================================================================
         * 
         * This function ensures the base map (Positron) and Region2_39 layer are visible
         * and properly ordered in the layer stack. The base map should be at the bottom
         * (zIndex 0) and the region layer should be just above it (zIndex 5).
         * 
         * HOW IT WORKS:
         * 1. Detects the base map layer by checking for tile/XYZ sources
         * 2. Detects the Region2_39 layer by checking layer titles
         * 3. Sets both layers to visible
         * 4. Sets appropriate z-index values
         * 5. Reorders layers in the collection (basemap at index 0, region at index 1)
         * 
         * Called during map initialization and when layers need to be reordered.
         * Connected to: map initialization, layer management
         * ============================================================================
         */
        function ensureBasemapVisible() {
            console.log('=== ENSURE BASEMAP VISIBLE START ===');
            if (typeof map === 'undefined' || !map.getLayers) {
                console.warn('Map not available in ensureBasemapVisible');
                return;
            }
            try {
                var layersColl = map.getLayers();
                var layers = layersColl.getArray().slice(); // copy to avoid mutation issues
                console.log('Total layers found:', layers.length);
                var basemapLayer = null;
                var regionLyr = null;

                // 1) detect basemap (tile) and region layer
                for (var i = 0; i < layers.length; i++) {
                    var lyr = layers[i];
                    try {
                        var src = lyr.getSource && lyr.getSource();
                        var srcName = (src && (src.constructor && src.constructor.name || '') || '').toString().toLowerCase();
                        var title = (lyr.get('title') || lyr.get('name') || '').toString().toLowerCase();
                        
                        console.log('Checking layer', i, ':', title, 'Source type:', srcName);

                        // tile-based basemap detection
                        if (!basemapLayer && (srcName.indexOf('tile') !== -1 || srcName.indexOf('xyz') !== -1 || typeof src.getTileGrid === 'function' || typeof src.getTileLoadFunction === 'function')) {
                            basemapLayer = lyr;
                            console.log('Base map layer found:', title);
                        }

                        // region layer detection by title
                        // Check for various forms: "region2", "region 2", "region_2", or HTML title with region2
                        if (!regionLyr && (
                            title.indexOf('region2') !== -1 || 
                            title.indexOf('region 2') !== -1 || 
                            title.indexOf('region_2') !== -1 || 
                            title === 'region2' || 
                            title === 'region 2' ||
                            title === 'region_2' || 
                            (title.indexOf('<img') !== -1 && (title.indexOf('region2') !== -1 || title.indexOf('region 2') !== -1))
                        )) {
                            regionLyr = lyr;
                            console.log('Region layer found:', title);
                        }
                    } catch (e) { 
                        console.warn('Error inspecting layer', i, ':', e);
                    }
                }

                // 2) Ensure basemap visible and put at bottom (zIndex 0)
                if (basemapLayer) {
                    try { 
                        basemapLayer.setVisible(true); 
                        console.log('Base map layer set to visible');
                    } catch (e) {
                        console.error('Error setting basemap visible:', e);
                    }
                    try { 
                        basemapLayer.setZIndex(0); 
                        console.log('Base map layer z-index set to 0');
                    } catch (e) {
                        console.error('Error setting basemap z-index:', e);
                    }
                    // move to bottom of collection
                    try {
                        layersColl.remove(basemapLayer);
                        layersColl.insertAt(0, basemapLayer);
                        console.log('Base map layer moved to bottom of layer stack');
                    } catch (e) {
                        console.error('Error reordering basemap:', e);
                    }
                } else {
                    console.warn('WARNING: Base map layer not found!');
                }

                // 3) Ensure region visible and placed above basemap (zIndex 5)
                if (regionLyr) {
                    try { 
                        regionLyr.setVisible(true); 
                        console.log('Region layer set to visible');
                    } catch (e) {
                        console.error('Error setting region visible:', e);
                    }
                    try { 
                        regionLyr.setZIndex(5); 
                        console.log('Region layer z-index set to 5');
                    } catch (e) {
                        console.error('Error setting region z-index:', e);
                    }
                    // move to just above basemap
                    try {
                        if (basemapLayer) {
                            layersColl.remove(regionLyr);
                            layersColl.insertAt(1, regionLyr);
                            console.log('Region layer moved to position 1 (above basemap)');
                        } else {
                            layersColl.remove(regionLyr);
                            layersColl.insertAt(0, regionLyr);
                            console.log('Region layer moved to position 0 (no basemap found)');
                        }
                    } catch (e) {
                        console.error('Error reordering region layer:', e);
                    }
                    console.log('Region2 ensured visible and ordered above basemap');
                } else {
                    console.warn('WARNING: Region layer not found!');
                }

                // 4) For safety: ensure any known highlight layer stays above region but below flood PNGs
                try { if (highlightLayer) { highlightLayer.setZIndex(900); } } catch (e) {}
                
                // 5) Ensure flood layers have high z-index and reduced opacity
                layers.forEach(function(layer) {
                    var layerTitle = layer.get('title') || layer.get('name') || 'Unknown';
                    var layerTitleLower = layerTitle.toLowerCase();
                    if (layerTitleLower.includes('flood') || 
                        layerTitleLower.includes('24meter') || 
                        layerTitleLower.includes('25meter') ||
                        layerTitleLower.includes('26meter') ||
                        layerTitleLower.includes('27meter') ||
                        layerTitleLower.includes('28meter') ||
                        layerTitleLower.includes('29meter') ||
                        layerTitleLower.includes('30meter') ||
                        layerTitleLower.includes('24_8') ||
                        layerTitleLower.includes('25_7') ||
                        layerTitleLower.includes('26_6') ||
                        layerTitleLower.includes('27_5') ||
                        layerTitleLower.includes('28_4') ||
                        layerTitleLower.includes('29_3') ||
                        layerTitleLower.includes('30_2') ||
                        layerTitleLower.includes('_flood_image')) {
                        try { 
                            layer.setZIndex(2000); 
                            layer.setVisible(true);
                            if (typeof layer.setOpacity === 'function') layer.setOpacity(0.8);
                            console.log('Set flood layer z-index to 2000 and opacity to 0.8:', layerTitle);
                        } catch (e) {}
                    }
                });

                ensureStoTomasLayerOnTop();
                
                try { 
                    map.render(); 
                    console.log('Map render triggered');
                } catch (e) {
                    console.error('Error rendering map:', e);
                }
                console.log('=== ENSURE BASEMAP VISIBLE COMPLETE ===');
            } catch (err) {
                console.error('ensureBasemapVisible error', err);
            }
        }
        
        // ========== Flood Extent 24 meters (24_8.png) raster visibility ===========

        /**
         * Finds the flood extent layer for 24 meters.
         * Wrapper function that calls findFloodExtentLayer('24').
         * Used for 24-meter flood extent layer management.
         * Connected to: findFloodExtentLayer(), setFloodExtent24InitialVisibility()
         */
        function findFloodExtent24Layer() {
            return findFloodExtentLayer('24');
        }

        /**
         * Sets initial visibility state for 24-meter flood extent layer.
         * Polls until layer is found, then ensures it's hidden initially.
         * Sets up event listener to sync dropdown selection with layer visibility.
         * Called during page initialization.
         * Connected to: findFloodExtent24Layer(), addMeterPNGLayer(), floodExtentDropdown
         */
        function setFloodExtent24InitialVisibility() {
            var dropdown = document.getElementById('floodExtentDropdown');
            if (!dropdown) {
                setTimeout(setFloodExtent24InitialVisibility, 150);
                return;
            }
            
            // Try to find layer now; if not found, poll until it appears
            function ensureLayerHidden() {
                var layer = findFloodExtent24Layer();
                if (!layer) {
                    setTimeout(ensureLayerHidden, 150);
                    return;
                }
                try {
                    // store a consistent global reference if possible
                    window.lyr_24 = window.lyr_24 || layer;
                    window.lyr_24_8 = window.lyr_24_8 || layer;
                    layer.setVisible(false);
                } catch (e) { /* ignore */ }
            }
            ensureLayerHidden();
            
            // Keep dropdown and layer in sync
            dropdown.addEventListener('change', function() {
                var layer = findFloodExtent24Layer();
                if (!layer) {
                    // if layer not yet created and 24 selected, create it
                    if (this.value === '24' && typeof addMeterPNGLayer === 'function') {
                        addMeterPNGLayer('24');
                        // after creation ensure it's visible
                        setTimeout(function() {
                            var l = findFloodExtent24Layer();
                            if (l) try { l.setVisible(true); } catch (e) {}
                        }, 200);
                    }
                    return;
                }
                if (this.value === '24') {
                    try { layer.setVisible(true); } catch (e) {}
                } else {
                    try { layer.setVisible(false); } catch (e) {}
                }
            });
        }
        setFloodExtent24InitialVisibility();

        // ========== Flood Extent 25-30 meters initial visibility ===========
        
        /**
         * Sets initial visibility state for flood extent layers (25-30 meters).
         * Polls until layer is found, then ensures it's hidden initially.
         * Sets up event listener to sync dropdown selection with layer visibility.
         * Called during page initialization for meters 25-30.
         * Connected to: findFloodExtentLayer(), addMeterPNGLayer(), floodExtentDropdown
         */
        function setFloodExtentInitialVisibilityFor(meter) {
            var dropdown = document.getElementById('floodExtentDropdown');
            if (!dropdown) {
                setTimeout(function(){ setFloodExtentInitialVisibilityFor(meter); }, 150);
                return;
            }

            function ensureLayerHidden() {
                var layer = findFloodExtentLayer(meter);
                if (!layer) {
                    setTimeout(ensureLayerHidden, 150);
                    return;
                }
                try {
                    window['lyr_' + meter] = window['lyr_' + meter] || layer;
                    layer.setVisible(false);
                } catch (e) { /* ignore */ }
            }
            ensureLayerHidden();

            // Listen for dropdown changes (multiple listeners ok)
            dropdown.addEventListener('change', function () {
                var layer = findFloodExtentLayer(meter);
                if (!layer) {
                    if (this.value === String(meter)) {
                        addMeterPNGLayer(meter);
                        setTimeout(function () {
                            var l = findFloodExtentLayer(meter);
                            if (l) try { l.setVisible(true); } catch (e) {}
                        }, 200);
                    }
                    return;
                }
                if (this.value === String(meter)) {
                    try { layer.setVisible(true); } catch (e) {}
                } else {
                    try { layer.setVisible(false); } catch (e) {}
                }
            });
        }

        // Initialize handlers for meters 25..30
        [25,26,27,28,29,30].forEach(function(m) {
            setFloodExtentInitialVisibilityFor(m);
        });

        /**
         * Sets up event listeners for the flood extent dropdown.
         * Handles changes to flood extent selection and shows/hides corresponding flood layers.
         * Also manages people table display based on selected flood extent.
         * Called during page initialization.
         * Connected to: showFloodData(), showPeopleTableFor(), hidePeople24Table(),
         *              updateFloodExtentAvailability()
         */
        function setupFloodExtentListeners() {
            var floodExtentDropdown = document.getElementById('floodExtentDropdown');
            if (floodExtentDropdown) {
                console.log('Setting up flood extent listeners');
                floodExtentDropdown.addEventListener('change', function() {
                    var selectedValue = this.value;
                    console.log('Flood extent changed to:', selectedValue);
                    
                    // Show/hide map legend based on selection
                    var mapLegend = document.getElementById('map-legend');
                    if (mapLegend) {
                        mapLegend.style.display = (selectedValue !== '') ? 'block' : 'none';
                    }
                    
                    if (selectedValue === '24') {
                        showFloodData('24');
                        // Load data but don't show table - data still available for other functions
                        setTimeout(function(){ loadPeopleDataForMeter(24); }, 200);
                        // Toggle thematic layers for 24m
                        setTimeout(function(){
                            try {
                                toggleHouseholds(false);
                                toggleNumberOfPeople24(false); // Keep hidden for all flood extents
                            } catch (e) { /* ignore */ }
                        }, 250);
                    } else if (selectedValue === '25') {
                        showFloodData('25');
                        setTimeout(function(){ loadPeopleDataForMeter(25); }, 200);
                        setTimeout(function(){ try { toggleHouseholds(true); toggleNumberOfPeople24(false); } catch (e) {} }, 150);
                    } else if (selectedValue === '26') {
                        showFloodData('26');
                        setTimeout(function(){ loadPeopleDataForMeter(26); }, 200);
                        setTimeout(function(){ try { toggleHouseholds(true); toggleNumberOfPeople24(false); } catch (e) {} }, 150);
                    } else if (selectedValue === '27') {
                        showFloodData('27');
                        setTimeout(function(){ loadPeopleDataForMeter(27); }, 200);
                        setTimeout(function(){ try { toggleHouseholds(true); toggleNumberOfPeople24(false); } catch (e) {} }, 150);
                    } else if (selectedValue === '28') {
                        showFloodData('28');
                        setTimeout(function(){ loadPeopleDataForMeter(28); }, 200);
                        setTimeout(function(){ try { toggleHouseholds(true); toggleNumberOfPeople24(false); } catch (e) {} }, 150);
                    } else if (selectedValue === '29') {
                        showFloodData('29');
                        setTimeout(function(){ loadPeopleDataForMeter(29); }, 200);
                        setTimeout(function(){ try { toggleHouseholds(true); toggleNumberOfPeople24(false); } catch (e) {} }, 150);
                    } else if (selectedValue === '30') {
                        showFloodData('30');
                        setTimeout(function(){ loadPeopleDataForMeter(30); }, 200);
                        setTimeout(function(){ try { toggleHouseholds(true); toggleNumberOfPeople24(false); } catch (e) {} }, 150);
                    } else {
                        // Only hide all flood layers when no value is selected
                        hideAllFloodGroups();
                        ensureBasemapVisible();
                        hidePeople24Table();
                        hideChartsPanel();
                        setTimeout(function(){ try { toggleHouseholds(true); toggleNumberOfPeople24(false); } catch (e) {} }, 150);
                    }
                });
            } else {
                console.log('Flood extent dropdown not found');
            }
        }
        
        /**
         * Hides all flood group layers on the map, except the currently selected one.
         * Iterates through all map layers and sets visibility to false for flood-related layers,
         * but keeps the currently selected flood extent layer visible.
         * Called before showing a specific flood extent to ensure only one is visible at a time.
         * Connected to: showFloodData(), setupFloodExtentListeners()
         */
        function hideAllFloodGroups() {
            if (typeof map !== 'undefined' && map.getLayers) {
                var layers = map.getLayers().getArray();
                console.log('Hiding all flood groups');
                
                // Get the currently selected flood extent
                var floodExtentDropdown = document.getElementById('floodExtentDropdown');
                var selectedExtent = floodExtentDropdown ? floodExtentDropdown.value : '';
                var selectedExtentSlug = selectedExtent ? (selectedExtent + 'meter') : '';
                
                layers.forEach(function(layer) {
                    var layerTitle = layer.get('title') || layer.get('name') || 'Unknown';
                    var layerTitleLower = layerTitle.toLowerCase();
                    var layerTitleCompact = layerTitleLower.replace(/[^a-z0-9]+/g, '');
                    
                    // Check if this layer should be hidden
                    var shouldHide = false;
                    
                    // Hide layers that contain flood-related keywords
                    if (layerTitleLower.includes('flood') || 
                        layerTitleLower.includes('analysis') ||
                        layerTitleLower.includes('aggregation') ||
                        layerTitleLower.includes('hazard') ||
                        layerTitleLower.includes('number of people') ||
                        layerTitleCompact.includes('numberofpeople') ||
                        layerTitleCompact.includes('24meter') ||
                        layerTitleCompact.includes('25meter') ||
                        layerTitleCompact.includes('26meter') ||
                        layerTitleCompact.includes('27meter') ||
                        layerTitleCompact.includes('28meter') ||
                        layerTitleCompact.includes('29meter') ||
                        layerTitleCompact.includes('30meter')) {
                        shouldHide = true;
                    }
                    
                    // Don't hide the currently selected flood extent layer
                    if (shouldHide && selectedExtent) {
                        var keepVisible = false;
                        
                        if (selectedExtent === '24') {
                            keepVisible = layerTitleCompact.includes('24meter') || layerTitleCompact.includes('24meters') || layerTitleLower.includes('24 meter');
                            if (!keepVisible && layerTitleLower.includes('24_8')) {
                                keepVisible = true;
                            }
                            if (!keepVisible && layerTitle.includes('24 Meter Flood Extent')) {
                                keepVisible = true;
                            }
                        } else {
                            keepVisible = layerTitleCompact.includes(selectedExtentSlug);
                        }
                        
                        if (keepVisible) {
                            shouldHide = false;
                            console.log('Keeping selected ' + selectedExtent + 'm flood layer visible:', layerTitle);
                        }
                    }
                    
                    if (shouldHide) {
                        layer.setVisible(false);
                        console.log('Hidden layer:', layerTitle);
                    }
                });
                // Also hide the people table if we're clearing flood groups or not on 24
                if (selectedExtent !== '24') hidePeople24Table();
            }
        }
        
                
        // Setup layer switcher control
        function setupLayerSwitcher() {
            // Layer switcher control is disabled - no layer list button will be shown
            console.log('Layer switcher control disabled - layer list button hidden');
        }
        
        /**
         * Finds a layer by searching for a substring in its name or title.
         * Searches through window globals and map layers to find matching layers.
         * Used as a utility function to locate layers by partial name match.
         * Called by: findHouseholdsLayer(), findNumberOfPeople24Layer(), other layer finder functions
         * Connected to: findHouseholdsLayer(), findNumberOfPeople24Layer()
         */
        function findLayerByNameIncludes(substr) {
            try {
                substr = (substr || '').toLowerCase();
                // Check window-scoped layer variables first
                for (var k in window) {
                    if (!window.hasOwnProperty(k)) continue;
                    var obj = window[k];
                    if (!obj || typeof obj !== 'object') continue;
                    if (typeof obj.setVisible !== 'function') continue;
                    try {
                        var title = ((obj.get && obj.get('title')) || (obj.get && obj.get('name')) || k || '').toString().toLowerCase();
                        if (title.indexOf(substr) !== -1 || (k.toLowerCase().indexOf(substr) !== -1)) return obj;
                    } catch (e) { /* ignore */ }
                }
                // Fallback: search map layers list
                if (typeof map !== 'undefined' && map.getLayers) {
                    var layers = map.getLayers().getArray();
                    for (var i = 0; i < layers.length; i++) {
                        try {
                            var layer = layers[i];
                            var t = (layer.get('title') || layer.get('name') || '').toString().toLowerCase();
                            if (t.indexOf(substr) !== -1) return layer;
                        } catch (e) { /* ignore */ }
                    }
                }
            } catch (e) { /* ignore */ }
            return null;
        }

        /**
         * Finds the Households layer on the map by searching for 'households' or 'household' in layer name.
         * Uses findLayerByNameIncludes() to locate the layer.
         * Called by: toggleHouseholds(), setBaseHouseholdLayersVisible()
         * Connected to: findLayerByNameIncludes(), toggleHouseholds()
         */
        function findHouseholdsLayer() {
            // Match common variants
            var cand = findLayerByNameIncludes('households');
            if (cand) return cand;
            return findLayerByNameIncludes('household');
        }

        /**
         * Finds the Number of People at 24 meters layer on the map.
         * Searches for layers containing 'numberofpeopleat24meters' or similar patterns.
         * Used to locate the population exposure layer for 24-meter flood extent.
         * Called by: toggleNumberOfPeople24(), showPeopleTableFor()
         * Connected to: findLayerByNameIncludes(), toggleNumberOfPeople24()
         */
        function findNumberOfPeople24Layer() {
            // Exact export usually: Numberofpeopleat24meters_12
            var cand = findLayerByNameIncludes('numberofpeopleat24meters_12');
            if (cand) return cand;
            // Fallback partials
            cand = findLayerByNameIncludes('numberofpeopleat24');
            if (cand) return cand;
            return findLayerByNameIncludes('numberofpeople');
        }

        /**
         * Finds the Sto.Tomas Households joined layer on the map.
         * Searches for layers containing 'stotomas' or 'sto.tomas' in layer name.
         * Used to locate the StoTomasHouseholdsjoined_layer_1 layer.
         * Called by: toggleLayer() for household type
         * Connected to: findLayerByNameIncludes(), toggleLayer()
         */
        function findStoTomasHouseholdsLayer() {
            // Try direct reference first if available
            if (typeof lyr_StoTomasHouseholdsjoined_layer_1 !== 'undefined' && lyr_StoTomasHouseholdsjoined_layer_1 !== null) {
                console.log('Found StoTomasHouseholdsjoined_layer_1 layer via direct reference');
                return lyr_StoTomasHouseholdsjoined_layer_1;
            }
            // Fallback to search by name in map layers
            if (typeof map !== 'undefined' && map.getLayers) {
                var layers = map.getLayers().getArray();
                for (var i = 0; i < layers.length; i++) {
                    var layer = layers[i];
                    if (layer && typeof layer.get === 'function') {
                        var title = layer.get('title') || '';
                        var name = layer.get('name') || '';
                        var combined = (title + ' ' + name).toLowerCase();
                        if (combined.indexOf('stotomas') >= 0 || 
                            combined.indexOf('sto.tomas') >= 0 || 
                            combined.indexOf('householdsjoined') >= 0 ||
                            combined.indexOf('households  joined') >= 0) {
                            console.log('Found StoTomasHouseholdsjoined_layer_1 layer via name search:', combined);
                            return layer;
                        }
                    }
                }
            }
            // Fallback to search by name using helper function
            var cand = findLayerByNameIncludes('stotomas');
            if (cand) {
                console.log('Found StoTomasHouseholdsjoined_layer_1 layer via findLayerByNameIncludes: stotomas');
                return cand;
            }
            cand = findLayerByNameIncludes('sto.tomas');
            if (cand) {
                console.log('Found StoTomasHouseholdsjoined_layer_1 layer via findLayerByNameIncludes: sto.tomas');
                return cand;
            }
            cand = findLayerByNameIncludes('householdsjoined');
            if (cand) {
                console.log('Found StoTomasHouseholdsjoined_layer_1 layer via findLayerByNameIncludes: householdsjoined');
                return cand;
            }
            console.warn('StoTomasHouseholdsjoined_layer_1 layer not found by any method');
            return null;
        }

        /**
         * Ensures the Sto.Tomas households layer draws above flood extent layers.
         * Sets its z-index to a value higher than flood layers (which use 2000).
         */
        function ensureStoTomasLayerOnTop() {
            try {
                var stoLayer = findStoTomasHouseholdsLayer();
                if (stoLayer && typeof stoLayer.setZIndex === 'function') {
                    stoLayer.setZIndex(2500);
                }
            } catch (e) {
                console.warn('Unable to set StoTomas layer z-index:', e);
            }
        }

        /**
         * Filters the StoTomasHouseholdsjoined_layer_1 layer to show only polygons
         * where the BARANGAY property matches selected barangays from the dropdown.
         * Uses a style-based approach: matching polygons get normal style, non-matching get transparent style.
         * If no barangays are selected, all polygons are transparent.
         * Called by: handleBarangaySelectionChange(), toggleLayer() for household type
         * Connected to: findStoTomasHouseholdsLayer(), getSelectedBarangays(), normalizeBarangayName()
         */
        function filterStoTomasHouseholdsByBarangay() {
            try {
                var stoTomasLayer = findStoTomasHouseholdsLayer();
                if (!stoTomasLayer) {
                    console.log('StoTomasHouseholdsjoined_layer_1 layer not found for filtering');
                    return;
                }

                var selectedBarangays = getSelectedBarangays();
                
                // Update global set of filtered barangays (normalized for comparison)
                stoTomasFilteredBarangays.clear();
                selectedBarangays.forEach(function(barangay) {
                    stoTomasFilteredBarangays.add(normalizeBarangayName(barangay));
                });

                // Create a dynamic style function that checks if feature's BARANGAY matches selected barangays
                var originalStyle = typeof style_StoTomasHouseholdsjoined_layer_1 !== 'undefined' 
                    ? style_StoTomasHouseholdsjoined_layer_1 
                    : function(feature, resolution) {
                        // Fallback style if original is not available
                        return [new ol.style.Style({
                            stroke: new ol.style.Stroke({color: 'rgba(35,35,35,1.0)', lineDash: null, lineCap: 'butt', lineJoin: 'miter', width: 0.988}),
                            fill: new ol.style.Fill({color: 'rgba(255,84,111,1.0)'})
                        })];
                    };
                
                stoTomasLayer.setStyle(function(feature, resolution) {
                    // If no barangays selected, make all transparent
                    if (stoTomasFilteredBarangays.size === 0) {
                        return [new ol.style.Style({
                            stroke: new ol.style.Stroke({color: 'rgba(0,0,0,0)', width: 0}),
                            fill: new ol.style.Fill({color: 'rgba(0,0,0,0)'})
                        })];
                    }

                    // Check if this feature's BARANGAY matches any selected barangay
                    var featBarangay = normalizeBarangayName(feature.get('BARANGAY'));
                    var isMatch = stoTomasFilteredBarangays.has(featBarangay);

                    if (isMatch) {
                        // Matching polygon: use original style
                        return originalStyle(feature, resolution);
                    } else {
                        // Non-matching polygon: make transparent
                        return [new ol.style.Style({
                            stroke: new ol.style.Stroke({color: 'rgba(0,0,0,0)', width: 0}),
                            fill: new ol.style.Fill({color: 'rgba(0,0,0,0)'})
                        })];
                    }
                });

                // Trigger layer redraw to apply new styles
                stoTomasLayer.changed();

                if (selectedBarangays.length === 0) {
                    console.log('StoTomasHouseholdsjoined_layer_1 filter applied - all polygons transparent (no barangays selected)');
                } else {
                    console.log('StoTomasHouseholdsjoined_layer_1 filtered by barangays:', selectedBarangays);
                }
                ensureStoTomasLayerOnTop();
            } catch (e) {
                console.error('Error filtering StoTomasHouseholdsjoined_layer_1 by barangay:', e);
            }
        }
        
        /**
         * Renders the family members table in a draggable modal.
         * Filters DB_0 data by FAMILY-ID and displays results in a modern responsive table.
         * @param {Array} members - Array of household member records from DB_0
         * @param {String} familyId - The FAMILY-ID to display in the header
         */
        function renderFamilyTable(members, familyId) {
            var container = document.getElementById('family-table');
            var modal = document.getElementById('family-table-modal');
            var modalContent = document.getElementById('family-table-modal-content');
            var modalTitle = document.getElementById('family-table-modal-title');
            
            if (!container || !modal || !modalContent) {
                console.warn('Family table modal not found');
                return;
            }
            
            // Update modal title with FAMILY-ID
            if (modalTitle) {
                modalTitle.textContent = 'FAMILY-ID: ' + (familyId || 'N/A');
            }
            
            // Reset transform to center the modal when shown
            familyTableModalDragState.xOffset = 0;
            familyTableModalDragState.yOffset = 0;
            familyTableModalDragState.currentX = 0;
            familyTableModalDragState.currentY = 0;
            familyTableModalDragState.initialX = 0;
            familyTableModalDragState.initialY = 0;
            modalContent.style.transform = 'translate(0px, 0px)';
            
            // Show the modal
            modal.style.display = 'flex';
            
            if (!members || members.length === 0) {
                // Create Bootstrap alert with icon using Bootstrap Icons
                var alertHtml = '<div class="alert alert-danger d-flex align-items-center" role="alert" style="margin: 0;">';
                alertHtml += '<i class="bi bi-exclamation-triangle-fill flex-shrink-0 me-2" style="font-size: 1.5rem;" aria-label="Danger:"></i>';
                alertHtml += '<div>';
                alertHtml += 'Sorry! We donot have data for this household!';
                alertHtml += '</div>';
                alertHtml += '</div>';
                
                container.innerHTML = alertHtml;
                return;
            }
            
            var html = '<table><thead><tr>';
            html += '<th>Relation</th>';
            html += '<th>Given Name</th>';
            html += '<th>Last Name</th>';
            html += '<th>Age</th>';
            html += '<th>Sex</th>';
            html += '<th>Occupation</th>';
            html += '</tr></thead><tbody>';
            
            members.forEach(function(m) {
                var props = m.properties || m;
                html += '<tr>';
                html += '<td>' + (props.RELATION || '-') + '</td>';
                html += '<td>' + (props['GIVEN NAME'] || props.GIVEN_NAME || '-') + '</td>';
                html += '<td>' + (props['LAST NAME'] || props.LAST_NAME || '-') + '</td>';
                html += '<td>' + (props.AGE || '-') + '</td>';
                html += '<td>' + (props.SEX || '-') + '</td>';
                html += '<td>' + (props.OCCUPATION || '-') + '</td>';
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }
        
        /**
         * Hides the family table modal.
         */
        function hideFamilyTableModal() {
            var modal = document.getElementById('family-table-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Global drag state for family table modal
        var familyTableModalDragState = {
            isDragging: false,
            currentX: 0,
            currentY: 0,
            initialX: 0,
            initialY: 0,
            xOffset: 0,
            yOffset: 0
        };
        
        /**
         * Sets up the family table modal with drag functionality and close button.
         */
        function setupFamilyTableModal() {
            var modal = document.getElementById('family-table-modal');
            var modalContent = document.getElementById('family-table-modal-content');
            var modalHeader = document.getElementById('family-table-modal-header');
            var closeBtn = document.getElementById('family-table-modal-close');
            
            if (!modal || !modalContent || !modalHeader) {
                console.warn('Family table modal elements not found');
                return;
            }
            
            // Close button handler
            if (closeBtn) {
                closeBtn.addEventListener('click', hideFamilyTableModal);
            }
            
            // Make modal draggable
            modalHeader.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);
            
            function dragStart(e) {
                familyTableModalDragState.initialX = e.clientX - familyTableModalDragState.xOffset;
                familyTableModalDragState.initialY = e.clientY - familyTableModalDragState.yOffset;
                
                if (e.target === modalHeader || modalHeader.contains(e.target)) {
                    // Don't start dragging if clicking the close button
                    if (e.target === closeBtn || closeBtn.contains(e.target)) {
                        return;
                    }
                    familyTableModalDragState.isDragging = true;
                }
            }
            
            function drag(e) {
                if (familyTableModalDragState.isDragging) {
                    e.preventDefault();
                    familyTableModalDragState.currentX = e.clientX - familyTableModalDragState.initialX;
                    familyTableModalDragState.currentY = e.clientY - familyTableModalDragState.initialY;
                    
                    familyTableModalDragState.xOffset = familyTableModalDragState.currentX;
                    familyTableModalDragState.yOffset = familyTableModalDragState.currentY;
                    
                    modalContent.style.transform = 'translate(' + familyTableModalDragState.currentX + 'px, ' + familyTableModalDragState.currentY + 'px)';
                }
            }
            
            function dragEnd(e) {
                if (familyTableModalDragState.isDragging) {
                    familyTableModalDragState.initialX = familyTableModalDragState.currentX;
                    familyTableModalDragState.initialY = familyTableModalDragState.currentY;
                }
                familyTableModalDragState.isDragging = false;
            }
            
            console.log('Family table modal drag functionality initialized');
        }
        
        /**
         * Handles polygon click events on StoTomasHouseholdsjoined_layer_1 layer.
         * Gets FAMILY-ID from clicked feature and displays matching household members.
         */
        function setupHouseholdPolygonClickHandler() {
            try {
                var stoTomasLayer = findStoTomasHouseholdsLayer();
                if (!stoTomasLayer) {
                    console.warn('StoTomasHouseholdsjoined_layer_1 layer not found for click handler');
                    return;
                }
                
                // Get the map instance
                if (typeof map === 'undefined') {
                    console.warn('Map not available for click handler');
                    return;
                }
                
                // Add click event listener to the map
                // Use 'singleclick' to avoid conflicts with other click handlers
                map.on('singleclick', function(evt) {
                    try {
                        // Check if DB_0 data is available
                        if (typeof json_DB_0 === 'undefined' || !json_DB_0.features) {
                            console.warn('DB_0 data not available');
                            return;
                        }
                        
                        // Only process clicks if the layer is visible
                        if (!stoTomasLayer.getVisible()) {
                            return;
                        }
                        
                        // Get clicked feature from StoTomasHouseholdsjoined_layer_1 layer
                        var feature = null;
                        map.forEachFeatureAtPixel(evt.pixel, function(feat, layer) {
                            // Check if this feature belongs to our target layer
                            if (layer === stoTomasLayer) {
                                feature = feat;
                                return true; // Stop iteration
                            }
                            return false;
                        }, {
                            hitTolerance: 5,
                            layerFilter: function(layer) {
                                return layer === stoTomasLayer;
                            }
                        });
                        
                        if (!feature) {
                            // No feature clicked on this layer
                            return;
                        }
                        
                        // Get FAMILY-ID from clicked feature
                        // Try multiple methods to get FAMILY-ID for robustness
                        var familyId = null;
                        if (feature.get) {
                            familyId = feature.get('FAMILY-ID');
                            if (!familyId && feature.getProperties) {
                                var props = feature.getProperties();
                                familyId = props['FAMILY-ID'] || props['family_id'] || props['FAMILY_ID'];
                            }
                        } else if (feature.properties) {
                            familyId = feature.properties['FAMILY-ID'] || feature.properties['family_id'] || feature.properties['FAMILY_ID'];
                        }
                        
                        if (!familyId) {
                            console.warn('No FAMILY-ID found on clicked feature');
                            renderFamilyTable([], null);
                            return;
                        }
                        
                        // Convert to string for consistent comparison
                        familyId = String(familyId).trim();
                        console.log('StoTomasHouseholdsjoined_layer_1 polygon clicked, FAMILY-ID:', familyId);
                        
                        // Filter DB_0 data by FAMILY-ID
                        var members = [];
                        for (var i = 0; i < json_DB_0.features.length; i++) {
                            var record = json_DB_0.features[i];
                            var props = record.properties || {};
                            var recordFamilyId = props['FAMILY-ID'];
                            
                            // Compare as strings to handle different formats
                            if (recordFamilyId !== undefined && recordFamilyId !== null && 
                                String(recordFamilyId).trim() === familyId) {
                                members.push(record);
                            }
                        }
                        
                        console.log('Found', members.length, 'household members for FAMILY-ID:', familyId);
                        
                        // Render the table in modal with FAMILY-ID
                        renderFamilyTable(members, familyId);
                    } catch (e) {
                        console.error('Error handling polygon click:', e);
                    }
                });
                
                console.log('Household polygon click handler initialized');
            } catch (e) {
                console.error('Error setting up household polygon click handler:', e);
            }
        }

        /**
         * Sets up cursor change to pointer when hovering over StoTomasHouseholdsjoined_layer_1 polygons.
         * Changes cursor to 'pointer' when over a feature, and back to 'default' when not.
         */
        function setupHouseholdPolygonHoverCursor() {
            try {
                var stoTomasLayer = findStoTomasHouseholdsLayer();
                if (!stoTomasLayer) {
                    console.warn('StoTomasHouseholdsjoined_layer_1 layer not found for hover cursor handler');
                    return;
                }
                
                // Get the map instance
                if (typeof map === 'undefined') {
                    console.warn('Map not available for hover cursor handler');
                    return;
                }
                
                // Get the map viewport element to change cursor
                var mapElement = map.getViewport();
                if (!mapElement) {
                    console.warn('Map viewport element not found');
                    return;
                }
                
                // Add pointer move event listener to the map
                map.on('pointermove', function(evt) {
                    try {
                        // Only process if the layer is visible
                        if (!stoTomasLayer.getVisible()) {
                            mapElement.style.cursor = '';
                            return;
                        }
                        
                        // Check if pointer is over a feature from StoTomasHouseholdsjoined_layer_1 layer
                        var feature = null;
                        map.forEachFeatureAtPixel(evt.pixel, function(feat, layer) {
                            // Check if this feature belongs to our target layer
                            if (layer === stoTomasLayer) {
                                feature = feat;
                                return true; // Stop iteration
                            }
                            return false;
                        }, {
                            hitTolerance: 5,
                            layerFilter: function(layer) {
                                return layer === stoTomasLayer;
                            }
                        });
                        
                        // Change cursor based on whether we're over a feature
                        if (feature) {
                            mapElement.style.cursor = 'pointer';
                        } else {
                            mapElement.style.cursor = '';
                        }
                    } catch (e) {
                        console.error('Error handling pointer move for cursor:', e);
                    }
                });
                
                console.log('Household polygon hover cursor handler initialized');
            } catch (e) {
                console.error('Error setting up household polygon hover cursor handler:', e);
            }
        }

        /**
         * Toggles visibility of the Households layer.
         * Finds the households layer and sets its visibility based on the parameter.
         * Called by: setBaseHouseholdLayersVisible(), layer management functions
         * Connected to: findHouseholdsLayer(), setBaseHouseholdLayersVisible()
         */
        function toggleHouseholds(visible) {
            var lyr = findHouseholdsLayer();
            if (lyr && typeof lyr.setVisible === 'function') {
                try { 
                    lyr.setVisible(!!visible); 
                    if (visible) {
                        ensureStoTomasLayerOnTop();
                    }
                } catch (e) {}
            }
        }

        /**
         * Toggles visibility of the Number of People at 24 meters layer.
         * Finds the layer and sets its visibility based on the parameter.
         * Called when showing/hiding population exposure data for 24-meter flood extent.
         * Connected to: findNumberOfPeople24Layer(), showPeopleTableFor()
         */
        function toggleNumberOfPeople24(visible) {
            var lyr = findNumberOfPeople24Layer();
            if (lyr && typeof lyr.setVisible === 'function') {
                try { lyr.setVisible(!!visible); lyr.setZIndex && lyr.setZIndex(1200); } catch (e) {}
            }
        }
        
        /**
         * Gets the GeoJSON data for people layer based on flood extent meter value.
         * Searches window globals for json_Numberofpeople... variables containing the meter number.
         * Returns the first matching GeoJSON object with features property.
         * Used to populate the people table with data for the selected flood extent.
         * Called by: showPeopleTableFor(), applyPeopleFiltersAndRender()
         * Connected to: showPeopleTableFor(), currentPeopleAllFeats
         */
        function getPeopleJsonFor(meter) {
            try {
                var wanted = String(meter);
                var matches = [];
                for (var key in window) {
                    if (!window.hasOwnProperty(key)) continue;
                    var low = key.toLowerCase();
                    // look for json_Numberofpeople... containing the meter number
                    if (low.indexOf('json_numberofpeople') !== -1 && low.indexOf(wanted) !== -1) {
                        matches.push(key);
                    }
                }
                // Prefer exact pattern json_NumberofpeopleatXm...
                matches.sort(function(a,b){ return a.length - b.length; });
                for (var i = 0; i < matches.length; i++) {
                    var obj = window[matches[i]];
                    if (obj && obj.features) return obj;
                }
            } catch (e) { /* ignore */ }
            return null;
        }


        /**
         * Calculates demographic data (infant, child, youth, adult, elderly, male, female, disabled)
         * from household data based on exposure ID (FAMILY-ID).
         * Iterates through json_Households_1 features and aggregates demographic information by age and sex.
         * Used to populate people table and charts with calculated demographics.
         * Called by: applyPeopleFiltersAndRender(), updateCharts()
         * Connected to: json_Households_1, applyPeopleFiltersAndRender(), updateCharts()
         */
        function calculateDemographicsFromHouseholds(exposureId) {
            try {
                if (typeof json_Households_1 === 'undefined' || !json_Households_1.features) {
                    return null;
                }
                
                var demographics = {
                    infant: 0,
                    child: 0,
                    youth: 0,
                    adult: 0,
                    elderly: 0,
                    male: 0,
                    female: 0,
                    disabled: 0
                };
                
                // Convert exposure_id to string for comparison
                var exposureIdStr = String(exposureId || '');
                
                // Find all household members with matching FAMILY-ID
                // First, we need to find the household feature that has this exposure_id as fid
                var householdFeature = null;
                for (var i = 0; i < json_Households_1.features.length; i++) {
                    var feature = json_Households_1.features[i];
                    if (feature && feature.properties) {
                        var householdFid = String(feature.properties['fid'] || '');
                        if (householdFid === exposureIdStr) {
                            householdFeature = feature;
                            break;
                        }
                    }
                }
                
                if (!householdFeature) {
                    return null;
                }
                
                // Get FAMILY-ID from the matched household
                var familyId = householdFeature.properties['FAMILY-ID'];
                if (!familyId) {
                    return null;
                }
                
                // Find all household members with the same FAMILY-ID
                var familyIdStr = String(familyId);
                for (var i = 0; i < json_Households_1.features.length; i++) {
                    var feature = json_Households_1.features[i];
                    if (!feature || !feature.properties) continue;
                    
                    var memberFamilyId = String(feature.properties['FAMILY-ID'] || '');
                    if (memberFamilyId !== familyIdStr) continue;
                    
                    // Get age and sex from household member
                    var age = parseInt(feature.properties['AGE'] || 0);
                    var sex = String(feature.properties['SEX'] || '').toLowerCase();
                    var disabled = String(feature.properties['Disabled'] || feature.properties['DISABLED'] || '').toLowerCase();
                    
                    // Count by age group (mutually exclusive ranges)
                    // Infant: 0-4 years
                    if (age >= 0 && age <= 4) {
                        demographics.infant++;
                    }
                    // Child: 5-14 years
                    else if (age >= 5 && age <= 14) {
                        demographics.child++;
                    }
                    // Youth: 15-24 years
                    else if (age >= 15 && age <= 24) {
                        demographics.youth++;
                    }
                    // Adult: 25-64 years
                    else if (age >= 25 && age <= 64) {
                        demographics.adult++;
                    }
                    // Elderly: 65+ years
                    else if (age >= 65) {
                        demographics.elderly++;
                    }
                    
                    // Count by sex
                    if (sex === 'male' || sex === 'm') {
                        demographics.male++;
                    } else if (sex === 'female' || sex === 'f') {
                        demographics.female++;
                    }
                    
                    // Count disabled
                    if (disabled === 'yes' || disabled === 'true' || disabled === '1') {
                        demographics.disabled++;
                    }
                }
                
                return demographics;
            } catch (e) {
                console.error('Error calculating demographics from households:', e);
                return null;
            }
        }
        
        /**
         * Counts households by barangay for a given municipality.
         * Extracts unique barangay names and counts households in each from json_Households_1.
         * Matches barangays with Region2_39 data to ensure consistency.
         * Used to populate barangay population popup with household counts.
         * Called by: showBarangayPopulationPopup()
         * Connected to: json_Households_1, json_Region2_39, showBarangayPopulationPopup()
         */
        function countHouseholdsByBarangay(municipalityName) {
            try {
                // Check if both data sources are available
                if (typeof json_Region2_39 === 'undefined' || !json_Region2_39.features) {
                    console.error('Region2_39 data not available');
                    return null;
                }
                
                if (typeof json_Households_1 === 'undefined' || !json_Households_1.features) {
                    console.error('Households_1 data not available');
                    return null;
                }
                
                // Get all unique Bgy_Name values from Region2_39, optionally filtered by municipality
                var regionBarangays = new Set();
                var municipalityBarangays = new Set(); // Barangays in the selected municipality
                
                json_Region2_39.features.forEach(function(feature) {
                    if (feature.properties && feature.properties.Bgy_Name) {
                        var bgyName = String(feature.properties.Bgy_Name).trim();
                        var munName = feature.properties.Mun_Name ? String(feature.properties.Mun_Name).trim() : '';
                        
                        if (bgyName) {
                            // If municipality filter is provided, only include barangays from that municipality
                            if (municipalityName) {
                                if (munName === municipalityName) {
                                    regionBarangays.add(bgyName);
                                    municipalityBarangays.add(bgyName);
                                }
                            } else {
                                regionBarangays.add(bgyName);
                            }
                        }
                    }
                });
                
                // Count households by barangay
                var counts = {};
                var totalCount = 0;
                
                // Initialize counts for all region barangays (filtered by municipality if provided)
                regionBarangays.forEach(function(bgyName) {
                    counts[bgyName] = 0;
                });
                
                // Count households that match
                json_Households_1.features.forEach(function(feature) {
                    if (feature.properties && feature.properties.BARANGAY) {
                        var householdBarangay = String(feature.properties.BARANGAY).trim();
                        
                        // Check if this barangay exists in Region2_39 (and matches municipality filter if provided)
                        if (regionBarangays.has(householdBarangay)) {
                            counts[householdBarangay] = (counts[householdBarangay] || 0) + 1;
                            totalCount++;
                        }
                    }
                });
                
                // Return summary object
                var result = {
                    total: totalCount,
                    byBarangay: counts,
                    matchedBarangays: Object.keys(counts).filter(function(bgy) { return counts[bgy] > 0; }),
                    unmatchedCount: json_Households_1.features.length - totalCount,
                    municipality: municipalityName || null
                };
                
                console.log('Household count by barangay:', result);
                return result;
            } catch (e) {
                console.error('Error counting households by barangay:', e);
                return null;
            }
        }
        
        // Show barangay population popup
        /**
         * Shows a popup modal displaying barangay population data for a municipality.
         * Calculates demographics and household counts for each barangay and displays in a table.
         * Shows loading spinner while data is being calculated.
         * Called when clicking on municipality in the map or dropdown.
         * Connected to: countHouseholdsByBarangay(), calculateDemographicsFromHouseholds(),
         *              hideBarangayPopulationPopup()
         */
        function showBarangayPopulationPopup(municipalityName) {
            try {
                var modal = document.getElementById('barangay-population-modal');
                var title = document.getElementById('barangay-population-title');
                var content = document.getElementById('barangay-population-content');
                
                if (!modal || !title || !content) {
                    console.error('Barangay population modal elements not found');
                    return;
                }
                
                // Set title
                title.textContent = 'Population by Barangay - ' + municipalityName;
                
                // Show loading state
                content.innerHTML = '<div style="text-align: center; padding: 40px;"><div class="spinner" style="margin: 0 auto;"></div><p style="margin-top: 20px; color: #ccc;">Loading population data...</p></div>';
                modal.style.display = 'flex';
                
                // Get population counts
                var result = countHouseholdsByBarangay(municipalityName);
                
                if (!result || !result.byBarangay) {
                    content.innerHTML = '<div style="text-align: center; padding: 40px; color: #ccc;">No data available for this municipality.</div>';
                    return;
                }
                
                // Build content HTML
                var html = '<div style="padding: 20px;">';
                html += '<div style="margin-bottom: 20px; padding: 15px; background: rgba(74, 144, 226, 0.1); border-radius: 8px; border-left: 4px solid #4a90e2;">';
                html += '<div style="color: #4a90e2; font-weight: 600; font-size: 1.1rem; margin-bottom: 5px;">Total Population</div>';
                html += '<div style="color: #fafafa; font-size: 1.5rem; font-weight: 700;">' + result.total.toLocaleString() + '</div>';
                html += '</div>';
                
                html += '<div style="max-height: 400px; overflow-y: auto;">';
                html += '<table style="width: 100%; border-collapse: collapse;">';
                html += '<thead>';
                html += '<tr style="background: rgba(74, 144, 226, 0.15); border-bottom: 2px solid #4a90e2;">';
                html += '<th style="padding: 12px; text-align: left; color: #4a90e2; font-weight: 600;">Barangay Name</th>';
                html += '<th style="padding: 12px; text-align: right; color: #4a90e2; font-weight: 600;">Number of Population</th>';
                html += '</tr>';
                html += '</thead>';
                html += '<tbody>';
                
                // Sort barangays by name
                var sortedBarangays = Object.keys(result.byBarangay).sort();
                
                if (sortedBarangays.length === 0) {
                    html += '<tr><td colspan="2" style="padding: 20px; text-align: center; color: #999;">No barangays found in this municipality.</td></tr>';
                } else {
                    sortedBarangays.forEach(function(bgyName) {
                        var count = result.byBarangay[bgyName];
                        html += '<tr style="border-bottom: 1px solid rgba(255, 255, 255, 0.1);">';
                        html += '<td style="padding: 12px; color: #fafafa;">' + bgyName + '</td>';
                        html += '<td style="padding: 12px; text-align: right; color: #fafafa; font-weight: 500;">' + count.toLocaleString() + '</td>';
                        html += '</tr>';
                    });
                }
                
                html += '</tbody>';
                html += '</table>';
                html += '</div>';
                html += '</div>';
                
                content.innerHTML = html;
            } catch (e) {
                console.error('Error showing barangay population popup:', e);
                var content = document.getElementById('barangay-population-content');
                if (content) {
                    content.innerHTML = '<div style="text-align: center; padding: 40px; color: #f44336;">Error loading population data.</div>';
                }
            }
        }
        
        // Hide barangay population popup
        /**
         * Hides the barangay population popup modal.
         * Sets the modal display to 'none' to hide it from view.
         * Called when closing the barangay population modal.
         * Connected to: showBarangayPopulationPopup(), modal close button
         */
        function hideBarangayPopulationPopup() {
            var modal = document.getElementById('barangay-population-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Filtering
        var currentPeopleAllFeats = [];

        /**
         * Updates the display of selected barangays in the people table section.
         * Shows selected barangay names or "All Barangays" if none selected.
         * Called when barangay selection changes.
         * Connected to: handleBarangaySelectionChange(), getSelectedBarangays()
         */
        function updatePeopleBarangayDisplay() {
            try {
                var displayEl = document.getElementById('people-filter-barangay-display');
                if (!displayEl) return;

                var selections = getSelectedBarangays();
                var selectedText = 'All Barangays';

                if (selections.length === 1) {
                    selectedText = selections[0];
                } else if (selections.length > 1) {
                    var preview = selections.slice(0, 3).join(', ');
                    if (selections.length > 3) {
                        preview += ' +' + (selections.length - 3);
                    }
                    selectedText = preview;
                }

                displayEl.textContent = selectedText;
            } catch (e) { /* ignore */ }
        }

        /**
         * Populates demographic filter options from people features.
         * Extracts available demographic filter values from the features array.
         * Used to set up filter dropdowns in the people table (currently may be unused).
         * Called by: showPeopleTableFor()
         * Connected to: applyPeopleFiltersAndRender(), currentPeopleAllFeats
         */
        function populatePeopleFiltersFromFeatures(feats) {
            try {
                updatePeopleBarangayDisplay();
                updateFloodExtentAvailability();
            } catch (e) { /* ignore */ }
        }

        /**
         * Traverses a layer tree recursively, calling callback for each layer.
         * Handles both single layers and layer groups, calling the callback function for each.
         * Used to find nested layers within layer groups.
         * Called by: ensureHouseholdLayers()
         * Connected to: ensureHouseholdLayers()
         */
        function traverseLayerTree(layer, callback) {
            if (!layer) return;
            try {
                callback(layer);
            } catch (e) { /* ignore */ }
            if (layer && typeof layer.getLayers === 'function') {
                var children = layer.getLayers();
                if (children && typeof children.forEach === 'function') {
                    children.forEach(function(child) {
                        traverseLayerTree(child, callback);
                    });
                }
            }
        }

        /**
         * Ensures household layers are registered and ready for use.
         * Traverses the map layer tree to find all Households_1 layers and stores them in householdLayers array.
         * Sets initial visibility to false. Called during map initialization and when toggling household layers.
         * Uses global variable 'householdLayers'.
         * Connected to: toggleLayer(), filterHouseholdsBySelectedBarangay(), setBaseHouseholdLayersVisible(),
         *              traverseLayerTree()
         */
        function ensureHouseholdLayers() {
            try {
                if (typeof map === 'undefined' || !map.getLayers || householdLayers.length > 0) {
                    return;
                }
                var layersCollection = map.getLayers();
                var registered = [];
                layersCollection.forEach(function(layer) {
                    traverseLayerTree(layer, function(candidate) {
                        if (!candidate || typeof candidate.get !== 'function') return;
                        var title = candidate.get('title') || candidate.get('name') || '';
                        if (!title) return;
                        var lower = String(title).toLowerCase();
                        if (lower.indexOf('households_1') !== -1) {
                            if (householdLayers.indexOf(candidate) === -1) {
                                householdLayers.push(candidate);
                                registered.push(title);
                                if (candidate.setVisible) {
                                    candidate.setVisible(false);
                                }
                            }
                        }
                    });
                });
                if (registered.length) {
                    console.log('Registered household base layers:', registered);
                } else {
                    console.warn('No household base layers found during initialization.');
                }
            } catch (e) {
                console.error('Failed to register household layers:', e);
            }
        }

        /**
         * ============================================================================
         * SET BASE HOUSEHOLD LAYERS VISIBLE FUNCTION - DISABLED
         * ============================================================================
         * 
         * This function sets the visibility of base household layers (from layers.js).
         * 
         * HOW IT WORKS (currently disabled):
         * - Toggles visibility of all registered household layers (lyr_Households_1)
         * - Called when toggling household layer visibility or when filtering by barangay
         * - Currently disabled: Function always keeps household layers hidden
         * 
         * CURRENT STATE:
         * - Households_1.js layer is PERMANENTLY DISABLED
         * - This function always sets layers to invisible (false)
         * - Household layers will never be shown on the map
         * 
         * NOTE: Households_1.js layer is permanently disabled. It will not show even when
         * the household button is clicked. Only Sto.Tomas Households layer can be shown.
         * 
         * TO RE-ENABLE:
         * 1. Uncomment the Households_1.js script tag in HTML
         * 2. Uncomment the Households_1_style.js script tag in HTML
         * 3. Remove the early return and always-false logic below
         * 
         * Called when toggling household layer visibility or when filtering by barangay (but currently disabled).
         * Connected to: ensureHouseholdLayers(), toggleLayer(), filterHouseholdsBySelectedBarangay()
         * ============================================================================
         */
        function setBaseHouseholdLayersVisible(visible) {
            // HOUSEHOLDS_1.JS IS DISABLED - Always keep household layers hidden
            console.log('Household layers visibility change skipped - Households_1.js is disabled. Requested visibility:', visible, '(always set to false)');
            try {
                ensureHouseholdLayers();
                // Always set to false (hidden) regardless of requested visibility
                householdLayers.forEach(function(layer) {
                    if (layer && typeof layer.setVisible === 'function') {
                        layer.setVisible(false);
                    }
                });
                console.log('Base household layers forced to hidden (disabled)');
            } catch (e) {
                console.error('Failed to toggle household base layers:', e);
            }
            
            // Original code below is disabled but preserved for future use
            /*
            try {
                ensureHouseholdLayers();
                var bool = !!visible;
                householdLayers.forEach(function(layer) {
                    if (layer && typeof layer.setVisible === 'function') {
                        layer.setVisible(bool);
                    }
                });
                console.log('Base household layers visibility set to:', bool);
            } catch (e) {
                console.error('Failed to toggle household base layers:', e);
            }
            */
        }

        /**
         * ============================================================================
         * SET PEOPLE LAYER VISIBLE FUNCTION - DISABLED
         * ============================================================================
         * 
         * This function sets the visibility of the People layer.
         * 
         * HOW IT WORKS (currently disabled):
         * - Shows or hides the People layer on the map
         * - Ensures the layer is initialized before changing visibility
         * - Currently disabled: Function returns immediately without doing anything
         * 
         * CURRENT STATE:
         * - People_0.js layer is PERMANENTLY DISABLED
         * - This function does nothing and returns immediately
         * - Layer will never be shown or hidden
         * 
         * NOTE: People_0.js layer is permanently disabled. This function will not
         * show or hide the layer even when called.
         * 
         * TO RE-ENABLE: See ensurePeopleLayer() function documentation
         * 
         * Called when toggling layers or when barangay selection changes (but currently disabled).
         * Connected to: ensurePeopleLayer(), toggleLayer(), handleBarangaySelectionChange()
         * ============================================================================
         */
        function setPeopleLayerVisible(visible) {
            // PEOPLE_0.JS IS DISABLED - Return immediately without doing anything
            console.log('People layer visibility change skipped - People_0.js is disabled. Requested visibility:', visible);
            return;
            
            // Original code below is disabled but preserved for future use
            /*
            try {
                ensurePeopleLayer();
                if (!peopleLayer || typeof peopleLayer.setVisible !== 'function') return;
                var bool = !!visible;
                if (peopleLayer.getVisible && peopleLayer.getVisible() === bool) {
                    return;
                }
                peopleLayer.setVisible(bool);
                console.log('People layer visibility forced to:', bool);
            } catch (e) {
                console.error('Failed to toggle people layer visibility:', e);
            }
            */
        }

        /**
         * Sets the disabled state of a control element by ID.
         * Updates both the disabled attribute and 'is-disabled' class.
         * Also removes 'active' class from nav buttons when disabled.
         * Called by: updateFloodExtentAvailability()
         * Connected to: updateFloodExtentAvailability()
         */
        function setControlDisabledById(id, disabled) {
            try {
                var el = document.getElementById(id);
                if (!el) return;
                var shouldDisable = !!disabled;
                if (shouldDisable && el.classList.contains('nav-btn')) {
                    el.classList.remove('active');
                }
                el.disabled = shouldDisable;
                el.classList.toggle('is-disabled', shouldDisable);
                if (shouldDisable) {
                    el.setAttribute('aria-disabled', 'true');
                } else {
                    el.removeAttribute('aria-disabled');
                }
            } catch (e) { /* ignore */ }
        }

        /**
         * ============================================================================
         * FLOOD EXTENT AVAILABILITY UPDATE FUNCTION - MODIFIED
         * ============================================================================
         * 
         * This function updates availability of flood extent dropdown and related controls.
         * 
         * HOW IT WORKS (currently modified):
         * - Flood extent dropdown is PERMANENTLY DISABLED (always set to disabled)
         * - Infographics and Impact Report buttons are enabled/disabled based on barangay selection
         * - Clears flood extent selection if no barangay is selected (if dropdown was enabled)
         * - Logs all changes to console for debugging
         * 
         * CURRENT STATE:
         * - Flood extent dropdown: ALWAYS DISABLED (overrides barangay-based logic)
         * - Infographics button: Enabled when barangays selected, disabled otherwise
         * - Impact Report button: Enabled when barangays selected, disabled otherwise
         * 
         * Enables/disables the flood extent dropdown based on barangay selection.
         * The dropdown is enabled when at least one barangay is selected, disabled otherwise.
         * 
         * Called when barangay selection changes.
         * Connected to: getSelectedBarangays(), handleBarangaySelectionChange(), setControlDisabledById()
         * ============================================================================
         */
        function updateFloodExtentAvailability() {
            console.log('=== UPDATE FLOOD EXTENT AVAILABILITY ===');
            try {
                var floodDropdown = document.getElementById('floodExtentDropdown');
                if (!floodDropdown) {
                    console.warn('Flood extent dropdown not found');
                    return;
                }
                
                var hasBarangay = getSelectedBarangays().length > 0;
                console.log('Barangay selection status:', hasBarangay ? 'has selections' : 'no selections');
                
                // Clear flood extent selection if no barangay is selected (for cleanup)
                if (!hasBarangay && floodDropdown.value) {
                    console.log('Clearing flood extent selection (no barangay selected)');
                    floodDropdown.value = '';
                    floodDropdown.dispatchEvent(new Event('change'));
                }
                
                // Enable/disable flood extent dropdown based on barangay selection
                floodDropdown.disabled = !hasBarangay;
                if (hasBarangay) {
                    floodDropdown.classList.remove('is-disabled');
                    console.log('Flood extent dropdown: ENABLED (barangay selected)');
                } else {
                    floodDropdown.classList.add('is-disabled');
                    console.log('Flood extent dropdown: DISABLED (no barangay selected)');
                }

                // Infographics and Impact Report buttons still depend on barangay selection
                var shouldDisableButtons = !hasBarangay;
                setControlDisabledById('toggleInfographicsBtn', shouldDisableButtons);
                setControlDisabledById('impactReportBtn', shouldDisableButtons);
                console.log('Infographics/Impact Report buttons:', shouldDisableButtons ? 'disabled' : 'enabled');
                
                console.log('=== UPDATE FLOOD EXTENT AVAILABILITY COMPLETE ===');
            } catch (e) {
                console.error('Error updating flood extent availability:', e);
            }
        }

        /**
         * Resets household selection state.
         * Clears selected household row, family ID, and removes highlights and markers.
         * Called when clearing selections or changing filters.
         * Connected to: removeHighlight(), removeHouseMarker(), clearLowerDropdowns(),
         *              setupMapClickHandler()
         */
        function resetHouseholdSelection() {
            if (lastSelectedHouseholdRow) {
                lastSelectedHouseholdRow.classList.remove('household-row-selected');
            }
            lastSelectedHouseholdRow = null;
            lastSelectedFamilyId = '';
            lastSelectedPopulationFeature = null;
            removeHighlight();
            removeHouseMarker();
        }

        /**
         * Removes the filtered household layer from the map.
         * Removes the layer created by filterHouseholdsBySelectedBarangay() when barangay filtering changes.
         * Called when clearing barangay selections or changing filters.
         * Connected to: filterHouseholdsBySelectedBarangay(), clearBarangayDropdown()
         */
        function removeFilteredHouseholdLayer() {
            if (filteredHouseholdLayer && map) {
                map.removeLayer(filteredHouseholdLayer);
                filteredHouseholdLayer = null;
            }
        }

        /**
         * Removes the selected barangay highlight layer from the map.
         * Removes the layer that highlights selected barangay boundaries.
         * Called when barangay selection changes or is cleared.
         * Connected to: filterHouseholdsBySelectedBarangay(), highlightSelectedBarangays(),
         *              clearBarangaySelections()
         */
        function removeSelectedBarangayHighlight() {
            if (selectedBarangayHighlightLayer && map) {
                map.removeLayer(selectedBarangayHighlightLayer);
                selectedBarangayHighlightLayer = null;
            }
        }


        /**
         * Converts an OpenLayers feature to GeoJSON format.
         * Handles both GeoJSON features and OpenLayers features, converting coordinate systems as needed.
         * Used when passing features between functions that expect GeoJSON format.
         * Called by: setupMapClickHandler(), applyHouseholdSelection(), highlightFeatureSelection()
         * Connected to: showHouseholdModal(), applyHouseholdSelection(), zoomToFeature()
         */
        function featureToGeoJson(feature) {
            if (!feature) return null;
            if (feature.type === 'Feature' && feature.geometry) {
                return feature;
            }
            if (feature.getGeometry) {
                try {
                    var format = new ol.format.GeoJSON();
                    return format.writeFeatureObject(feature, {
                        dataProjection: 'EPSG:4326',
                        featureProjection: map ? map.getView().getProjection() : 'EPSG:3857'
                    });
                } catch (e) {
                    console.warn('Failed to convert feature to GeoJSON:', e);
                    return null;
                }
            }
            return null;
        }

        /**
         * Highlights a selected feature on the map.
         * Converts feature to GeoJSON and calls highlightPopulationPolygon().
         * Used to highlight household or population features when selected.
         * Called by: applyHouseholdSelection(), applyPeopleFiltersAndRender()
         * Connected to: featureToGeoJson(), highlightPopulationPolygon()
         */
        function highlightFeatureSelection(feature) {
            var geoFeature = featureToGeoJson(feature);
            if (!geoFeature) return;
            highlightPopulationPolygon(geoFeature);
        }

        /**
         * Gets GeoJSON features for selected barangays from Region2_39 data.
         * Matches features based on selected region, province, municipality, and barangay names.
         * Used to highlight selected barangay boundaries on the map.
         * Called by: filterHouseholdsBySelectedBarangay(), highlightSelectedBarangays()
         * Connected to: getSelectedBarangays(), normalizeBarangayName(), json_Region2_39
         */
        function getSelectedBarangayFeatures() {
            if (typeof json_Region2_39 === 'undefined' || !json_Region2_39.features) {
                return [];
            }
            var regionSelect = document.getElementById('region-select');
            var provinceSelect = document.getElementById('province-select');
            var municipalitySelect = document.getElementById('municipality-select');

            var region = regionSelect ? normalizeBarangayName(regionSelect.value) : '';
            var province = provinceSelect ? normalizeBarangayName(provinceSelect.value) : '';
            var municipality = municipalitySelect ? normalizeBarangayName(municipalitySelect.value) : '';
            var selectedBarangays = getSelectedBarangays();
            var barangaySet = new Set(selectedBarangays.map(normalizeBarangayName));

            if (barangaySet.size === 0) {
                return [];
            }

            var matches = [];
            for (var i = 0; i < json_Region2_39.features.length; i++) {
                var feature = json_Region2_39.features[i];
                if (!feature || !feature.properties) continue;
                var props = feature.properties;
                var featureBarangay = normalizeBarangayName(props.Bgy_Name);
                if (!barangaySet.has(featureBarangay)) continue;

                var featureMunicipality = normalizeBarangayName(props.Mun_Name);
                var featureProvince = normalizeBarangayName(props.Pro_Name);
                var featureRegion = normalizeBarangayName(props.Reg_Name);

                if (municipality && featureMunicipality !== municipality) continue;
                if (province && featureProvince !== province) continue;
                if (region && featureRegion !== region) continue;

                matches.push(feature);
            }
            console.log('Matched', matches.length, 'barangay polygons for selections:', selectedBarangays);
            return matches;
        }

        /**
         * Highlights selected barangay boundaries on the map.
         * Creates a vector layer with orange highlight style for the selected barangay features.
         * Removes previous highlight before adding new one. Uses z-index 1050.
         * Called by: filterHouseholdsBySelectedBarangay()
         * Connected to: removeSelectedBarangayHighlight(), getSelectedBarangayFeatures(),
         *              selectedBarangayHighlightLayer
         */
        function highlightSelectedBarangays(features) {
            removeSelectedBarangayHighlight();
            if (!features || !features.length || !map) return;
            try {
                var format = new ol.format.GeoJSON({
                    dataProjection: 'EPSG:4326',
                    featureProjection: map.getView().getProjection()
                });
                var olFeatures = [];
                for (var i = 0; i < features.length; i++) {
                    try {
                        var olFeature = format.readFeature(features[i]);
                        if (olFeature) {
                            olFeatures.push(olFeature);
                        }
                    } catch (err) {
                        console.warn('Failed to convert barangay feature for highlight:', err);
                    }
                }
                if (!olFeatures.length) return;
                var highlightStyle = new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#f39c12',
                        width: 3
                    }),
                    fill: new ol.style.Fill({
                        color: 'rgba(243, 156, 18, 0.15)'
                    })
                });
                selectedBarangayHighlightLayer = new ol.layer.Vector({
                    source: new ol.source.Vector({ features: olFeatures }),
                    style: highlightStyle,
                    zIndex: 1050
                });
                map.addLayer(selectedBarangayHighlightLayer);
                console.log('Applied persistent highlight for', olFeatures.length, 'barangay polygons.');
            } catch (e) {
                console.error('Failed to highlight barangays:', e);
            }
        }


        /**
         * Updates the visual highlight of selected row in the people table.
         * Adds 'household-row-selected' class to the row matching lastSelectedFamilyId.
         * Called when household selection changes or table is re-rendered.
         * Connected to: applyHouseholdSelection(), applyPeopleFiltersAndRender(),
         *              lastSelectedFamilyId, lastSelectedHouseholdRow
         */
        function updateTableSelectionHighlight() {
            var tbody = document.querySelector('#people-24-table-inner tbody');
            if (lastSelectedHouseholdRow) {
                lastSelectedHouseholdRow.classList.remove('household-row-selected');
                lastSelectedHouseholdRow = null;
            }
            if (!tbody || !lastSelectedFamilyId) {
                return;
            }
            var row = tbody.querySelector('tr[data-exposure-id=\"' + lastSelectedFamilyId + '\"]');
            if (row) {
                row.classList.add('household-row-selected');
                lastSelectedHouseholdRow = row;
            } else {
                lastSelectedFamilyId = '';
                lastSelectedPopulationFeature = null;
                removeHighlight();
                removeHouseMarker();
            }
        }

        /**
         * Extracts family ID from a feature's properties.
         * Tries multiple property names (exposure_id, exposureId, fid, FAMILY-ID, etc.) to find the family identifier.
         * Returns empty string if no family ID found.
         * Called by: setupMapClickHandler(), applyHouseholdSelection()
         * Connected to: showHouseholdModal(), applyHouseholdSelection()
         */
        function getFamilyIdFromFeature(feature) {
            if (!feature) return '';
            var props = feature.get ? feature.getProperties() : feature.properties;
            if (!props) return '';
            var candidates = [
                props.exposure_id,
                props.exposureId,
                props['exposure_id'],
                props['fid'],
                props['FID'],
                props['FAMILY-ID'],
                props['family_id']
            ];
            for (var i = 0; i < candidates.length; i++) {
                var candidate = candidates[i];
                if (candidate !== undefined && candidate !== null && String(candidate).trim() !== '') {
                    return String(candidate).trim();
                }
            }
            return '';
        }

        /**
         * Applies household selection, updating table highlight and map display.
         * Stores selected family ID, highlights the feature on the map, and zooms to it.
         * Updates table row highlight to show which household is selected.
         * Called when clicking on household features or table rows.
         * Connected to: updateTableSelectionHighlight(), highlightFeatureSelection(), zoomToFeature(),
         *              showHouseholdModal(), lastSelectedFamilyId
         */
        function applyHouseholdSelection(familyId, feature, options) {
            if (!familyId) {
                resetHouseholdSelection();
                return;
            }
            lastSelectedFamilyId = familyId;
            var geoFeature = feature ? featureToGeoJson(feature) : featureToGeoJson(findFeatureByFamilyId(familyId));
            if (geoFeature) {
                lastSelectedPopulationFeature = geoFeature;
            } else {
                lastSelectedPopulationFeature = null;
            }
            updateTableSelectionHighlight();
            if (lastSelectedPopulationFeature) {
                highlightFeatureSelection(lastSelectedPopulationFeature);
                if (!options || options.zoom !== false) {
                    zoomToFeature(lastSelectedPopulationFeature);
                }
            }
        }

        /**
         * Filters household layer to show only households in selected barangays.
         * Creates a new filtered layer from json_Households_1 features matching selected barangays.
         * Hides base household layers and shows filtered layer when barangays are selected.
         * Also highlights selected barangay boundaries on the map.
         * Called when barangay selection changes or household layer is toggled.
         * Connected to: getSelectedBarangays(), getSelectedBarangayFeatures(), highlightSelectedBarangays(),
         *              setBaseHouseholdLayersVisible(), removeFilteredHouseholdLayer(),
         *              handleBarangaySelectionChange(), toggleLayer()
         */
        /**
         * ============================================================================
         * FILTER HOUSEHOLDS BY SELECTED BARANGAY FUNCTION - DISABLED
         * ============================================================================
         * 
         * This function filters household polygons based on selected barangays and creates
         * a filtered household layer on the map.
         * 
         * HOW IT WORKS (currently disabled):
         * - Filters json_Households_1 features by selected barangays
         * - Creates a filtered household layer with matching polygons
         * - Shows/hides the filtered layer based on household button state
         * - Currently disabled: Function returns immediately without creating any layers
         * 
         * CURRENT STATE:
         * - Households_1.js layer is PERMANENTLY DISABLED
         * - This function does nothing and returns immediately
         * - Filtered household layers will never be created or shown
         * 
         * NOTE: Households_1.js layer is permanently disabled. This function will not
         * create or show filtered household layers even when barangays are selected.
         * 
         * TO RE-ENABLE: See setBaseHouseholdLayersVisible() function documentation
         * 
         * Called when barangay selection changes (but currently disabled).
         * Connected to: handleBarangaySelectionChange(), setBaseHouseholdLayersVisible()
         * ============================================================================
         */
        function filterHouseholdsBySelectedBarangay() {
            // HOUSEHOLDS_1.JS IS DISABLED - Return immediately without creating filtered layer
            console.log('Household filtering skipped - Households_1.js is disabled');
            
            // Always remove any existing filtered layer
            removeFilteredHouseholdLayer();
            
            // Always keep base household layers hidden
            setBaseHouseholdLayersVisible(false);
            
            // BUT: Still highlight selected barangays even if household filtering is disabled
            var selections = getSelectedBarangays();
            if (selections.length > 0) {
                // Get barangay features for highlighting
                var barangayFeatures = getSelectedBarangayFeatures();
                if (barangayFeatures.length > 0) {
                    highlightSelectedBarangays(barangayFeatures);
                    console.log('Barangay highlight applied for', selections.length, 'selected barangay(s)');
                } else {
                    // If no features found, remove highlight
                    removeSelectedBarangayHighlight();
                    console.log('No barangay features found for selections:', selections);
                }
            } else {
                // If no selections, remove highlight
                removeSelectedBarangayHighlight();
                console.log('No barangay selections - highlight removed');
            }
            
            return;
            
            // Original code below is disabled but preserved for future use
            /*
            ensureHouseholdLayers();
            var selections = getSelectedBarangays();
            var selectionSet = new Set(selections.map(normalizeBarangayName));
            removeSelectedBarangayHighlight();
            removeFilteredHouseholdLayer();

            if (selectionSet.size === 0) {
                console.log('No barangay selections detected. Household filter cleared.');
                if (householdLayersVisible) {
                    setBaseHouseholdLayersVisible(true);
                }
                return;
            }

            if (typeof json_Households_1 === 'undefined' || !json_Households_1.features) {
                console.warn('Household data unavailable');
                return;
            }

            if (!map) {
                console.warn('Map not available for filtering households');
                return;
            }

            var barangayFeatures = getSelectedBarangayFeatures();
            if (!barangayFeatures.length) {
                console.warn('Unable to locate barangay boundary features for selections:', selections);
                return;
            }

            highlightSelectedBarangays(barangayFeatures);

            var format = new ol.format.GeoJSON({
                dataProjection: 'EPSG:4326',
                featureProjection: map.getView().getProjection()
            });

            var matchedFeatures = [];
            for (var i = 0; i < json_Households_1.features.length; i++) {
                var feat = json_Households_1.features[i];
                if (!feat || !feat.properties || !feat.geometry) continue;

                var props = feat.properties;
                var featureBarangay = normalizeBarangayName(props.BARANGAY);
                if (!selectionSet.has(featureBarangay)) {
                    continue;
                }

                try {
                    var olFeature = format.readFeature(feat);
                    if (olFeature) {
                        matchedFeatures.push(olFeature);
                    }
                } catch (err) {
                    console.warn('Failed to convert household feature for filtering:', err);
                }
            }

            console.log('Prepared', matchedFeatures.length, 'household polygons for barangay selections:', selections);

            if (matchedFeatures.length === 0) {
                if (householdLayersVisible) {
                    setBaseHouseholdLayersVisible(false);
                }
                return;
            }

            if (!householdLayersVisible) {
                console.log('Household layers are currently hidden; filtered results will render when activated.');
                return;
            }

            filteredHouseholdLayer = new ol.layer.Vector({
                source: new ol.source.Vector({
                    features: matchedFeatures
                }),
                style: function(feature) {
                    return [
                        new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                color: 'rgba(35,35,35,1.0)',
                                width: 0.988
                            }),
                            fill: new ol.style.Fill({
                                color: 'rgba(196,60,57,1.0)'
                            })
                        })
                    ];
                },
                visible: householdLayersVisible,
                title: 'Filtered Households',
                zIndex: 1200
            });

            map.addLayer(filteredHouseholdLayer);
            if (householdLayersVisible) {
                setBaseHouseholdLayersVisible(false);
                filteredHouseholdLayer.setVisible(true);
            } else {
                filteredHouseholdLayer.setVisible(false);
            }
            console.log('Filtered household layer created and added to map');
            */
        }

        function checkDemoFilter(filter, demos, properties) {
            try {
                var lower = (filter || '').toLowerCase();
                var fallback = function(key) {
                    var raw = properties ? properties[key] : 0;
                    var num = parseFloat(raw || 0);
                    return isNaN(num) ? 0 : num;
                };
                var values = {
                    infant: demos ? demos.infant : fallback('infant'),
                    child: demos ? demos.child : fallback('child'),
                    youth: demos ? demos.youth : fallback('youth'),
                    adult: demos ? demos.adult : fallback('adult'),
                    elderly: demos ? demos.elderly : fallback('elderly'),
                    male: demos ? demos.male : fallback('male'),
                    female: demos ? demos.female : fallback('female'),
                    disabled: demos ? demos.disabled : fallback('disabled')
                };
                if (!values.hasOwnProperty(lower)) {
                    return true;
                }
                return (values[lower] || 0) > 0;
            } catch (e) {
                return true;
            }
        }

        /**
         * Applies filters to people data and renders the filtered results in the table.
         * Filters by barangay selection and demographic criteria, then builds table rows.
         * Also highlights filtered features on the map and updates the row count.
         * Called when barangay selection changes, demographic filter changes, or flood extent changes.
         * Connected to: getSelectedBarangays(), normalizeBarangayName(), checkDemoFilter(),
         *              calculateDemographicsFromHouseholds(), highlightTableFeatures(),
         *              updatePeopleCount(), updateTableSelectionHighlight(), handleBarangaySelectionChange()
         */
        function applyPeopleFiltersAndRender() {
            var tbody = document.querySelector('#people-24-table-inner tbody');
            if (!tbody) return;
            var selectedBarangays = getSelectedBarangays();
            var barangaySet = new Set(selectedBarangays.map(normalizeBarangayName));
            var hasBarangayFilter = barangaySet.size > 0;

            var rendered = 0;
            var rows = '';
            var totalRecords = 0; // Count total records matching filters (all records)
            var filteredFeatures = []; // Collect features that pass filters for highlighting
            
            var demoFilter = (currentDemoFilter || '').toLowerCase();

            // First pass: count all records matching filters
            for (var i = 0; i < currentPeopleAllFeats.length; i++) {
                var f = currentPeopleAllFeats[i];
                var p = f && f.properties ? f.properties : {};
                
                // Apply barangay filter
                var brgyVal = normalizeBarangayName(p['aggregation_name']);
                if (hasBarangayFilter && !barangaySet.has(brgyVal)) continue;
                
                if (demoFilter) {
                    var exposureIdFirst = p.exposure_id || '';
                    var demosFirst = calculateDemographicsFromHouseholds(exposureIdFirst);
                    var passes = checkDemoFilter(demoFilter, demosFirst, p);
                    if (!passes) continue;
                }
                
                // Count all records matching filters
                totalRecords++;
            }
            
            // Second pass: render all records matching filters (no deduplication)
            for (var i = 0; i < currentPeopleAllFeats.length; i++) {
                var f = currentPeopleAllFeats[i];
                var p = f && f.properties ? f.properties : {};
                
                // Apply barangay filter
                var brgyVal = normalizeBarangayName(p['aggregation_name']);
                if (hasBarangayFilter && !barangaySet.has(brgyVal)) continue;

                if (demoFilter) {
                    var exposureIdFilter = p.exposure_id || '';
                    var demosFilter = calculateDemographicsFromHouseholds(exposureIdFilter);
                    var passesFilter = checkDemoFilter(demoFilter, demosFilter, p);
                    if (!passesFilter) continue;
                }
                
                // Collect feature for highlighting
                filteredFeatures.push(f);
                
                // Show ALL records matching the filters (no deduplication)
                var hazard = (p.hazard_class != null ? String(p.hazard_class) : '');
                if (hazard.toLowerCase() === 'use_caution') hazard = 'very low';
                var brgyShow = p['aggregation_name'] || '';
                var exposureId = p.exposure_id || '';
                
                // Calculate demographics from household data
                var calculatedDemos = calculateDemographicsFromHouseholds(exposureId);
                
                // Use calculated demographics if available, otherwise fall back to exposure data
                var infant = calculatedDemos ? calculatedDemos.infant : (p.infant || 0);
                var child = calculatedDemos ? calculatedDemos.child : (p.child || 0);
                var youth = calculatedDemos ? calculatedDemos.youth : (p.youth || 0);
                var adult = calculatedDemos ? calculatedDemos.adult : (p.adult || 0);
                var elderly = calculatedDemos ? calculatedDemos.elderly : (p.elderly || 0);
                var male = calculatedDemos ? calculatedDemos.male : (p.male || 0);
                var female = calculatedDemos ? calculatedDemos.female : (p.female || 0);
                var disabled = calculatedDemos ? calculatedDemos.disabled : (p.disabled || 0);
                
                // Increment row number for display
                rendered++;
                
                rows += '<tr data-exposure-id="' + exposureId + '">' +
                    '<td>' + rendered + '</td>' +
                    '<td>' + brgyShow + '</td>' +
                    '<td>' + infant + '</td>' +
                    '<td>' + child + '</td>' +
                    '<td>' + youth + '</td>' +
                    '<td>' + adult + '</td>' +
                    '<td>' + elderly + '</td>' +
                    '<td>' + male + '</td>' +
                    '<td>' + female + '</td>' +
                    '<td>' + disabled + '</td>' +
                    '<td>' + hazard + '</td>' +
                '</tr>';
            }
            if (rows === '') rows = '<tr><td colspan="11" class="empty-message">No data</td></tr>';
            tbody.innerHTML = rows;
            updateTableSelectionHighlight();
            if (lastSelectedPopulationFeature) {
                highlightFeatureSelection(lastSelectedPopulationFeature);
            }
            updatePeopleCount(rendered, totalRecords);
            
            // Highlight all filtered features on the map
            highlightTableFeatures(filteredFeatures);
        }
        
        /**
         * Highlights features displayed in the population exposure table on the map.
         * Finds matching features from the current flood extent layer and adds them to highlight layer.
         * Uses exposure_id to match features between table data and map layer.
         * Called after filtering and rendering people table.
         * Connected to: applyPeopleFiltersAndRender(), highlightLayer, currentPeopleAllFeats
         */
        function highlightTableFeatures(features) {
            try {
                if (!highlightLayer) {
                    createHighlightLayer();
                }
                
                // Clear previous highlights
                highlightLayer.getSource().clear();
                
                if (features.length === 0) {
                    return;
                }
                
                // Get the current meter value to find the correct layer
                var dropdown = document.getElementById('floodExtentDropdown');
                var meter = dropdown ? dropdown.value : null;
                if (!meter) return;
                
                // Find the layer for this meter (e.g., Numberofpeopleat24meters_12)
                var layerName = 'numberofpeopleat' + meter + 'meters';
                var targetLayer = null;
                
                map.getLayers().forEach(function(layer) {
                    var layerTitle = layer.get('title') || '';
                    var layerTitleLower = layerTitle.toLowerCase();
                    var layerTitleCompact = layerTitleLower.replace(/[^a-z0-9]+/g, '');
                    if (layerTitleLower.indexOf(layerName) !== -1 || layerTitleCompact.indexOf(layerName) !== -1) {
                        targetLayer = layer;
                    }
                });
                
                if (!targetLayer || !targetLayer.getSource()) {
                    console.warn('Could not find layer for meter:', meter);
                    return;
                }
                
                // Collect exposure_ids from filtered features
                var exposureIds = new Set();
                for (var i = 0; i < features.length; i++) {
                    var f = features[i];
                    var p = f && f.properties ? f.properties : {};
                    var exposureId = p.exposure_id;
                    if (exposureId != null) {
                        exposureIds.add(String(exposureId));
                    }
                }
                
                // Find matching features from the layer source
                var layerSource = targetLayer.getSource();
                var olFeatures = [];
                
                layerSource.forEachFeature(function(olFeature) {
                    var props = olFeature.getProperties();
                    var exposureId = props.exposure_id;
                    if (exposureId != null && exposureIds.has(String(exposureId))) {
                        // Clone the feature to add to highlight layer
                        var clonedFeature = olFeature.clone();
                        olFeatures.push(clonedFeature);
                    }
                });
                
                // Add all features to highlight layer
                if (olFeatures.length > 0) {
                    highlightLayer.getSource().addFeatures(olFeatures);
                    console.log('Highlighted', olFeatures.length, 'polygons from population exposure table');
                }
            } catch (e) {
                console.error('Error highlighting table features:', e);
            }
        }

        /**
         * Updates the people table count display.
         * Shows number of rendered rows vs total filtered rows, and includes demographic filter info if active.
         * Called after rendering people table.
         * Connected to: applyPeopleFiltersAndRender(), currentDemoFilter
         */
        function updatePeopleCount(rendered, total) {
            try {
                var el = document.getElementById('people-table-count');
                if (el) {
                    var text = String(rendered) + ' of ' + String(total) + ' rows';
                    if (currentDemoFilter) {
                        text += ' (filtered by ' + currentDemoFilter.replace(/_/g, ' ') + ')';
                    }
                    el.textContent = text;
                }
            } catch (e) { /* ignore */ }
        }

        


        // Wire close button
        (function(){
            var btn = document.getElementById('people-24-close');
            if (btn && !btn._wired) {
                btn.addEventListener('click', function(){ hidePeople24Table(); });
                btn._wired = true;
            }
        })();
        
        // Chart instances
        var hazardPieChart = null;
        var demographicsBarChart = null;
        // Right pane chart instances
        var householdsChart = null;
        var populationChart = null;
        var sexChart = null;
        var ageChart = null;
        
        /**
         * Formats a number with thousands separators (commas).
         * Example: 1346 becomes "1,346", 2951 becomes "2,951"
         */
        function formatNumber(num) {
            return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }

        /**
         * Normalizes an age value to a non-negative number or returns null if invalid.
         */
        function sanitizeAgeValue(value) {
            var parsed = Number(value);
            if (isNaN(parsed) || !isFinite(parsed) || parsed < 0) {
                return null;
            }
            return parsed;
        }
        var currentDemoFilter = '';
        var lastSelectedFamilyId = '';
        var lastSelectedHouseholdRow = null;
        var lastSelectedPopulationFeature = null;
        var filteredHouseholdLayer = null;
        var selectedBarangayHighlightLayer = null;
        
        /**
         * Shows the charts panel and updates chart data.
         * Displays the charts panel overlay and triggers chart update.
         * Called when user wants to view charts.
         * Connected to: updateCharts(), hideChartsPanel()
         */
        function showChartsPanel() {
            // Update top pane position when charts panel is shown
            updateTopPanePosition();
            var chartsPanel = document.getElementById('charts-panel');
            var mapContainer = document.getElementById('map-container');
            if (chartsPanel && mapContainer) {
                chartsPanel.style.display = 'flex';
                mapContainer.classList.add('charts-open');
                updateCharts();
            }
        }
        
        /**
         * Hides the charts panel.
         * Sets charts panel display to 'none' and removes 'charts-open' class from map container.
         * Called when closing charts panel.
         * Connected to: showChartsPanel()
         */
        function hideChartsPanel() {
            var chartsPanel = document.getElementById('charts-panel');
            var mapContainer = document.getElementById('map-container');
            if (chartsPanel && mapContainer) {
                chartsPanel.style.display = 'none';
                mapContainer.classList.remove('charts-open');
                // Update top pane position when charts panel is hidden
                updateTopPanePosition();
            }
        }
        
        /**
         * Updates charts (pie chart and bar chart) with filtered data.
         * Calculates hazard level distribution and demographics from filtered people data.
         * Charts reflect the same data shown in the Population exposure table.
         * Creates/updates Chart.js instances for hazard pie chart and demographics bar chart.
         * Called when filters change or charts panel is shown.
         * Connected to: getSelectedBarangays(), calculateDemographicsFromHouseholds(),
         *              applyPeopleFiltersAndRender(), handleBarangaySelectionChange(),
         *              showChartsPanel(), currentPeopleAllFeats, hazardPieChart, demographicsBarChart
         */
        function updateCharts() {
            // Don't update charts when flood extent is selected - charts panel is hidden
            var dropdown = document.getElementById('floodExtentDropdown');
            var meterVal = dropdown ? String(dropdown.value || '').trim() : '';
            if (meterVal) {
                // If flood extent is selected, don't show charts
                if (hazardPieChart) hazardPieChart.destroy();
                if (demographicsBarChart) demographicsBarChart.destroy();
                hazardPieChart = null;
                demographicsBarChart = null;
                return;
            }
            
            // Check if we have data, if not, try to get it (only if no flood extent is selected)
            if (!currentPeopleAllFeats || currentPeopleAllFeats.length === 0) {
                // Only load if no flood extent is selected
                if (!meterVal) {
                    var jsonObj = getPeopleJsonFor(meterVal);
                    if (jsonObj && jsonObj.features) {
                        currentPeopleAllFeats = jsonObj.features;
                    }
                }
            }
            
            if (!currentPeopleAllFeats || currentPeopleAllFeats.length === 0) {
                // Clear charts if no data
                if (hazardPieChart) hazardPieChart.destroy();
                if (demographicsBarChart) demographicsBarChart.destroy();
                hazardPieChart = null;
                demographicsBarChart = null;
                return;
            }
            
            var selectedBarangays = getSelectedBarangays();
            var barangaySet = new Set(selectedBarangays.map(normalizeBarangayName));
            var hasBarangayFilter = barangaySet.size > 0;
            
            // Filter data based on selected filters (if any) - same logic as table
            var filteredData = [];
            for (var i = 0; i < currentPeopleAllFeats.length; i++) {
                var f = currentPeopleAllFeats[i];
                var p = f && f.properties ? f.properties : {};
                
                // Apply barangay filter if selected
                if (hasBarangayFilter) {
                    var brgyVal = normalizeBarangayName(p['aggregation_name']);
                    if (!barangaySet.has(brgyVal)) continue;
                }
                
                filteredData.push(p);
            }
            
            if (filteredData.length === 0) {
                if (hazardPieChart) hazardPieChart.destroy();
                if (demographicsBarChart) demographicsBarChart.destroy();
                hazardPieChart = null;
                demographicsBarChart = null;
                return;
            }
            
            // Calculate hazard level distribution - COUNT ROWS (not sum population)
            var hazardData = {
                'high': 0,
                'medium': 0,
                'low': 0,
                'very low': 0
            };
            
            for (var i = 0; i < filteredData.length; i++) {
                var p = filteredData[i];
                var hazardClass = (p['hazard_class'] || '').toString().trim().toLowerCase();
                if (hazardClass === 'use_caution') hazardClass = 'very low';
                
                if (hazardData.hasOwnProperty(hazardClass)) {
                    hazardData[hazardClass]++; // Count rows, not sum population
                }
            }
            
            // Calculate demographics - use calculated values from household data (same as table)
            var demoData = {
                infant: 0,
                child: 0,
                youth: 0,
                adult: 0,
                elderly: 0,
                disabled: 0
            };
            var demoKeysForChart = ['infant', 'child', 'youth', 'adult', 'elderly', 'disabled'];
            
            for (var i = 0; i < filteredData.length; i++) {
                var p = filteredData[i];
                var exposureId = p.exposure_id || '';
                
                // Calculate demographics from household data (same as table)
                var calculatedDemos = calculateDemographicsFromHouseholds(exposureId);
                
                // Use calculated demographics if available, otherwise fall back to exposure data
                demoData.infant += calculatedDemos ? calculatedDemos.infant : (parseFloat(p.infant || 0));
                demoData.child += calculatedDemos ? calculatedDemos.child : (parseFloat(p.child || 0));
                demoData.youth += calculatedDemos ? calculatedDemos.youth : (parseFloat(p.youth || 0));
                demoData.adult += calculatedDemos ? calculatedDemos.adult : (parseFloat(p.adult || 0));
                demoData.elderly += calculatedDemos ? calculatedDemos.elderly : (parseFloat(p.elderly || 0));
                demoData.disabled += calculatedDemos ? calculatedDemos.disabled : (parseFloat(p.disabled || 0));
            }
            
            // Update Pie Chart
            var pieCtx = document.getElementById('hazardPieChart');
            if (pieCtx) {
                if (hazardPieChart) hazardPieChart.destroy();
                hazardPieChart = new Chart(pieCtx, {
                    type: 'pie',
                    data: {
                        labels: ['High', 'Medium', 'Low', 'Very Low'],
                        datasets: [{
                            data: [
                                hazardData['high'],
                                hazardData['medium'],
                                hazardData['low'],
                                hazardData['very low']
                            ],
                            backgroundColor: [
                                'rgba(220, 53, 69, 0.8)',   // Red for High
                                'rgba(255, 193, 7, 0.8)',   // Yellow for Medium
                                'rgba(40, 167, 69, 0.8)',   // Green for Low
                                'rgba(108, 117, 125, 0.8)'  // Gray for Very Low
                            ],
                            borderColor: [
                                'rgba(220, 53, 69, 1)',
                                'rgba(255, 193, 7, 1)',
                                'rgba(40, 167, 69, 1)',
                                'rgba(108, 117, 125, 1)'
                            ],
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    color: '#fafafa',
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            tooltip: {
                                enabled: false // Disable tooltips
                            },
                            datalabels: {
                                color: '#ffffff',
                                font: {
                                    weight: 'bold',
                                    size: 12
                                },
                                formatter: function(value, context) {
                                    return Math.round(value);
                                },
                                anchor: 'center',
                                align: 'center'
                            }
                        }
                    },
                    plugins: [ChartDataLabels] // Register the plugin
                });
            }
            
            // Update Bar Chart
            var barCtx = document.getElementById('demographicsBarChart');
            if (barCtx) {
                if (demographicsBarChart) demographicsBarChart.destroy();
                var demoColors = demoKeysForChart.map(function(key) {
                    if (!currentDemoFilter) {
                        return 'rgba(243, 156, 18, 0.8)';
                    }
                    return currentDemoFilter === key ? 'rgba(243, 156, 18, 1)' : 'rgba(243, 156, 18, 0.35)';
                });
                demographicsBarChart = new Chart(barCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Infant', 'Child', 'Youth', 'Adult', 'Elderly', 'Disabled'],
                        datasets: [{
                            label: 'Population',
                            data: [
                                demoData.infant,
                                demoData.child,
                                demoData.youth,
                                demoData.adult,
                                demoData.elderly,
                                demoData.disabled
                            ],
                            backgroundColor: demoColors,
                            borderColor: 'rgba(243, 156, 18, 1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: false // Disable tooltips
                            },
                            datalabels: {
                                color: '#ffffff',
                                font: {
                                    weight: 'bold',
                                    size: 11
                                },
                                formatter: function(value) {
                                    var rounded = Math.round(value);
                                    return rounded > 0 ? rounded.toLocaleString() : '';
                                },
                                anchor: 'end',
                                align: 'top',
                                offset: 5
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 20000,
                                ticks: {
                                    color: '#fafafa',
                                    font: {
                                        size: 11
                                    }
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                }
                            },
                            x: {
                                ticks: {
                                    color: '#fafafa',
                                    font: {
                                        size: 11
                                    }
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                }
                            }
                        },
                        onClick: function(evt, elements) {
                            if (!elements || elements.length === 0) {
                                if (currentDemoFilter) {
                                    currentDemoFilter = '';
                                    applyPeopleFiltersAndRender();
                                    updateCharts();
                                }
                                return;
                            }
                            var first = elements[0];
                            if (typeof first.index === 'undefined') return;
                            var key = demoKeysForChart[first.index] || '';
                            if (!key) return;
                            currentDemoFilter = (currentDemoFilter === key) ? '' : key;
                            applyPeopleFiltersAndRender();
                            updateCharts();
                        },
                        onHover: function(evt, elements) {
                            var target = evt && evt.native ? evt.native.target : (evt ? evt.target : null);
                            if (target) {
                                target.style.cursor = (elements && elements.length) ? 'pointer' : 'default';
                            }
                        }
                    },
                    plugins: [ChartDataLabels] // Register the plugin
                });
            }
        }
        
        /**
         * Checks if all canvas elements for right pane charts exist in the DOM.
         * Returns true if all canvas elements are found, false otherwise.
         */
        function areChartCanvasesReady() {
            var canvases = [
                document.getElementById('householdsChart'),
                document.getElementById('populationChart'),
                document.getElementById('sexChart'),
                document.getElementById('ageChart')
            ];
            var allReady = canvases.every(function(canvas) {
                return canvas !== null && canvas !== undefined;
            });
            if (!allReady) {
                console.log('Chart canvases not ready yet. Found:', canvases.filter(function(c) { return c !== null; }).length, 'of 4');
            }
            return allReady;
        }
        
        /**
         * Updates the right pane charts with statistics from DB_0.js based on selected barangays.
         * Calculates and displays: Total Households, Total Population, Group by Sex, and Group by Age.
         * Called when barangay selection changes or on page load.
         * Connected to: getSelectedBarangays(), normalizeBarangayName(), json_DB_0,
         *              householdsChart, populationChart, sexChart, ageChart
         */
        function updateRightPaneCharts() {
            try {
                // Check if canvas elements exist
                if (!areChartCanvasesReady()) {
                    console.warn('Chart canvas elements not ready, retrying in 500ms...');
                    setTimeout(updateRightPaneCharts, 500);
                    return;
                }
                
                console.log('Updating right pane charts...');
                
                // Check if DB_0 data is available
                if (typeof json_DB_0 === 'undefined' || !json_DB_0.features) {
                    console.warn('DB_0 data not available for right pane charts, initializing with zero values');
                    // Initialize charts with zero values
                    updateHouseholdsChart(0);
                    updatePopulationChart(0);
                    updateSexChart(0, 0);
                    updateAgeChart(null);
                    return;
                }
                
                // Get selected barangays
                var selectedBarangays = getSelectedBarangays();
                var barangaySet = new Set();
                selectedBarangays.forEach(function(barangay) {
                    barangaySet.add(normalizeBarangayName(barangay));
                });
                
                // Filter features by selected barangays
                var filteredFeatures = [];
                if (barangaySet.size > 0) {
                    for (var i = 0; i < json_DB_0.features.length; i++) {
                        var feature = json_DB_0.features[i];
                        if (!feature || !feature.properties) continue;
                        var featBarangay = normalizeBarangayName(feature.properties.BARANGAY || '');
                        if (barangaySet.has(featBarangay)) {
                            filteredFeatures.push(feature);
                        }
                    }
                }
                
                // Calculate statistics
                var stats = {
                    totalHouseholds: 0,
                    totalPopulation: filteredFeatures.length,
                    male: 0,
                    female: 0
                };
                var ageStats = {
                    infant: 0,
                    child: 0,
                    adult: 0,
                    elderly: 0
                };
                
                // Count unique FAMILY-ID for households
                var uniqueFamilyIds = new Set();
                for (var j = 0; j < filteredFeatures.length; j++) {
                    var feat = filteredFeatures[j];
                    var props = feat.properties;
                    var familyId = props['FAMILY-ID'] || '';
                    if (familyId) {
                        uniqueFamilyIds.add(String(familyId));
                    }
                    // Count by sex
                    var sex = String(props.SEX || '').toUpperCase();
                    if (sex === 'M') {
                        stats.male++;
                    } else if (sex === 'F') {
                        stats.female++;
                    }

                    // Count by age group
                    var ageValue = sanitizeAgeValue(props.AGE);
                    if (ageValue !== null) {
                        if (ageValue <= 4) {
                            ageStats.infant++;
                        } else if (ageValue <= 14) {
                            ageStats.child++;
                        } else if (ageValue <= 64) {
                            ageStats.adult++;
                        } else {
                            ageStats.elderly++;
                        }
                    }
                }
                stats.totalHouseholds = uniqueFamilyIds.size;
                
                console.log('Chart statistics calculated:', stats);
                
                // Update Total Households Chart
                updateHouseholdsChart(stats.totalHouseholds);
                
                // Update Total Population Chart
                updatePopulationChart(stats.totalPopulation);
                
                // Update Group by Sex Chart
                updateSexChart(stats.male, stats.female);
                
                // Update Group by Age Chart
                updateAgeChart(ageStats);
                
                console.log('Right pane charts updated successfully');
                
            } catch (e) {
                console.error('Error updating right pane charts:', e);
                // Initialize charts with zero values on error
                try {
                    updateHouseholdsChart(0);
                    updatePopulationChart(0);
                    updateSexChart(0, 0);
                    updateAgeChart(null);
                } catch (err) {
                    console.error('Error initializing charts with zero values:', err);
                }
            }
        }
        
        /**
         * Updates the Total Households donut chart.
         */
        function updateHouseholdsChart(total) {
            try {
                var ctx = document.getElementById('householdsChart');
                if (!ctx) {
                    console.warn('householdsChart canvas not found');
                    return;
                }
                
                if (householdsChart) {
                    householdsChart.destroy();
                    householdsChart = null;
                }
                
                // Ensure total is a number, default to 0 if undefined/null
                total = total || 0;
                
                console.log('Creating households chart with value:', total);
                
                // For single value, show as a donut with one segment
                householdsChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Households'],
                    datasets: [{
                        data: [total],
                        backgroundColor: ['rgba(36, 178, 255, 0.8)'],
                        borderColor: ['rgba(36, 178, 255, 1)'],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '70%',
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: function(context) {
                                    return 'Total: ' + formatNumber(context.parsed);
                                }
                            }
                        },
                        datalabels: {
                            color: '#ffffff',
                            font: {
                                weight: 'bold',
                                size: 11
                            },
                            formatter: function(value) {
                                return formatNumber(value || 0);
                            },
                            anchor: 'center',
                            align: 'center'
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
            } catch (e) {
                console.error('Error creating households chart:', e);
            }
        }
        
        /**
         * Updates the Total Population donut chart.
         */
        function updatePopulationChart(total) {
            try {
                console.log('updatePopulationChart called with total:', total);
                
                // Check if Chart.js is available
                if (typeof Chart === 'undefined') {
                    console.error('Chart.js library not loaded');
                    return;
                }
                
                var ctx = document.getElementById('populationChart');
                if (!ctx) {
                    console.warn('populationChart canvas not found');
                    return;
                }
                
                console.log('Population chart canvas found:', ctx);
                
                if (populationChart) {
                    populationChart.destroy();
                    populationChart = null;
                }
                
                // Ensure total is a number, default to 0 if undefined/null
                total = Number(total) || 0;
                
                console.log('Creating population chart with value:', total);
                
                // Use a minimum value of 1 for Chart.js to render properly, but display 0 in label
                var chartValue = Math.max(total, 1);
                
                populationChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Population'],
                        datasets: [{
                            data: [chartValue],
                            backgroundColor: ['rgba(243, 156, 18, 0.8)'],
                            borderColor: ['rgba(243, 156, 18, 1)'],
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        cutout: '70%',
                        animation: {
                            animateRotate: true,
                            animateScale: true
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: true,
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                callbacks: {
                                    label: function(context) {
                                        return 'Total: ' + formatNumber(total);
                                    }
                                }
                            },
                            datalabels: {
                                color: '#ffffff',
                                font: {
                                    weight: 'bold',
                                    size: 11
                                },
                                formatter: function(value, context) {
                                    // Always show the actual total value, not the chart value
                                    return formatNumber(total);
                                },
                                anchor: 'center',
                                align: 'center'
                            }
                        }
                    },
                    plugins: [ChartDataLabels]
                });
                
                console.log('Population chart created successfully');
            } catch (e) {
                console.error('Error creating population chart:', e);
                console.error('Error stack:', e.stack);
            }
        }
        
        /**
         * Updates the Group by Sex donut chart.
         */
        function updateSexChart(male, female) {
            try {
                var ctx = document.getElementById('sexChart');
                if (!ctx) {
                    console.warn('sexChart canvas not found');
                    return;
                }
                
                if (sexChart) {
                    sexChart.destroy();
                    sexChart = null;
                }
                
                // Ensure values are numbers
                male = male || 0;
                female = female || 0;
                var total = male + female;
                var malePercent = total > 0 ? ((male / total) * 100).toFixed(2) : 0;
                var femalePercent = total > 0 ? ((female / total) * 100).toFixed(2) : 0;
                
                console.log('Creating sex chart with values - Male:', male, 'Female:', female);
                
                sexChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Male', 'Female'],
                    datasets: [{
                        data: [male, female],
                        backgroundColor: [
                            'rgba(36, 178, 255, 0.8)',   // Light blue for Male
                            'rgba(243, 156, 18, 0.8)'    // Orange for Female
                        ],
                        borderColor: [
                            'rgba(36, 178, 255, 1)',
                            'rgba(243, 156, 18, 1)'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '60%',
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#fafafa',
                                font: {
                                    size: 9,
                                    weight: '500'
                                },
                                padding: 5,
                                usePointStyle: true,
                                pointStyle: 'circle',
                                generateLabels: function(chart) {
                                    var data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        return data.labels.map(function(label, i) {
                                            var value = data.datasets[0].data[i];
                                            var percent = total > 0 ? ((value / total) * 100).toFixed(2) : 0;
                                            return {
                                                text: label + ': ' + formatNumber(value) + ' (' + percent + '%)',
                                                fillStyle: data.datasets[0].backgroundColor[i],
                                                strokeStyle: data.datasets[0].borderColor[i],
                                                lineWidth: 2,
                                                hidden: false,
                                                index: i,
                                                fontColor: '#fafafa'
                                            };
                                        });
                                    }
                                    return [];
                                }
                            }
                        },
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: 'rgba(255, 255, 255, 0.2)',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    var label = context.label || '';
                                    var value = context.parsed;
                                    var percent = total > 0 ? ((value / total) * 100).toFixed(2) : 0;
                                    return label + ': ' + formatNumber(value) + ' (' + percent + '%)';
                                }
                            }
                        },
                        datalabels: {
                            color: '#ffffff',
                            font: {
                                weight: '600',
                                size: 10
                            },
                            formatter: function(value) {
                                if (!value) return '';
                                var percent = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                return formatNumber(value) + '\n(' + percent + '%)';
                            },
                            anchor: 'center',
                            align: 'center',
                            clamp: true,
                            textStrokeColor: 'rgba(0, 0, 0, 0.55)',
                            textStrokeWidth: 3,
                            padding: 2
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
            } catch (e) {
                console.error('Error creating sex chart:', e);
            }
        }
        
        /**
         * Updates the Group by Age donut chart with data sourced from DB_0.js.
         */
        function updateAgeChart(ageData) {
            try {
                console.log('updateAgeChart called with ageData:', ageData);
                
                if (typeof Chart === 'undefined') {
                    console.error('Chart.js library not loaded');
                    return;
                }
                
                var ctx = document.getElementById('ageChart');
                if (!ctx) {
                    console.warn('ageChart canvas not found');
                    return;
                }
                
                if (ageChart) {
                    ageChart.destroy();
                    ageChart = null;
                }
                
                var buckets = {
                    infant: 0,
                    child: 0,
                    adult: 0,
                    elderly: 0
                };
                
                if (ageData && typeof ageData === 'object') {
                    if (Array.isArray(ageData) && ageData.length === 4) {
                        buckets.infant = Number(ageData[0]) || 0;
                        buckets.child = Number(ageData[1]) || 0;
                        buckets.adult = Number(ageData[2]) || 0;
                        buckets.elderly = Number(ageData[3]) || 0;
                    } else {
                        buckets.infant = Number(ageData.infant) || 0;
                        buckets.child = Number(ageData.child) || 0;
                        buckets.adult = Number(ageData.adult) || 0;
                        buckets.elderly = Number(ageData.elderly) || 0;
                    }
                }
                
                var labels = [
                    'Infant 0-4',
                    'Child 5-14',
                    'Adult 15-64',
                    'Elderly 65+'
                ];
                var datasetData = [
                    buckets.infant,
                    buckets.child,
                    buckets.adult,
                    buckets.elderly
                ];
                var total = datasetData.reduce(function(sum, value) {
                    return sum + (Number(value) || 0);
                }, 0);
                
                if (total === 0) {
                    console.log('No age data available, rendering empty state for age chart');
                    ageChart = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: ['No Data'],
                            datasets: [{
                                data: [1],
                                backgroundColor: ['rgba(108, 117, 125, 0.4)'],
                                borderColor: ['rgba(108, 117, 125, 0.8)'],
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            cutout: '70%',
                            plugins: {
                                legend: {
                                    display: false
                                },
                                tooltip: {
                                    enabled: false
                                },
                                datalabels: {
                                    color: '#9aa0ae',
                                    font: {
                                        weight: 'normal',
                                        size: 10
                                    },
                                    formatter: function() {
                                        return 'No Data';
                                    },
                                    anchor: 'center',
                                    align: 'center'
                                }
                            }
                        },
                        plugins: [ChartDataLabels]
                    });
                    return;
                }
                
                var colors = [
                    'rgba(36, 178, 255, 0.85)',   // Infant - Light blue
                    'rgba(243, 156, 18, 0.85)',    // Child - Orange
                    'rgba(52, 152, 219, 0.85)',    // Adult - Blue
                    'rgba(155, 89, 182, 0.85)'     // Elderly - Purple
                ];
                
                var borderColors = [
                    'rgba(36, 178, 255, 1)',
                    'rgba(243, 156, 18, 1)',
                    'rgba(52, 152, 219, 1)',
                    'rgba(155, 89, 182, 1)'
                ];
                
                ageChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: datasetData,
                            backgroundColor: colors,
                            borderColor: borderColors,
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        cutout: '60%',
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: true,
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: 'rgba(255, 255, 255, 0.2)',
                                borderWidth: 1,
                                callbacks: {
                                    title: function(context) {
                                        return context[0].label;
                                    },
                                    label: function(context) {
                                        var value = context.parsed || 0;
                                        var percent = total > 0 ? ((value / total) * 100).toFixed(2) : 0;
                                        return [
                                            'Count: ' + formatNumber(value),
                                            'Share: ' + percent + '%'
                                        ];
                                    }
                                }
                            },
                            datalabels: {
                                color: '#ffffff',
                                font: {
                                    weight: '600',
                                    size: 9
                                },
                                anchor: 'center',
                                align: 'center',
                                formatter: function(value, context) {
                                    if (!value) return '';
                                    var dataset = context.chart.data.datasets[0];
                                    var sum = dataset.data.reduce(function(acc, val) {
                                        return acc + (Number(val) || 0);
                                    }, 0);
                                    var percent = sum > 0 ? ((value / sum) * 100).toFixed(1) : 0;
                                    var percentNum = parseFloat(percent);
                                    if (percentNum >= 10) {
                                        return formatNumber(value) + '\n(' + percent + '%)';
                                    }
                                    return percent + '%';
                                }
                            }
                        }
                    },
                    plugins: [ChartDataLabels]
                });
                
                console.log('Age chart created successfully');
            } catch (e) {
                console.error('Error creating age chart:', e);
                console.error('Error stack:', e.stack);
            }
        }
        
        /**
         * Shows the people table for a specific flood extent meter value.
         * Loads people data for the meter, populates filters, renders table, and displays the pane.
         * Sets table title and pane height. Also shows charts panel.
         * Called when flood extent dropdown changes to a valid meter value.
         * Connected to: getPeopleJsonFor(), populatePeopleFiltersFromFeatures(),
         *              applyPeopleFiltersAndRender(), hidePeople24Table(), setupFloodExtentListeners()
         */
        /**
         * Loads people data for the specified meter without displaying the table.
         * Data is still loaded and available for other functions (filtering, calculations, etc.).
         * Called when flood extent is selected.
         * @param {Number} meter - The flood extent meter value (24-30)
         */
        function loadPeopleDataForMeter(meter) {
            try {
                var dropdown = document.getElementById('floodExtentDropdown');
                if (!dropdown || String(dropdown.value) !== String(meter)) { 
                    return; 
                }
                // If data not ready yet, retry shortly
                var jsonObj = getPeopleJsonFor(meter);
                if (!jsonObj) { 
                    setTimeout(function(){ loadPeopleDataForMeter(meter); }, 200); 
                    return; 
                }
                var feats = (jsonObj && jsonObj.features) ? jsonObj.features : [];
                currentPeopleAllFeats = feats;
                populatePeopleFiltersFromFeatures(feats);
                // Don't show table or charts panel - data is loaded for other functions
                hidePeople24Table();
                hideChartsPanel();
            } catch (e) { 
                console.error('Error loading people data for meter:', meter, e);
            }
        }

        /**
         * Shows the population exposure table for the specified meter.
         * NOTE: This function is kept for backward compatibility but is not called when flood extent is selected.
         * @param {Number} meter - The flood extent meter value (24-30)
         */
        function showPeopleTableFor(meter) {
            try {
                var dropdown = document.getElementById('floodExtentDropdown');
                if (!dropdown || String(dropdown.value) !== String(meter)) { 
                    hidePeople24Table(); 
                    return; 
                }
                var navBar = document.getElementById('top-navigation-bar');
                var tbody = document.querySelector('#people-24-table-inner tbody');
                var titleTextEl = document.getElementById('people-table-title-text');
                if (!navBar || !tbody) return;
                // If data not ready yet, retry shortly
                var jsonObj = getPeopleJsonFor(meter);
                if (!jsonObj) { setTimeout(function(){ showPeopleTableFor(meter); }, 200); return; }
                var feats = (jsonObj && jsonObj.features) ? jsonObj.features : [];
                currentPeopleAllFeats = feats;
                populatePeopleFiltersFromFeatures(feats);
                applyPeopleFiltersAndRender(); // This will update the counter correctly
                // Show navigation bar
                navBar.style.display = 'block';
                if (titleTextEl) titleTextEl.textContent = 'Population Exposure - ' + String(meter) + ' meters';
                
                // Update navigation bar position based on right pane and charts panel state
                updateTopPanePosition();
                
                // Adjust map container to account for navigation bar
                var mapContainer = document.getElementById('map-container');
                if (mapContainer) {
                    mapContainer.classList.add('nav-bar-visible');
                }
                
                // Don't show charts panel when flood extent is selected
                hideChartsPanel();
            } catch (e) { /* ignore */ }
        }

        /**
         * Hides the people table pane.
         * Sets display to 'none' to hide the people table from view.
         * Called when flood extent is cleared or changed to a value without table data.
         * Connected to: showPeopleTableFor(), setupFloodExtentListeners(), hideAllFloodGroups()
         */
        function hidePeople24Table() {
            var navBar = document.getElementById('top-navigation-bar');
            if (navBar) { navBar.style.display = 'none'; }
            
            // Remove nav-bar-visible class from map container
            var mapContainer = document.getElementById('map-container');
            if (mapContainer) {
                mapContainer.classList.remove('nav-bar-visible');
            }
            
            updatePeopleCount(0, 0);
            hideChartsPanel();
            resetHouseholdSelection();
            // Clear highlights when table is hidden
            if (highlightLayer) {
                highlightLayer.getSource().clear();
            }
        }
        
        // Household Modal Functions
        /**
         * Shows the household details modal for a specific family ID.
         * Loads household data, displays household members in a table, and shows household size.
         * Zooms to and highlights the household polygon on the map.
         * Called when clicking on household features or table rows.
         * Connected to: findHouseholdDataByFamilyId(), generateReligion(), zoomToFeature(),
         *              highlightPopulationPolygon(), setupMapClickHandler(), setupTableClickHandlers()
         */
        function showHouseholdModal(familyId, feature) {
            try {
                var modal = document.getElementById('household-modal');
                var title = document.getElementById('household-modal-title');
                var tbody = document.getElementById('household-details-tbody');
                var householdSizeValue = document.getElementById('household-size-value');
                
                if (!modal || !title || !tbody || !householdSizeValue) return;
                
                // Find household data for this fid
                var householdData = findHouseholdDataByFamilyId(familyId);
                
                if (householdData.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #999;">No household data found for fid: ' + familyId + '</td></tr>';
                    householdSizeValue.textContent = '-';
                } else {
                    var rows = '';
                    var familyReligion = generateReligion(); // Generate one religion for the entire family
                    var householdSize = householdData.length; // Count the number of rows
                    
                    // Display household size at the top
                    householdSizeValue.textContent = householdSize;
                    
                    householdData.forEach(function(member) {
                        rows += '<tr>' +
                            '<td>' + (member['RELATION'] || '') + '</td>' +
                            '<td>' + (member['GIVEN NAME'] || '') + '</td>' +
                            '<td>' + (member['LAST NAME'] || '') + '</td>' +
                            '<td>' + (member['AGE'] || '') + '</td>' +
                            '<td>' + (member['SEX'] || '') + '</td>' +
                            '<td>' + (member['OCCUPATION'] || '') + '</td>' +
                            '<td>' + familyReligion + '</td>' +
                        '</tr>';
                    });
                    tbody.innerHTML = rows;
                }
                
                title.textContent = 'Household Details';
                modal.style.display = 'flex';
                
                // Zoom to and highlight the selected polygon
                console.log('Attempting to zoom to feature:', feature);
                if (feature) {
                    zoomToFeature(feature);
                    // Highlight the population polygon
                    highlightPopulationPolygon(feature);
                } else {
                    console.log('No feature provided for zooming');
                }
            } catch (e) {
                console.error('Error showing household modal:', e);
            }
        }
        
        /**
         * Hides the household details modal.
         * Sets modal display to 'none' and removes house marker and highlight.
         * Called when closing the household modal.
         * Connected to: showHouseholdModal(), removeHouseMarker(), removeHighlight()
         */
        function hideHouseholdModal() {
            var modal = document.getElementById('household-modal');
            if (modal) {
                modal.style.display = 'none';
                // Remove house marker when modal is closed
                removeHouseMarker();
                // Remove highlight when modal is closed
                removeHighlight();
            }
        }
        
        /**
         * Finds household data for a given family ID from json_Households_1.
         * Searches for features matching the family ID (by FAMILY-ID or fid property).
         * Returns an array of household member property objects.
         * Called by: showHouseholdModal(), setupMapClickHandler()
         * Connected to: json_Households_1, showHouseholdModal()
         */
        function findHouseholdDataByFamilyId(familyId) {
            try {
                if (typeof json_Households_1 === 'undefined' || !json_Households_1.features) {
                    console.log('Household data not available');
                    return [];
                }
                
                // Convert both values to strings for comparison
                var familyIdStr = String(familyId).trim();
                if (familyIdStr === '') {
                    return [];
                }

                console.log('Looking for household data with identifier:', familyIdStr);

                // First try direct FAMILY-ID matches
                var directMatches = json_Households_1.features.filter(function(feature) {
                    if (!feature || !feature.properties) return false;
                    var householdFamilyId = feature.properties['FAMILY-ID'];
                    return householdFamilyId !== undefined && householdFamilyId !== null &&
                        String(householdFamilyId).trim() === familyIdStr;
                });

                if (directMatches.length > 0) {
                    console.log('Found', directMatches.length, 'rows via FAMILY-ID match');
                    return directMatches.map(function(feature) {
                        return feature.properties;
                    });
                }

                console.log('No direct FAMILY-ID match; falling back to fid lookup');
                
                // First, find the fid match to get the FAMILY-ID
                var matchedFeature = null;
                for (var i = 0; i < json_Households_1.features.length; i++) {
                    var feature = json_Households_1.features[i];
                    if (feature && feature.properties) {
                        var householdFid = String(feature.properties['fid']);
                        if (householdFid === familyIdStr) {
                            matchedFeature = feature;
                            console.log('Found matching fid!', feature);
                            break;
                        }
                    }
                }
                
                if (!matchedFeature) {
                    console.log('No matching fid found:', familyIdStr);
                    return [];
                }
                
                // Now get the FAMILY-ID from the matched feature
                var familyIdValue = matchedFeature.properties['FAMILY-ID'];
                console.log('FAMILY-ID for fid', familyIdStr, 'is:', familyIdValue);
                
                // Now find all features with the same FAMILY-ID
                var matchingFeatures = json_Households_1.features.filter(function(feature) {
                    if (!feature.properties) return false;
                    var householdFamilyId = String(feature.properties['FAMILY-ID']);
                    return householdFamilyId === String(familyIdValue);
                });
                
                console.log('Found', matchingFeatures.length, 'matching household features');
                
                if (matchingFeatures.length === 0) {
                    // Let's check if there are any similar IDs for debugging
                    var allFamilyIds = json_Households_1.features
                        .filter(function(f) { return f.properties && f.properties['FAMILY-ID']; })
                        .map(function(f) { return f.properties['FAMILY-ID']; })
                        .slice(0, 10); // Show first 10 for debugging
                    console.log('Sample household Family IDs:', allFamilyIds);
                }
                
                return matchingFeatures.map(function(feature) {
                    return feature.properties;
                });
            } catch (e) {
                console.error('Error finding household data:', e);
                return [];
            }
        }
        
        /**
         * Generates a random religion value for household display.
         * Uses weighted distribution: 70% Roman Catholic, 15% Iglesia ni Cristo, 10% Born Again Christian, 5% Islam.
         * Called when displaying household data in the modal.
         * Connected to: showHouseholdModal()
         */
        function generateReligion() {
            // Most households are Roman Catholic, then others
            // Weighted distribution: 70% Roman Catholic, 15% Iglesia ni Cristo, 10% Born Again Christian, 5% Islam
            var random = Math.random();
            if (random < 0.70) {
                return 'Roman Catholic';
            } else if (random < 0.85) {
                return 'Iglesia ni Cristo';
            } else if (random < 0.95) {
                return 'Born Again Christian';
            } else {
                return 'Islam';
            }
        }
        
        /**
         * Shows the infographics modal with PDF for a specific flood extent meter.
         * Loads PDF from infographics/{meter}/output/infographic.pdf and displays it in an object element.
         * Shows loading spinner while PDF loads.
         * Called when clicking infographics button (requires barangay selection).
         * Connected to: updateFloodExtentAvailability(), hideInfographicsModal()
         */
        function showInfographicsModal(meter) {
            try {
                var modal = document.getElementById('infographics-modal');
                var title = document.getElementById('infographics-modal-title');
                var body = modal ? modal.querySelector('.modal-body') : null;
                var container = document.getElementById('infographics-container');
                if (!modal || !container) return;
                var safeMeter = String(meter).replace(/[^0-9]/g, '');
                var pdfPath = 'infographics/' + safeMeter + '/output/infographic.pdf';
                if (title) title.textContent = 'Infographics  ' + safeMeter + ' meters';
                // Show loading state
                container.innerHTML = '<div class="loading-wrap"><div class="spinner"></div></div>';
                // Insert <object> for PDF
                var objectEl = document.createElement('object');
                objectEl.setAttribute('data', pdfPath);
                objectEl.setAttribute('type', 'application/pdf');
                objectEl.setAttribute('style', 'width:100%; height:100%;');
                // Fallback content for object
                var fallbackDiv = document.createElement('div');
                fallbackDiv.setAttribute('style', 'padding:16px; color:#e0e0e0; text-align:center;');
                fallbackDiv.textContent = 'Attempting to load PDF...';
                objectEl.appendChild(fallbackDiv);

                // Replace loading after a short delay regardless (object has no reliable load)
                setTimeout(function(){
                    container.innerHTML = '';
                    container.appendChild(objectEl);
                }, 800);
                modal.style.display = 'flex';
                modal.style.zIndex = '1000';
            } catch (e) { /* ignore */ }
        }

        /**
         * Hides the infographics modal.
         * Sets modal display to 'none' and clears the container content.
         * Called when closing the infographics modal.
         * Connected to: showInfographicsModal()
         */
        function hideInfographicsModal() {
            try {
                var modal = document.getElementById('infographics-modal');
                if (!modal) return; 
                modal.style.display = 'none';
                var container = document.getElementById('infographics-container');
                if (container) container.innerHTML = '';
            } catch (e) { /* ignore */ }
        }

        /**
         * Shows the impact report modal with HTML report for a specific flood extent meter.
         * Loads HTML from infographics/{meter}/output/impact-report-output.html and displays it in an iframe.
         * Shows loading spinner while report loads.
         * Called when clicking impact report button (requires barangay selection).
         * Connected to: updateFloodExtentAvailability(), hideImpactReportModal()
         */
        function showImpactReportModal(meter) {
            try {
                var modal = document.getElementById('impact-report-modal');
                var container = document.getElementById('impact-report-container');
                var title = document.getElementById('impact-report-modal-title');
                if (!modal || !container) return;
                var safeMeter = String(meter).replace(/[^0-9]/g, '');
                if (title) title.textContent = 'Impact Report  ' + safeMeter + ' meters';
                var htmlPath = 'infographics/' + safeMeter + '/output/impact-report-output.html';
                // Prepare container and overlay spinner without replacing content repeatedly
                container.innerHTML = '';
                var wrapper = document.createElement('div');
                wrapper.setAttribute('style', 'position:relative; width:100%; height:100%; background:#1e2329;');

                var spinnerWrap = document.createElement('div');
                spinnerWrap.className = 'loading-wrap';
                spinnerWrap.setAttribute('style', 'position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:#1e2329;');
                var spinner = document.createElement('div');
                spinner.className = 'spinner';
                spinnerWrap.appendChild(spinner);

                var iframe = document.createElement('iframe');
                iframe.src = htmlPath;
                iframe.title = 'Impact Report';
                iframe.setAttribute('style', 'width:100%; height:100%; border:none; background:#1e2329; visibility:hidden;');
                iframe.onload = function(){
                    iframe.style.visibility = 'visible';
                    if (spinnerWrap && spinnerWrap.parentNode) spinnerWrap.parentNode.removeChild(spinnerWrap);
                };
                iframe.onerror = function(){
                    if (spinnerWrap && spinnerWrap.parentNode) spinnerWrap.parentNode.removeChild(spinnerWrap);
                    wrapper.innerHTML = '';
                    var err = document.createElement('div');
                    err.className = 'inline-error';
                    err.innerHTML = 'Unable to load Impact Report. <a href="' + htmlPath + '" target="_blank" style="color:#f39c12; text-decoration:underline;">Open in new tab</a>';
                    wrapper.appendChild(err);
                };

                wrapper.appendChild(iframe);
                wrapper.appendChild(spinnerWrap);
                container.appendChild(wrapper);
                modal.style.display = 'flex';
                modal.style.zIndex = '1000';
            } catch (e) { /* ignore */ }
        }

        /**
         * Hides the impact report modal.
         * Sets modal display to 'none' and clears the container content.
         * Called when closing the impact report modal.
         * Connected to: showImpactReportModal()
         */
        function hideImpactReportModal() {
            try {
                var modal = document.getElementById('impact-report-modal');
                if (!modal) return;
                modal.style.display = 'none';
                var container = document.getElementById('impact-report-container');
                if (container) container.innerHTML = '';
            } catch (e) { /* ignore */ }
        }

        // Global variable to store the current house marker
        var currentHouseMarker = null;
        // Global variable to store the current highlighted polygon layer
        var currentHighlightLayer = null;
        
        /**
         * Highlights a population polygon on the map with red border and fill.
         * Converts GeoJSON feature to OpenLayers feature and adds it to a highlight layer.
         * Removes previous highlight before adding new one. Uses z-index 1100.
         * Called when selecting a household or clicking on population features.
         * Connected to: showHouseholdModal(), applyHouseholdSelection(), highlightFeatureSelection(),
         *              currentHighlightLayer
         */
        function highlightPopulationPolygon(feature) {
            try {
                // Remove existing highlight layer
                if (currentHighlightLayer) {
                    map.removeLayer(currentHighlightLayer);
                    currentHighlightLayer = null;
                }
                
                if (!feature || !feature.geometry) {
                    console.log('No feature geometry to highlight');
                    return;
                }
                
                // Convert GeoJSON feature to OpenLayers feature
                var format = new ol.format.GeoJSON({
                    dataProjection: 'EPSG:4326',
                    featureProjection: 'EPSG:3857'
                });
                
                var olFeature = format.readFeature(feature);
                
                // Create highlight style
                var highlightStyle = new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#ff0000',
                        width: 3
                    }),
                    fill: new ol.style.Fill({
                        color: 'rgba(255, 0, 0, 0.2)'
                    })
                });
                
                // Create vector layer with highlighted feature
                currentHighlightLayer = new ol.layer.Vector({
                    source: new ol.source.Vector({
                        features: [olFeature]
                    }),
                    style: highlightStyle,
                    zIndex: 3000 // Above other layers
                });
                
                // Add highlight layer to map
                map.addLayer(currentHighlightLayer);
                console.log('Population polygon highlighted');
                
            } catch (e) {
                console.error('Error highlighting population polygon:', e);
            }
        }
        
        // Remove highlight function
        /**
         * Removes the population polygon highlight from the map.
         * Removes the current highlight layer if it exists.
         * Called when clearing selection or closing modals.
         * Connected to: highlightPopulationPolygon(), resetHouseholdSelection(),
         *              hideHouseholdModal(), currentHighlightLayer
         */
        function removeHighlight() {
            if (currentHighlightLayer) {
                map.removeLayer(currentHighlightLayer);
                currentHighlightLayer = null;
                console.log('Highlight removed');
            }
        }
        
        /**
         * Zooms the map to a specific feature's extent.
         * Calculates the feature's geometry extent and fits the map view to that extent.
         * Uses animation duration of 1000ms and max zoom of 17.
         * Called when selecting a household or clicking on features.
         * Connected to: showHouseholdModal(), applyHouseholdSelection(), zoomToArea()
         */
        function zoomToFeature(feature) {
            try {
                console.log('zoomToFeature called with:', feature);
                
                if (!map) {
                    console.log('Map not available');
                    return;
                }
                
                if (!feature) {
                    console.log('No feature provided');
                    return;
                }
                
                // Handle both OpenLayers features and raw GeoJSON features
                var geometry;
                if (feature.getGeometry) {
                    // OpenLayers feature
                    console.log('Processing OpenLayers feature');
                    geometry = feature.getGeometry();
                } else if (feature.geometry) {
                    // Raw GeoJSON feature - convert to OpenLayers geometry
                    console.log('Processing GeoJSON feature:', feature.geometry);
                    var format = new ol.format.GeoJSON({
                        dataProjection: 'EPSG:4326', // Input projection (WGS84)
                        featureProjection: 'EPSG:3857' // Output projection (Web Mercator)
                    });
                    geometry = format.readGeometry(feature.geometry);
                    console.log('Converted geometry:', geometry);
                } else {
                    console.log('No geometry found in feature');
                    return;
                }
                
                if (!geometry) {
                    console.log('No geometry after processing');
                    return;
                }
                
                var extent = geometry.getExtent();
                console.log('Feature extent:', extent);
                
                if (!extent || extent.length !== 4) {
                    console.log('Invalid extent');
                    return;
                }
                
                // Get center coordinates
                var center = ol.extent.getCenter(extent);
                console.log('Center coordinates:', center);
                
                // Check if extent has valid coordinates (not all zeros)
                if (extent[0] === 0 && extent[1] === 0 && extent[2] === 0 && extent[3] === 0) {
                    console.log('Extent is all zeros, trying alternative approach');
                    
                    if (center[0] !== 0 || center[1] !== 0) {
                        // Use center coordinates with a reasonable zoom level
                        map.getView().setCenter(center);
                        map.getView().setZoom(15);
                        console.log('Set center and zoom manually');
                        
                        // Add house marker at center
                        addHouseMarker(center);
                        return;
                    }
                }
                
                // Add some padding around the feature
                var padding = 100; // Use meters for Web Mercator
                var expandedExtent = [
                    extent[0] - padding,
                    extent[1] - padding,
                    extent[2] + padding,
                    extent[3] + padding
                ];
                
                console.log('Expanded extent:', expandedExtent);
                console.log('Zooming to feature...');
                
                map.getView().fit(expandedExtent, {
                    duration: 1000, // Animation duration in milliseconds
                    padding: [50, 50, 50, 50] // Add padding around the feature
                });
                
                // Add house marker at center after zoom
                setTimeout(function() {
                    addHouseMarker(center);
                }, 1100); // Wait for zoom animation to complete
                
                console.log('Zoom command sent');
            } catch (e) {
                console.error('Error zooming to feature:', e);
            }
        }
        
        // Add house marker function
        /**
         * Adds a house marker icon at the specified center coordinate.
         * Creates an OpenLayers icon feature and adds it to a marker layer on the map.
         * Uses a house icon with text label "This house".
         * Called when displaying household location on the map.
         * Connected to: removeHouseMarker(), currentHouseMarker
         */
        function addHouseMarker(center) {
            try {
                // Remove existing marker
                if (currentHouseMarker) {
                    map.removeLayer(currentHouseMarker);
                }
                
                // Create marker style
                var markerStyle = new ol.style.Style({
                    image: new ol.style.Icon({
                        src: 'data:image/svg+xml;base64,' + btoa(`
                            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="16" cy="16" r="12" fill="#e74c3c" stroke="#fff" stroke-width="3"/>
                                <path d="M16 8l-8 6v10h4v-6h8v6h4V14l-8-6z" fill="#fff"/>
                            </svg>
                        `),
                        scale: 1,
                        anchor: [0.5, 1]
                    }),
                    text: new ol.style.Text({
                        text: 'This house',
                        font: 'bold 14px Arial',
                        fill: new ol.style.Fill({
                            color: '#2c3e50'
                        }),
                        stroke: new ol.style.Stroke({
                            color: '#fff',
                            width: 3
                        }),
                        offsetY: -40,
                        textAlign: 'center'
                    })
                });
                
                // Create marker feature
                var markerFeature = new ol.Feature({
                    geometry: new ol.geom.Point(center),
                    name: 'House Marker'
                });
                
                // Create marker layer
                currentHouseMarker = new ol.layer.Vector({
                    source: new ol.source.Vector({
                        features: [markerFeature]
                    }),
                    style: markerStyle,
                    zIndex: 1000
                });
                
                // Add marker to map
                map.addLayer(currentHouseMarker);
                console.log('House marker added at:', center);
                
            } catch (e) {
                console.error('Error adding house marker:', e);
            }
        }
        
        /**
         * Removes the house marker from the map.
         * Removes the marker layer if it exists.
         * Called when clearing selection or closing modals.
         * Connected to: addHouseMarker(), resetHouseholdSelection(), hideHouseholdModal(),
         *              currentHouseMarker
         */
        function removeHouseMarker() {
            if (currentHouseMarker) {
                map.removeLayer(currentHouseMarker);
                currentHouseMarker = null;
                console.log('House marker removed');
            }
        }
        
        // Setup modal event listeners
        /**
         * Sets up the household modal with close button and drag functionality.
         * Adds event listener for close button and makes modal draggable by header.
         * Called during page initialization.
         * Connected to: hideHouseholdModal(), modal drag handlers
         */
        function setupHouseholdModal() {
            var modal = document.getElementById('household-modal');
            var modalContent = document.querySelector('.modal-content');
            var modalHeader = document.querySelector('.modal-header');
            var closeBtn = document.getElementById('household-modal-close');
            
            if (closeBtn) {
                closeBtn.addEventListener('click', hideHouseholdModal);
            }
            
            // Remove the click-outside-to-close functionality since we want map interaction
            // Users can close the modal using the X button
            
            // Make modal draggable
            if (modalHeader && modalContent) {
                var isDragging = false;
                var currentX;
                var currentY;
                var initialX;
                var initialY;
                var xOffset = 0;
                var yOffset = 0;
                
                modalHeader.addEventListener('mousedown', dragStart);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);
                
                function dragStart(e) {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    
                    if (e.target === modalHeader || modalHeader.contains(e.target)) {
                        isDragging = true;
                    }
                }
                
                function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        
                        xOffset = currentX;
                        yOffset = currentY;
                        
                        modalContent.style.transform = 'translate(' + currentX + 'px, ' + currentY + 'px)';
                    }
                }
                
                function dragEnd(e) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                }
            }
        }
        
        /**
         * Sets up click handlers for table cells in the people table.
         * When a cell is clicked, finds the exposure_id and applies household selection.
         * Called during page initialization.
         * Connected to: applyHouseholdSelection(), findFeatureByFamilyId(), resetHouseholdSelection()
         */
        function setupTableClickHandlers() {
            var tbody = document.querySelector('#people-24-table-inner tbody');
            if (tbody) {
                tbody.addEventListener('click', function(e) {
                    var cell = e.target;
                    if (cell.tagName === 'TD') {
                        var row = cell.parentElement;
                        // Get exposure_id from the row's data attribute
                        var exposureId = row.getAttribute('data-exposure-id');
                        var familyId = exposureId ? exposureId.trim() : '';
                        
                        console.log('Table cell clicked, fid:', familyId);
                        console.log('fid type:', typeof familyId, 'Value:', familyId);
                        
                        if (familyId && familyId !== '') {
                            var populationFeature = findFeatureByFamilyId(familyId);
                            applyHouseholdSelection(familyId, populationFeature);
                            } else {
                            resetHouseholdSelection();
                        }
                    }
                });
            }
        }
        
        /**
         * Finds a feature from currentPeopleAllFeats by family ID (exposure_id).
         * Searches through the current people features array for matching exposure_id.
         * Returns the feature object or null if not found.
         * Called when clicking on table rows to locate the corresponding map feature.
         * Connected to: setupTableClickHandlers(), applyHouseholdSelection(), currentPeopleAllFeats
         */
        function findFeatureByFamilyId(familyId) {
            try {
                if (!currentPeopleAllFeats || currentPeopleAllFeats.length === 0) return null;
                
                var familyIdStr = String(familyId);
                for (var i = 0; i < currentPeopleAllFeats.length; i++) {
                    var feature = currentPeopleAllFeats[i];
                    if (feature && feature.properties && String(feature.properties.exposure_id) === familyIdStr) {
                        return feature;
                    }
                }
                return null;
            } catch (e) {
                console.error('Error finding feature by fid:', e);
                return null;
            }
        }
        
        // Initialize modal functionality
        document.addEventListener('DOMContentLoaded', function() {
            setupHouseholdModal();
            setupTableClickHandlers();
            var infoClose = document.getElementById('infographics-modal-close');
            if (infoClose && !infoClose._wired) {
                infoClose.addEventListener('click', hideInfographicsModal);
                infoClose._wired = true;
            }

            var infoMax = document.getElementById('infographics-modal-maximize');
            if (infoMax && !infoMax._wired) {
                infoMax.addEventListener('click', function(){
                    try {
                        var modal = document.getElementById('infographics-modal');
                        if (!modal) return;
                        var content = modal.querySelector('.modal-content');
                        if (!content) return;
                        var isMax = content.classList.contains('maximized');
                        if (isMax) {
                            content.classList.remove('maximized');
                            infoMax.title = 'Maximize';
                            infoMax.textContent = '';
                        } else {
                            content.classList.add('maximized');
                            infoMax.title = 'Restore';
                            infoMax.textContent = '';
                        }
                    } catch (e) { /* ignore */ }
                });
                infoMax._wired = true;
            }

            // Impact Report modal close
            var irClose = document.getElementById('impact-report-modal-close');
            if (irClose && !irClose._wired) {
                irClose.addEventListener('click', hideImpactReportModal);
                irClose._wired = true;
            }
            
            // Barangay Population modal close
            var barangayPopClose = document.getElementById('barangay-population-close');
            if (barangayPopClose && !barangayPopClose._wired) {
                barangayPopClose.addEventListener('click', hideBarangayPopulationPopup);
                barangayPopClose._wired = true;
            }

            // Impact Report modal maximize
            var irMax = document.getElementById('impact-report-modal-maximize');
            if (irMax && !irMax._wired) {
                irMax.addEventListener('click', function(){
                    try {
                        var modal = document.getElementById('impact-report-modal');
                        if (!modal) return;
                        var content = modal.querySelector('.modal-content');
                        if (!content) return;
                        var isMax = content.classList.contains('maximized');
                        if (isMax) {
                            content.classList.remove('maximized');
                            irMax.title = 'Maximize';
                            irMax.textContent = '';
                        } else {
                            content.classList.add('maximized');
                            irMax.title = 'Restore';
                            irMax.textContent = '';
                        }
                    } catch (e) { /* ignore */ }
                });
                irMax._wired = true;
            }

            // Make Infographics modal draggable by its header
            (function(){
                var modal = document.getElementById('infographics-modal');
                if (!modal) return;
                var content = modal.querySelector('.modal-content');
                var header = modal.querySelector('.modal-header');
                if (!content || !header) return;

                var isDragging = false;
                var initialX = 0, initialY = 0;
                var currentX = 0, currentY = 0;
                var xOffset = 0, yOffset = 0;

                header.style.cursor = 'move';
                header.addEventListener('mousedown', dragStart);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);

                function dragStart(e) {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    if (e.target === header || header.contains(e.target)) {
                        isDragging = true;
                    }
                }

                function drag(e) {
                    if (!isDragging) return;
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;
                    content.style.transform = 'translate(' + currentX + 'px, ' + currentY + 'px)';
                }

                function dragEnd() {
                    isDragging = false;
                }
            })();

            // Make Impact Report modal draggable by its header
            (function(){
                var modal = document.getElementById('impact-report-modal');
                if (!modal) return;
                var content = modal.querySelector('.modal-content');
                var header = modal.querySelector('.modal-header');
                if (!content || !header) return;

                var isDragging = false;
                var initialX = 0, initialY = 0;
                var currentX = 0, currentY = 0;
                var xOffset = 0, yOffset = 0;

                header.style.cursor = 'move';
                header.addEventListener('mousedown', dragStart);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);

                function dragStart(e) {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    if (e.target === header || header.contains(e.target)) {
                        isDragging = true;
                    }
                }

                function drag(e) {
                    if (!isDragging) return;
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;
                    content.style.transform = 'translate(' + currentX + 'px, ' + currentY + 'px)';
                }

                function dragEnd() {
                    isDragging = false;
                }
            })();

            // Wire Impact Report button
            var impactBtn = document.getElementById('impactReportBtn');
            if (impactBtn && !impactBtn._wired) {
                impactBtn.addEventListener('click', function() {
                    try {
                        var dropdown = document.getElementById('floodExtentDropdown');
                        var meterVal = dropdown ? String(dropdown.value || '').trim() : '';
                        if (!meterVal) {
                            alert('Please select a Flood Extent first.');
                            return;
                        }
                        try { localStorage.setItem('lastFloodMeter', meterVal); } catch (e) { /* ignore */ }
                        showImpactReportModal(meterVal);
                    } catch (e) { /* ignore */ }
                });
                impactBtn._wired = true;
            }

            // Wire standalone Infographics button (near L645)
            var toggleInfoBtn = document.getElementById('toggleInfographicsBtn');
            if (toggleInfoBtn && !toggleInfoBtn._wired) {
                toggleInfoBtn.addEventListener('click', function() {
                    try {
                        var dropdown = document.getElementById('floodExtentDropdown');
                        var meterVal = dropdown ? String(dropdown.value || '').trim() : '';
                        if (!meterVal) {
                            alert('Please select a Flood Extent first.');
                            return;
                        }
                        try { localStorage.setItem('lastFloodMeter', meterVal); } catch (e) { /* ignore */ }
                        showInfographicsModal(meterVal);
                    } catch (e) { /* ignore */ }
                });
                toggleInfoBtn._wired = true;
            }

            // AI Chat widget logic
            (function(){
                var toggle = document.getElementById('ai-chat-toggle');
                var panel = document.getElementById('ai-chat-panel');
                var closeBtn = document.getElementById('ai-chat-close');
                var body = document.getElementById('ai-chat-body');
                var input = document.getElementById('ai-chat-input');
                var send = document.getElementById('ai-chat-send');
                var settings = document.getElementById('ai-chat-settings');
                var docsBtn = document.getElementById('ai-chat-docs');
                var keyHint = document.getElementById('ai-key-hint');
                var isSending = false;

                function getApiKey(){
                    try { return localStorage.getItem('openai_api_key') || ''; } catch(e){ return ''; }
                }
                function setApiKey(val){
                    try { localStorage.setItem('openai_api_key', val || ''); } catch(e){}
                }
                function getProxyUrl(){
                    try { return localStorage.getItem('openai_proxy_url') || ''; } catch(e){ return ''; }
                }
                function setProxyUrl(val){
                    try { localStorage.setItem('openai_proxy_url', val || ''); } catch(e){}
                }
                function getOrgId(){ try { return localStorage.getItem('openai_org_id') || ''; } catch(e){ return ''; } }
                function setOrgId(v){ try { localStorage.setItem('openai_org_id', v || ''); } catch(e){} }
                function getProjectId(){ try { return localStorage.getItem('openai_project_id') || ''; } catch(e){ return ''; } }
                function setProjectId(v){ try { localStorage.setItem('openai_project_id', v || ''); } catch(e){} }
                function ensureKeyHint(){
                    var has = !!getApiKey() || !!getProxyUrl();
                    if (keyHint) keyHint.style.display = has ? 'none' : 'block';
                }
                function appendMsg(role, text){
                    var div = document.createElement('div');
                    div.className = 'ai-msg ' + (role === 'user' ? 'user' : 'assistant');
                    div.textContent = text;
                    body.appendChild(div);
                    body.scrollTop = body.scrollHeight;
                }
                function currentMeter(){
                    var dd = document.getElementById('floodExtentDropdown');
                    return dd ? String(dd.value || '').trim() : '';
                }
                function sleep(ms){ return new Promise(function(r){ setTimeout(r, ms); }); }
                async function sendToAI(query){
                    var key = getApiKey();
                    var proxy = getProxyUrl();
                    if (!key && !proxy){ appendMsg('assistant', 'Set an API key or a proxy URL in  (recommended: proxy on your server).'); return; }
                    var meter = currentMeter();
                    var systemPrompt = 'You are a helpful GIS assistant for a flood exposure web app. Answer concisely. If asked about a meter, assume the selected meter is ' + (meter || 'unknown') + ' unless specified.';
                    var backoffs = [1000, 2000, 4000];
                    var warnedRateLimit = false;
                    try {
                        for (var i = 0; i <= backoffs.length; i++) {
                            var url = proxy || 'https://api.openai.com/v1/chat/completions';
                            var headers = { 'Content-Type': 'application/json' };
                            if (!proxy && key) headers['Authorization'] = 'Bearer ' + key;
                            var org = getOrgId();
                            var proj = getProjectId();
                            if (!proxy && org) headers['OpenAI-Organization'] = org;
                            if (!proxy && proj) headers['OpenAI-Project'] = proj;
                            var res = await fetch(url, {
                                method: 'POST',
                                headers: headers,
                                body: JSON.stringify({
                                    model: 'gpt-4o-mini',
                                    messages: [
                                        { role: 'system', content: systemPrompt },
                                        { role: 'user', content: query }
                                    ],
                                    temperature: 0.2,
                                    max_tokens: 400
                                })
                            });
                            if (res.ok) {
                                var data = await res.json();
                                var answer = (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) || 'No response';
                                try {
                                    var reqId = res.headers.get('x-request-id');
                                    var remReq = res.headers.get('x-ratelimit-remaining-requests');
                                    var remTok = res.headers.get('x-ratelimit-remaining-tokens');
                                    if (reqId) console.log('OpenAI x-request-id:', reqId);
                                    if (remReq || remTok) console.log('RateLimit remaining - requests:', remReq, 'tokens:', remTok);
                                } catch(_e){}
                                appendMsg('assistant', answer);
                                return;
                            }
                            if (res.status === 429 && i < backoffs.length) {
                                if (!warnedRateLimit) {
                                    var resetMs = res.headers.get('x-ratelimit-reset-requests');
                                    var waitHint = resetMs ? (' ~' + resetMs + 'ms') : '';
                                    appendMsg('assistant', 'Rate limit reached. Retrying' + waitHint + '...');
                                    warnedRateLimit = true;
                                }
                                await sleep(backoffs[i]);
                                continue;
                            }
                            // Non-retryable or final failure
                            throw new Error('HTTP ' + res.status);
                        }
                        // If we exit loop without return, treat as failure
                        throw new Error('HTTP 429');
                    } catch(err){
                        var msg = (err && err.message) ? err.message : String(err);
                        if (msg.indexOf('429') >= 0) {
                            appendMsg('assistant', 'Rate limit from API. Please wait a moment and try again.');
                        } else {
                            appendMsg('assistant', 'Error contacting AI: ' + msg);
                        }
                    }
                }

                if (toggle && !toggle._wired){
                    toggle.addEventListener('click', function(){
                        if (!panel) return;
                        var isOpen = panel.style.display === 'flex';
                        panel.style.display = isOpen ? 'none' : 'flex';
                        ensureKeyHint();
                    });
                    toggle._wired = true;
                }
                if (closeBtn && !closeBtn._wired){
                    closeBtn.addEventListener('click', function(){ if(panel) panel.style.display = 'none'; });
                    closeBtn._wired = true;
                }
                if (settings && !settings._wired){
                    settings.addEventListener('click', function(){
                        var currentKey = getApiKey();
                        var keyVal = prompt('OpenAI API key (stored locally). Leave blank if using a server proxy:', currentKey ? (currentKey.slice(0,3) + '...' + currentKey.slice(-4)) : '');
                        if (keyVal && keyVal.indexOf('...') < 0) setApiKey(keyVal); else if (!keyVal) setApiKey('');
                        var currentProxy = getProxyUrl();
                        var proxyVal = prompt('Proxy URL (optional, recommended). Example: https://your-domain.com/api/chat', currentProxy || '');
                        if (proxyVal !== null) setProxyUrl(proxyVal.trim());
                        var org = prompt('OpenAI Organization ID (optional):', getOrgId() || ''); if (org !== null) setOrgId(org.trim());
                        var proj = prompt('OpenAI Project ID (optional):', getProjectId() || ''); if (proj !== null) setProjectId(proj.trim());
                        ensureKeyHint();
                        if (!getProxyUrl() && getApiKey()) {
                            appendMsg('assistant', 'Note: Using a key in the browser is insecure. Prefer configuring a server proxy.');
                        }
                    });
                    settings._wired = true;
                }
                if (docsBtn && !docsBtn._wired){
                    docsBtn.addEventListener('click', function(){
                        try { window.open('Documentation.html#ai-proxy', '_blank'); } catch(e){}
                    });
                    docsBtn._wired = true;
                }
                function doSend(){
                    var q = (input && input.value || '').trim();
                    if (!q) return;
                    if (isSending) { return; }
                    isSending = true;
                    if (send) { send.disabled = true; }
                    appendMsg('user', q);
                    if (input) input.value = '';
                    Promise.resolve().then(function(){ return sendToAI(q); }).finally(function(){
                        isSending = false;
                        if (send) { send.disabled = false; }
                    });
                }
                if (send && !send._wired){ send.addEventListener('click', doSend); send._wired = true; }
                if (input && !input._wired){ input.addEventListener('keydown', function(e){ if(e.key==='Enter'){ doSend(); } }); input._wired = true; }
            })();

            // ESC to close whichever modal is open
            document.addEventListener('keydown', function(e){
                try {
                    if (e.key !== 'Escape') return;
                    var info = document.getElementById('infographics-modal');
                    var ir = document.getElementById('impact-report-modal');
                    if (ir && ir.style.display === 'flex') {
                        hideImpactReportModal();
                        return;
                    }
                    if (info && info.style.display === 'flex') {
                        hideInfographicsModal();
                        return;
                    }
                } catch (err) { /* ignore */ }
            });
        });
        </script>
        
        <!-- Bootstrap Offcanvas for Barangay Statistics -->
        <div class="offcanvas offcanvas-end" tabindex="-1" id="offcanvasRight" aria-labelledby="offcanvasRightLabel">
            <div class="offcanvas-header">
                <h5 class="offcanvas-title" id="offcanvasRightLabel">Selected Barangay/s Details</h5>
                <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
            </div>
            <div class="offcanvas-body">
                <!-- Charts Grid Container -->
                <div id="right-pane-charts-container">
                    <!-- Total Households Chart -->
                    <div class="right-pane-chart-wrapper">
                        <h4 style="color: #fafafa; font-size: 0.75rem; font-weight: 600;">Total Households</h4>
                        <div>
                            <canvas id="householdsChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Total Population Chart -->
                    <div class="right-pane-chart-wrapper">
                        <h4 style="color: #fafafa; font-size: 0.75rem; font-weight: 600;">Total Population</h4>
                        <div>
                            <canvas id="populationChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Group by Sex Chart -->
                    <div class="right-pane-chart-wrapper">
                        <h4 style="color: #fafafa; font-size: 0.75rem; font-weight: 600;">Group by Sex</h4>
                        <div>
                            <canvas id="sexChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Group by Age Chart -->
                    <div class="right-pane-chart-wrapper age-chart-wrapper">
                        <h4 style="color: #fafafa; font-size: 0.75rem; font-weight: 600;">Group by Age</h4>
                        <div>
                            <canvas id="ageChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </body>
        </html>
