import json
import csv
import re
# Read the CSV file
csv_data = {}
with open('layers/Joining Table.csv', 'r', encoding='utf-8') as f:
reader = csv.DictReader(f)
for row in reader:
# Clean up the FAMILY-ID (remove quotes and whitespace)
family_id = row['FAMILY-ID'].strip().strip('"')
barangay = row[' BARANGAY'].strip()  # Note: there's a leading space in the CSV header
# Store in a dictionary keyed by BARANGAY
# If multiple FAMILY-IDs exist for same BARANGAY, we'll use the first one
# You may need to adjust this logic based on your matching criteria
if barangay not in csv_data:
csv_data[barangay] = family_id
# Read the JS file
with open('layers/StoTomasHouseholdsjoined_layer_1.js', 'r', encoding='utf-8') as f:
content = f.read()
# Extract the JSON part (everything after the variable declaration)
match = re.search(r'var json_StoTomasHouseholdsjoined_layer_1 = ({.*});?\s*$', content, re.DOTALL)
if not match:
print("Error: Could not find JSON data in the JS file")
exit(1)
json_str = match.group(1)
geojson_data = json.loads(json_str)
# Update FAMILY-ID for each feature based on BARANGAY match
updated_count = 0
for feature in geojson_data['features']:
props = feature['properties']
barangay = props.get('BARANGAY', '').strip()
if barangay in csv_data:
old_family_id = props.get('FAMILY-ID', '')
new_family_id = csv_data[barangay]
props['FAMILY-ID'] = new_family_id
updated_count += 1
print(f"Updated feature fid={props.get('fid')}: BARANGAY={barangay}, FAMILY-ID: {old_family_id} -> {new_family_id}")
else:
print(f"Warning: No matching FAMILY-ID found for BARANGAY={barangay} (fid={props.get('fid')})")
# Write back to the JS file
new_content = 'var json_StoTomasHouseholdsjoined_layer_1 = ' + json.dumps(geojson_data, ensure_ascii=False) + ';'
with open('layers/StoTomasHouseholdsjoined_layer_1.js', 'w', encoding='utf-8') as f:
f.write(new_content)
print(f"\nTotal features updated: {updated_count}")
print(f"Total features in file: {len(geojson_data['features'])}")
import json
import csv
import re
from collections import defaultdict
def assign_family_ids_from_csv():
"""
Assigns unique FAMILY-ID values from Joining Table.csv to polygons in
StoTomasHouseholdsjoined_layer_1.js based on matching BARANGAY values.
For each polygon, it finds matching BARANGAY in CSV and assigns a unique
FAMILY-ID that hasn't been used yet for that BARANGAY.
"""
# Step 1: Read CSV and group FAMILY-IDs by BARANGAY
print("Reading CSV file...")
barangay_family_ids = defaultdict(list)  # {BARANGAY: [list of FAMILY-IDs]}
with open('layers/Joining Table.csv', 'r', encoding='utf-8') as f:
reader = csv.DictReader(f)
for row in reader:
# Clean up the values (remove quotes and whitespace)
family_id = row['FAMILY-ID'].strip().strip('"')
barangay = row[' BARANGAY'].strip()  # Note: leading space in CSV header
if family_id and barangay:
barangay_family_ids[barangay].append(family_id)
print(f"Found {len(barangay_family_ids)} unique BARANGAY values in CSV")
print(f"Total FAMILY-ID entries: {sum(len(ids) for ids in barangay_family_ids.values())}")
# Step 2: Read the JS file
print("\nReading JS file...")
with open('layers/StoTomasHouseholdsjoined_layer_1.js', 'r', encoding='utf-8') as f:
content = f.read()
# Extract the JSON part
match = re.search(r'var json_StoTomasHouseholdsjoined_layer_1 = ({.*});?\s*$', content, re.DOTALL)
if not match:
raise ValueError("Could not find JSON data in the JS file")
json_str = match.group(1)
geojson_data = json.loads(json_str)
# Step 3: Track used FAMILY-IDs per BARANGAY to ensure uniqueness
used_family_ids = defaultdict(set)  # {BARANGAY: {set of used FAMILY-IDs}}
assignment_stats = {
'updated': 0,
'no_match': 0,
'exhausted': 0  # When all FAMILY-IDs for a BARANGAY are used
}
# Step 4: Assign FAMILY-IDs to each polygon
print("\nAssigning FAMILY-IDs to polygons...")
for feature in geojson_data['features']:
props = feature['properties']
fid = props.get('fid', 'unknown')
barangay = props.get('BARANGAY', '').strip()
old_family_id = props.get('FAMILY-ID', '')
if not barangay:
print(f"Warning: Feature fid={fid} has no BARANGAY value")
assignment_stats['no_match'] += 1
continue
# Find available FAMILY-IDs for this BARANGAY
if barangay in barangay_family_ids:
available_ids = barangay_family_ids[barangay]
used_ids = used_family_ids[barangay]
# Find the first available FAMILY-ID that hasn't been used
new_family_id = None
for family_id in available_ids:
if family_id not in used_ids:
new_family_id = family_id
used_ids.add(family_id)
break
if new_family_id:
props['FAMILY-ID'] = new_family_id
assignment_stats['updated'] += 1
if assignment_stats['updated'] <= 10:  # Print first 10 for verification
print(f"  fid={fid}: BARANGAY='{barangay}', FAMILY-ID: {old_family_id} -> {new_family_id}")
else:
# All FAMILY-IDs for this BARANGAY have been used
print(f"  Warning: fid={fid}: All FAMILY-IDs exhausted for BARANGAY='{barangay}'")
assignment_stats['exhausted'] += 1
else:
print(f"  Warning: fid={fid}: No matching BARANGAY='{barangay}' found in CSV")
assignment_stats['no_match'] += 1
# Step 5: Write back to the JS file
print("\nWriting updated data to JS file...")
new_content = 'var json_StoTomasHouseholdsjoined_layer_1 = ' + json.dumps(geojson_data, ensure_ascii=False, separators=(',', ':')) + ';'
with open('layers/StoTomasHouseholdsjoined_layer_1.js', 'w', encoding='utf-8') as f:
f.write(new_content)
# Step 6: Print summary
print("\n" + "="*60)
print("ASSIGNMENT SUMMARY")
print("="*60)
print(f"Total features processed: {len(geojson_data['features'])}")
print(f"Successfully updated: {assignment_stats['updated']}")
print(f"No BARANGAY match in CSV: {assignment_stats['no_match']}")
print(f"FAMILY-IDs exhausted (more polygons than available IDs): {assignment_stats['exhausted']}")
print("="*60)
# Additional statistics
print("\nBARANGAY Usage Statistics:")
for barangay, used_set in sorted(used_family_ids.items()):
total_available = len(barangay_family_ids.get(barangay, []))
used_count = len(used_set)
print(f"  {barangay}: {used_count}/{total_available} FAMILY-IDs used")
return assignment_stats
# Main execution
if __name__ == "__main__":
try:
# Create backup first
import shutil
backup_path = 'layers/StoTomasHouseholdsjoined_layer_1.js.backup'
shutil.copy('layers/StoTomasHouseholdsjoined_layer_1.js', backup_path)
print(f"Backup created: {backup_path}\n")
# Run the assignment function
stats = assign_family_ids_from_csv()
print("\n✓ Process completed successfully!")
print(f"✓ Backup saved to: {backup_path}")
except FileNotFoundError as e:
print(f"Error: File not found - {e}")
print("Make sure you're running this script from the project root directory.")
except json.JSONDecodeError as e:
print(f"Error: Failed to parse JSON - {e}")
except Exception as e:
print(f"Error: {e}")
import traceback
traceback.print_exc()
import json
import csv
import re
from collections import defaultdict
def assign_family_ids_from_csv():
"""
Assigns unique FAMILY-ID values from Joining Table.csv to polygons in
StoTomasHouseholdsjoined_layer_1.js based on matching BARANGAY values.
For each polygon, it finds matching BARANGAY in CSV and assigns a unique
FAMILY-ID that hasn't been used yet for that BARANGAY.
"""
# Step 1: Read CSV and group FAMILY-IDs by BARANGAY
print("Reading CSV file...")
barangay_family_ids = defaultdict(list)  # {BARANGAY: [list of FAMILY-IDs]}
with open('layers/Joining Table.csv', 'r', encoding='utf-8') as f:
reader = csv.DictReader(f)
for row in reader:
# Clean up the values (remove quotes and whitespace)
family_id = row['FAMILY-ID'].strip().strip('"')
barangay = row[' BARANGAY'].strip()  # Note: leading space in CSV header
if family_id and barangay:
barangay_family_ids[barangay].append(family_id)
print(f"Found {len(barangay_family_ids)} unique BARANGAY values in CSV")
print(f"Total FAMILY-ID entries: {sum(len(ids) for ids in barangay_family_ids.values())}")
# Step 2: Read the JS file
print("\nReading JS file...")
with open('layers/StoTomasHouseholdsjoined_layer_1.js', 'r', encoding='utf-8') as f:
content = f.read()
# Extract the JSON part
match = re.search(r'var json_StoTomasHouseholdsjoined_layer_1 = ({.*});?\s*$', content, re.DOTALL)
if not match:
raise ValueError("Could not find JSON data in the JS file")
json_str = match.group(1)
geojson_data = json.loads(json_str)
# Step 3: Track used FAMILY-IDs per BARANGAY to ensure uniqueness
used_family_ids = defaultdict(set)  # {BARANGAY: {set of used FAMILY-IDs}}
assignment_stats = {
'updated': 0,
'no_match': 0,
'exhausted': 0  # When all FAMILY-IDs for a BARANGAY are used
}
# Step 4: Assign FAMILY-IDs to each polygon
print("\nAssigning FAMILY-IDs to polygons...")
for feature in geojson_data['features']:
props = feature['properties']
fid = props.get('fid', 'unknown')
barangay = props.get('BARANGAY', '').strip()
old_family_id = props.get('FAMILY-ID', '')
if not barangay:
print(f"Warning: Feature fid={fid} has no BARANGAY value")
assignment_stats['no_match'] += 1
continue
# Find available FAMILY-IDs for this BARANGAY
if barangay in barangay_family_ids:
available_ids = barangay_family_ids[barangay]
used_ids = used_family_ids[barangay]
# Find the first available FAMILY-ID that hasn't been used
new_family_id = None
for family_id in available_ids:
if family_id not in used_ids:
new_family_id = family_id
used_ids.add(family_id)
break
if new_family_id:
props['FAMILY-ID'] = new_family_id
assignment_stats['updated'] += 1
if assignment_stats['updated'] <= 10:  # Print first 10 for verification
print(f"  fid={fid}: BARANGAY='{barangay}', FAMILY-ID: {old_family_id} -> {new_family_id}")
else:
# All FAMILY-IDs for this BARANGAY have been used
print(f"  Warning: fid={fid}: All FAMILY-IDs exhausted for BARANGAY='{barangay}'")
assignment_stats['exhausted'] += 1
else:
print(f"  Warning: fid={fid}: No matching BARANGAY='{barangay}' found in CSV")
assignment_stats['no_match'] += 1
# Step 5: Write back to the JS file
print("\nWriting updated data to JS file...")
new_content = 'var json_StoTomasHouseholdsjoined_layer_1 = ' + json.dumps(geojson_data, ensure_ascii=False, separators=(',', ':')) + ';'
with open('layers/StoTomasHouseholdsjoined_layer_1.js', 'w', encoding='utf-8') as f:
f.write(new_content)
# Step 6: Print summary
print("\n" + "="*60)
print("ASSIGNMENT SUMMARY")
print("="*60)
print(f"Total features processed: {len(geojson_data['features'])}")
print(f"Successfully updated: {assignment_stats['updated']}")
print(f"No BARANGAY match in CSV: {assignment_stats['no_match']}")
print(f"FAMILY-IDs exhausted (more polygons than available IDs): {assignment_stats['exhausted']}")
print("="*60)
# Additional statistics
print("\nBARANGAY Usage Statistics:")
for barangay, used_set in sorted(used_family_ids.items()):
total_available = len(barangay_family_ids.get(barangay, []))
used_count = len(used_set)
print(f"  {barangay}: {used_count}/{total_available} FAMILY-IDs used")
return assignment_stats
# Main execution
if __name__ == "__main__":
try:
# Create backup first
import shutil
backup_path = 'layers/StoTomasHouseholdsjoined_layer_1.js.backup'
shutil.copy('layers/StoTomasHouseholdsjoined_layer_1.js', backup_path)
print(f"Backup created: {backup_path}\n")
# Run the assignment function
stats = assign_family_ids_from_csv()
print("\n✓ Process completed successfully!")
print(f"✓ Backup saved to: {backup_path}")
except FileNotFoundError as e:
print(f"Error: File not found - {e}")
print("Make sure you're running this script from the project root directory.")
except json.JSONDecodeError as e:
print(f"Error: Failed to parse JSON - {e}")
except Exception as e:
print(f"Error: {e}")
import traceback
traceback.print_exc()
